\documentclass[9pt,authoryear]{sigplanconf}

\usepackage{color}
\usepackage{amssymb}
\usepackage{amsmath}
\usepackage{epsdice}
\usepackage{bbm}
\usepackage{dsfont}
\usepackage{stmaryrd}
\DeclareTextSymbol\nptextcrlambda{T3}{172}
\DeclareTextSymbolDefault\nptextcrlambda{T3}
\DeclareFontFamily{U}{npmathb}{\hyphenchar\font45}
\DeclareFontShape{U}{npmathb}{m}{n}{
      <5> <6> <7> <8> <9> <10> gen * mathb
      <10.95> mathb10 <12> <14.4> <17.28> <20.74> <24.88> mathb12
      }{}
\DeclareSymbolFont{npmathb}{U}{npmathb}{m}{n}
\DeclareFontSubstitution{U}{npmathb}{m}{n}
\DeclareMathSymbol{\npbigstar}   {2}{npmathb}{"0E} % to fool the highlighter => "
\DeclareMathSymbol{\npdotdiv}    {2}{npmathb}{"01} % to fool the highlighter => "

\DeclareFontFamily{U}{matha}{\hyphenchar\font45}
\DeclareFontShape{U}{matha}{m}{n}{
      <5> <6> <7> <8> <9> <10> gen * matha
      <10.95> matha10 <12> <14.4> <17.28> <20.74> <24.88> matha12
      }{}
\DeclareSymbolFont{matha}{U}{matha}{m}{n}
\DeclareFontSubstitution{U}{matha}{m}{n}
\DeclareMathSymbol{\npoasterisk} {2}{matha}{"66} % to fool the highlighter => "
\DeclareMathSymbol{\npnotequiv}  {3}{matha}{"19} % to fool the highlighter => "
\title{Names For Free --- Polymorphic Views of Names and Binders}

\special{papersize=8.5in,11in}
\setlength{\pdfpageheight}{\paperheight}
\setlength{\pdfpagewidth}{\paperwidth}
\hyphenation{crypto--graphic}
\exclusivelicense
\conferenceinfo{Haskell{~}{'}13}{September 23--24 2013, Boston, MA, USA}
\copyrightyear{2013}
\copyrightdata{978-1-4503-2383-3/13/09}
\doi{2503778.2503780}
\authorinfo{Jean-Philippe Bernardy}{Chalmers University of Technology and University of Gothenburg}{bernardy@chalmers.se}
\authorinfo{Nicolas Pouillard}{IT University of Copenhagen}{npou@itu.dk}

\begin{document}

\maketitle

\begin{abstract}
We propose a novel technique to represent names and binders in
Haskell. The dynamic (run-time) representation is based on de Bruijn
indices, but it features an interface to write and manipulate
variables conviently, using Haskell-level lambdas and variables. The
key idea is to use rich types: a subterm with an additional free variable
is viewed either as $\forall v. v \rightarrow \mathsf{Term} (a + v)$
or $\exists v. v \times \mathsf{Term} (a + v)$ depending on whether it
is constructed or analysed. We demonstrate on a number of examples how
this approach permits to express term construction and manipulation in
a natural way, while retaining the good properties of representations
based on de Bruijn indices.

\end{abstract}

\category{D.3.3}{Language Constructs and Features}{}

\begin{keywords}name binding,
polymorphism,
parametricity,
type-classes,
nested types\end{keywords}

\section{Introduction\label{intro}}

%
%paragraphName: the line of work where we belong
One of the main application areas of functional programming
    languages such as \textsc{Haskell} is programming language technology.
    In particular, \textsc{Haskell} programmers often find themselves
    manipulating data structures representing some higher-order object
    languages, featuring binders and names.%


%
%paragraphName: identifying the gap
Yet, the most commonly used representations for names and binders
    yield code which is difficult to read, or error-prone to write
    and maintain. The techniques in question are often referred as
    {``}nominal{''}, {``}de{~}Bruijn indices{''} and {``}Higher-Order Abstract Syntax
    (HOAS){''}.%


%
%paragraphName: Nominal pros&cons
In the nominal approach, one typically uses some atomic type to
    represent names. Because a name is simply referred to the atom
    representing it, the nominal style is natural. The main issues
    with this technique are that variables must sometimes be renamed
    in order to avoid name capture (that is, if a binder refers to an
    already used name, variables might end up referring to the wrong
    binder). The need for renaming demands a way to generate fresh
    atoms. This side effect can be resolved with a supply for unique
    atoms or using an abstraction such as a monad but is disturbing
    if one wishes to write functional code. Additionally, nominal
    representations are not canonical. (For instance, two $ \alpha $-equivalent
    representations of the same term such as \texttt{$ \lambda $}\texttt{x}\texttt{.}\texttt{x} and \texttt{$ \lambda $}\texttt{y}\texttt{.}\texttt{y}    may be different). Hence special care has to be taken to prevent
    user code to violate the abstraction barrier. Furthermore fresh
    name generation is an observable effect breaking referential
    transparency (\texttt{fresh}\texttt{\mbox{\hspace{0.50em}}}\texttt{x}\texttt{\mbox{\hspace{0.50em}}}\texttt{in}\texttt{\mbox{\hspace{0.50em}}}\texttt{x}\texttt{\mbox{\hspace{0.50em}}}\texttt{\ensuremath{\npnotequiv}}\texttt{\mbox{\hspace{0.50em}}}\texttt{fresh}\texttt{\mbox{\hspace{0.50em}}}\texttt{x}\texttt{\mbox{\hspace{0.50em}}}\texttt{in}\texttt{\mbox{\hspace{0.50em}}}\texttt{x}). For instance a
    function generating fresh names and not properly using them to close
    abstractions becomes impure.%


%
%paragraphName: de Bruijn pros&cons
To avoid the problem of name capture, one can represent names
    canonically, for example by the number of binders, typically $ \lambda $,
    to cross between an occurrence and its binding site (a de{~}Bruijn
    index). This has the added benefit of making $ \alpha $-equivalent terms
    syntactically equal. In practice however, this representation makes
    it hard to manipulate terms{:} instead of calling things by name,
    programmers have to rely on their arithmetic abilities, which turns
    out to be error-prone. As soon as one has to deal with more than
    just a couple open bindings, it becomes easy to make mistakes.%


%
%paragraphName: HOAS
Finally, one can use the binders of the host language (in our case
    \textsc{Haskell}) to represent binders of the object language. This
    technique (called HOAS) does not suffer from name-capture problems
    nor does it involve arithmetic. However the presence of functions in
    the term representation mean that it is difficult to manipulate, and
    it may contain values which do not represent any term.%


%
%paragraphName: contribution
The contribution of this paper is a new programming interface for
    binders, which provides the ability to write terms in a natural
    style close to concrete syntax. We can for example build the
    application function of the untyped $ \lambda $-calculus as follows{:}%


%
%comment: {- --
%


{\nopagebreak }

%
%code:
%
%comment: -- Building the following term: \ f x → f x
%apTm = lam $ \ f → lam $ \ x → var f `App` var x
%
~\\~\vphantom{$\{$}\texttt{\makebox[1.22ex][c]{-}\makebox[1.22ex][c]{-}\mbox{\hspace{0.50em}}Building\mbox{\hspace{0.50em}}the\mbox{\hspace{0.50em}}following\mbox{\hspace{0.50em}}term{:}\mbox{\hspace{0.50em}}$ \lambda $\mbox{\hspace{0.50em}}f\mbox{\hspace{0.50em}}x\mbox{\hspace{0.50em}}$ \rightarrow $\mbox{\hspace{0.50em}}f\mbox{\hspace{0.50em}}x}\texttt{{\nopagebreak \newline%
}\vphantom{$\{$}}\texttt{apTm}\texttt{\mbox{\hspace{0.50em}}}\texttt{{\char `\=}}\texttt{\mbox{\hspace{0.50em}}}\texttt{lam}\texttt{\mbox{\hspace{0.50em}}}\texttt{\${}}\texttt{\mbox{\hspace{0.50em}}}\texttt{$ \lambda $}\texttt{\mbox{\hspace{0.50em}}}\texttt{f}\texttt{\mbox{\hspace{0.50em}}}\texttt{$ \rightarrow $}\texttt{\mbox{\hspace{0.50em}}}\texttt{lam}\texttt{\mbox{\hspace{0.50em}}}\texttt{\${}}\texttt{\mbox{\hspace{0.50em}}}\texttt{$ \lambda $}\texttt{\mbox{\hspace{0.50em}}}\texttt{x}\texttt{\mbox{\hspace{0.50em}}}\texttt{$ \rightarrow $}\texttt{\mbox{\hspace{0.50em}}}\texttt{var}\texttt{\mbox{\hspace{0.50em}}}\texttt{f}\texttt{\mbox{\hspace{0.50em}}}\texttt{{`}App{`}}\texttt{\mbox{\hspace{0.50em}}}\texttt{var}\texttt{\mbox{\hspace{0.50em}}}\texttt{x}\texttt{{\nopagebreak \newline%
}\vphantom{$\{$}}%


%
%comment: -- -}
%


%
%paragraphName:
and we are able to test if a term is eta-contractible using the
    following function{:}%


%
%comment: {- --
%


{\nopagebreak }

%
%code:
%
%comment: canEta (Lam e) = unpack e $ \ x t → case t of
%  App e1 (Var y) → y `isOccurenceOf` x &&
%                    x `freshFor` e1
%  _ → False
%canEta _ = False
%
~\\~\vphantom{$\{$}\texttt{canEta}\texttt{\mbox{\hspace{0.50em}}}\texttt{\makebox[1.22ex][l]{$ {(} $}}\texttt{Lam}\texttt{\mbox{\hspace{0.50em}}}\texttt{e}\texttt{\makebox[1.22ex][r]{$ {)} $}}\texttt{\mbox{\hspace{0.50em}}}\texttt{{\char `\=}}\texttt{\mbox{\hspace{0.50em}}}\texttt{unpack}\texttt{\mbox{\hspace{0.50em}}}\texttt{e}\texttt{\mbox{\hspace{0.50em}}}\texttt{\${}}\texttt{\mbox{\hspace{0.50em}}}\texttt{$ \lambda $}\texttt{\mbox{\hspace{0.50em}}}\texttt{x}\texttt{\mbox{\hspace{0.50em}}}\texttt{t}\texttt{\mbox{\hspace{0.50em}}}\texttt{$ \rightarrow $}\texttt{\mbox{\hspace{0.50em}}}\texttt{case}\texttt{\mbox{\hspace{0.50em}}}\texttt{t}\texttt{\mbox{\hspace{0.50em}}}\texttt{of}\texttt{{\nopagebreak \newline%
}\vphantom{$\{$}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{App}\texttt{\mbox{\hspace{0.50em}}}\texttt{e1}\texttt{\mbox{\hspace{0.50em}}}\texttt{\makebox[1.22ex][l]{$ {(} $}}\texttt{Var}\texttt{\mbox{\hspace{0.50em}}}\texttt{y}\texttt{\makebox[1.22ex][r]{$ {)} $}}\texttt{\mbox{\hspace{0.50em}}}\texttt{$ \rightarrow $}\texttt{\mbox{\hspace{0.50em}}}\texttt{y}\texttt{\mbox{\hspace{0.50em}}}\texttt{{`}isOccurenceOf{`}}\texttt{\mbox{\hspace{0.50em}}}\texttt{x}\texttt{\mbox{\hspace{0.50em}}}\texttt{\&{}\&{}}\texttt{{\nopagebreak \newline%
}\vphantom{$\{$}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{x}\texttt{\mbox{\hspace{0.50em}}}\texttt{{`}freshFor{`}}\texttt{\mbox{\hspace{0.50em}}}\texttt{e1}\texttt{{\nopagebreak \newline%
}\vphantom{$\{$}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\makebox[1.22ex][c]{\_{}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{$ \rightarrow $}\texttt{\mbox{\hspace{0.50em}}}\texttt{False}\texttt{{\nopagebreak \newline%
}\vphantom{$\{$}}\texttt{canEta}\texttt{\mbox{\hspace{0.50em}}}\texttt{\makebox[1.22ex][c]{\_{}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{{\char `\=}}\texttt{\mbox{\hspace{0.50em}}}\texttt{False}\texttt{{\nopagebreak \newline%
}\vphantom{$\{$}}%


%
%comment: -- -}
%


%
%paragraphName: contribution continued
All the while, neither do we require a name supply, nor is there
    a risk for name capture. Testing terms for $ \alpha $-equivalence remains
    straightforward and representable terms are exactly those intended.
    The cost of this achievement is the use of somewhat more involved
    types for binders, and the use of extensions of the \textsc{Haskell}    type-system. The new construction is informally described and
    motivated in sec. \ref{overview}. In sections \ref{contextSec} to
    \ref{scopesSec} we present in detail the implementation of the
    technique as well as basic applications. Larger applications such as
    normalization (using hereditary substitutions), closure conversion
    and CPS transformation are presented in sec. \ref{examples}.%


\section{Overview\label{overview}}

%
%paragraphName: flow
In this section we describe our interface, but before doing so we 
    describe a simple implementation which can support this interface.%


\subsection{de{~}Bruijn Indices}

%
%paragraphName: de Bruijn indices
\Citet{de_bruijn_lambda_1972} proposed to represent an occurrence
    of some variable{~}\texttt{x} by counting the number of binders that one
    has to cross between the occurrence and the binding site of{~}\texttt{x}.
    A direct implementation of the idea may yield the following
    representation of untyped $ \lambda $-terms{:}%


{\nopagebreak }

%
%code:
%
%comment: data Nat = O | S Nat
%data TmB where
%  VarB :: Nat → TmB
%  AppB :: TmB → TmB → TmB
%  LamB :: TmB → TmB
%
~\\~\vphantom{$\{$}\texttt{data}\texttt{\mbox{\hspace{0.50em}}}\texttt{Nat}\texttt{\mbox{\hspace{0.50em}}}\texttt{{\char `\=}}\texttt{\mbox{\hspace{0.50em}}}\texttt{O}\texttt{\mbox{\hspace{0.50em}}}\texttt{\makebox[1.22ex][c]{\textbar{}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{S}\texttt{\mbox{\hspace{0.50em}}}\texttt{Nat}\texttt{{\nopagebreak \newline%
}\vphantom{$\{$}}\texttt{data}\texttt{\mbox{\hspace{0.50em}}}\texttt{TmB}\texttt{\mbox{\hspace{0.50em}}}\texttt{where}\texttt{{\nopagebreak \newline%
}\vphantom{$\{$}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{VarB}\texttt{\mbox{\hspace{0.50em}}}\texttt{{:}{:}}\texttt{\mbox{\hspace{0.50em}}}\texttt{Nat}\texttt{\mbox{\hspace{0.50em}}}\texttt{$ \rightarrow $}\texttt{\mbox{\hspace{0.50em}}}\texttt{TmB}\texttt{{\nopagebreak \newline%
}\vphantom{$\{$}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{AppB}\texttt{\mbox{\hspace{0.50em}}}\texttt{{:}{:}}\texttt{\mbox{\hspace{0.50em}}}\texttt{TmB}\texttt{\mbox{\hspace{0.50em}}}\texttt{$ \rightarrow $}\texttt{\mbox{\hspace{0.50em}}}\texttt{TmB}\texttt{\mbox{\hspace{0.50em}}}\texttt{$ \rightarrow $}\texttt{\mbox{\hspace{0.50em}}}\texttt{TmB}\texttt{{\nopagebreak \newline%
}\vphantom{$\{$}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{LamB}\texttt{\mbox{\hspace{0.50em}}}\texttt{{:}{:}}\texttt{\mbox{\hspace{0.50em}}}\texttt{TmB}\texttt{\mbox{\hspace{0.50em}}}\texttt{$ \rightarrow $}\texttt{\mbox{\hspace{0.50em}}}\texttt{TmB}\texttt{{\nopagebreak \newline%
}\vphantom{$\{$}}%


%
%paragraphName: apB
Using this representation, the implementation of the application
    function{~}\texttt{$ \lambda $}\texttt{\mbox{\hspace{0.50em}}}\texttt{f}\texttt{\mbox{\hspace{0.50em}}}\texttt{x}\texttt{\mbox{\hspace{0.50em}}}\texttt{$ \rightarrow $}\texttt{\mbox{\hspace{0.50em}}}\texttt{f}\texttt{\mbox{\hspace{0.50em}}}\texttt{x} is the following{:}%


{\nopagebreak }

%
%code:
%
%comment: apB :: TmB
%apB = LamB $ LamB $ VarB (S O) `AppB` VarB O
%
~\\~\vphantom{$\{$}\texttt{apB}\texttt{\mbox{\hspace{0.50em}}}\texttt{{:}{:}}\texttt{\mbox{\hspace{0.50em}}}\texttt{TmB}\texttt{{\nopagebreak \newline%
}\vphantom{$\{$}}\texttt{apB}\texttt{\mbox{\hspace{0.50em}}}\texttt{{\char `\=}}\texttt{\mbox{\hspace{0.50em}}}\texttt{LamB}\texttt{\mbox{\hspace{0.50em}}}\texttt{\${}}\texttt{\mbox{\hspace{0.50em}}}\texttt{LamB}\texttt{\mbox{\hspace{0.50em}}}\texttt{\${}}\texttt{\mbox{\hspace{0.50em}}}\texttt{VarB}\texttt{\mbox{\hspace{0.50em}}}\texttt{\makebox[1.22ex][l]{$ {(} $}}\texttt{S}\texttt{\mbox{\hspace{0.50em}}}\texttt{O}\texttt{\makebox[1.22ex][r]{$ {)} $}}\texttt{\mbox{\hspace{0.50em}}}\texttt{{`}AppB{`}}\texttt{\mbox{\hspace{0.50em}}}\texttt{VarB}\texttt{\mbox{\hspace{0.50em}}}\texttt{O}\texttt{{\nopagebreak \newline%
}\vphantom{$\{$}}%


%
%paragraphName: no static scoping
However, such a direct implementation is cumbersome and na\"{i}ve. For
    instance it cannot statically distinguish bound and free variables.
    That is, a closed term has the same type as an open term.%


\paragraph*{Nested Abstract Syntax}

%
%paragraphName: nested data types
In functional programming languages such as \textsc{Haskell}, it is
    possible to remedy to this situation by using nested data types
    and polymorphic recursion. That is, one parameterizes the type of
    terms by a type that can represent \emph{free} variables. If the
    parameter is the empty type, terms are closed. If the parameter is
    the unit type, there is at most one free variable, etc.
    This representation is known as Nested Abstract Syntax{~}\cite{bellegarde-94,bird-paterson-99,altenkirch-reus-99}.%


{\nopagebreak }

%
%code:
%
%comment: data Tm a where
%  Var :: a → Tm a
%  App :: Tm a → Tm a → Tm a
%  Lam :: Tm (Succ a) → Tm a
%
~\\~\vphantom{$\{$}\texttt{data}\texttt{\mbox{\hspace{0.50em}}}\texttt{Tm}\texttt{\mbox{\hspace{0.50em}}}\texttt{a}\texttt{\mbox{\hspace{0.50em}}}\texttt{where}\texttt{{\nopagebreak \newline%
}\vphantom{$\{$}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{Var}\texttt{\mbox{\hspace{0.50em}}}\texttt{{:}{:}}\texttt{\mbox{\hspace{0.50em}}}\texttt{a}\texttt{\mbox{\hspace{0.50em}}}\texttt{$ \rightarrow $}\texttt{\mbox{\hspace{0.50em}}}\texttt{Tm}\texttt{\mbox{\hspace{0.50em}}}\texttt{a}\texttt{{\nopagebreak \newline%
}\vphantom{$\{$}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{App}\texttt{\mbox{\hspace{0.50em}}}\texttt{{:}{:}}\texttt{\mbox{\hspace{0.50em}}}\texttt{Tm}\texttt{\mbox{\hspace{0.50em}}}\texttt{a}\texttt{\mbox{\hspace{0.50em}}}\texttt{$ \rightarrow $}\texttt{\mbox{\hspace{0.50em}}}\texttt{Tm}\texttt{\mbox{\hspace{0.50em}}}\texttt{a}\texttt{\mbox{\hspace{0.50em}}}\texttt{$ \rightarrow $}\texttt{\mbox{\hspace{0.50em}}}\texttt{Tm}\texttt{\mbox{\hspace{0.50em}}}\texttt{a}\texttt{{\nopagebreak \newline%
}\vphantom{$\{$}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{Lam}\texttt{\mbox{\hspace{0.50em}}}\texttt{{:}{:}}\texttt{\mbox{\hspace{0.50em}}}\texttt{Tm}\texttt{\mbox{\hspace{0.50em}}}\texttt{\makebox[1.22ex][l]{$ {(} $}}\texttt{Succ}\texttt{\mbox{\hspace{0.50em}}}\texttt{a}\texttt{\makebox[1.22ex][r]{$ {)} $}}\texttt{\mbox{\hspace{0.50em}}}\texttt{$ \rightarrow $}\texttt{\mbox{\hspace{0.50em}}}\texttt{Tm}\texttt{\mbox{\hspace{0.50em}}}\texttt{a}\texttt{{\nopagebreak \newline%
}\vphantom{$\{$}}%


%
%paragraphName: the type of Lam
The recursive case{~}\texttt{Lam} changes the type parameter, increasing
    its cardinality by one, since the body can refer to one more
    variable. Anticipating the amendments we propose, we define the
    type{~}\texttt{Succ}\texttt{\mbox{\hspace{0.50em}}}\texttt{a} as a proper sum of{~}\texttt{a} and the unit type{~}\texttt{\makebox[1.22ex][l]{$ {(} $}}\texttt{\makebox[1.22ex][r]{$ {)} $}}    instead of{~}\texttt{Maybe}\texttt{\mbox{\hspace{0.50em}}}\texttt{a} as customary. Because the sum is used in an
    asymmetric fashion (the left-hand-side corresponds to variables
    bound earlier and the right-hand-side to the freshly bound one),
    we give a special definition of sum written{~}\texttt{$ \vartriangleright $}, whose syntax
    reflects the intended semantics.%


{\nopagebreak }

%
%code:
%
%comment: type Succ a = a :▹ ()
%
%data a :▹ v  = Old a | New v
%
%mapOld :: (a → a') → (a :▹ v) → (a' :▹ v)
%mapOld f (Old x) = Old (f x)
%mapOld _ (New x) = New x
%
%mapNew :: (v → v') → (a :▹ v) → (a :▹ v')
%mapNew _ (Old x) = Old x
%mapNew f (New x) = New (f x)
%
~\\~\vphantom{$\{$}\texttt{type}\texttt{\mbox{\hspace{0.50em}}}\texttt{Succ}\texttt{\mbox{\hspace{0.50em}}}\texttt{a}\texttt{\mbox{\hspace{0.50em}}}\texttt{{\char `\=}}\texttt{\mbox{\hspace{0.50em}}}\texttt{a}\texttt{\mbox{\hspace{0.50em}}}\texttt{$ \vartriangleright $}\texttt{\mbox{\hspace{0.50em}}}\texttt{\makebox[1.22ex][l]{$ {(} $}}\texttt{\makebox[1.22ex][r]{$ {)} $}}\texttt{{\nopagebreak \newline%
}\vphantom{$\{$}}\texttt{{\nopagebreak \newline%
}\vphantom{$\{$}}\texttt{data}\texttt{\mbox{\hspace{0.50em}}}\texttt{a}\texttt{\mbox{\hspace{0.50em}}}\texttt{$ \vartriangleright $}\texttt{\mbox{\hspace{0.50em}}}\texttt{v}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{{\char `\=}}\texttt{\mbox{\hspace{0.50em}}}\texttt{Old}\texttt{\mbox{\hspace{0.50em}}}\texttt{a}\texttt{\mbox{\hspace{0.50em}}}\texttt{\makebox[1.22ex][c]{\textbar{}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{New}\texttt{\mbox{\hspace{0.50em}}}\texttt{v}\texttt{{\nopagebreak \newline%
}\vphantom{$\{$}}\texttt{{\nopagebreak \newline%
}\vphantom{$\{$}}\texttt{mapOld}\texttt{\mbox{\hspace{0.50em}}}\texttt{{:}{:}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\makebox[1.22ex][l]{$ {(} $}}\texttt{a}\texttt{\mbox{\hspace{0.50em}}}\texttt{$ \rightarrow $}\texttt{\mbox{\hspace{0.50em}}}\texttt{a{'}}\texttt{\makebox[1.22ex][r]{$ {)} $}}\texttt{\mbox{\hspace{0.50em}}}\texttt{$ \rightarrow $}\texttt{\mbox{\hspace{0.50em}}}\texttt{\makebox[1.22ex][l]{$ {(} $}}\texttt{a}\texttt{\mbox{\hspace{0.50em}}}\texttt{$ \vartriangleright $}\texttt{\mbox{\hspace{0.50em}}}\texttt{v}\texttt{\makebox[1.22ex][r]{$ {)} $}}\texttt{\mbox{\hspace{0.50em}}}\texttt{$ \rightarrow $}\texttt{\mbox{\hspace{0.50em}}}\texttt{\makebox[1.22ex][l]{$ {(} $}}\texttt{a{'}}\texttt{\mbox{\hspace{0.50em}}}\texttt{$ \vartriangleright $}\texttt{\mbox{\hspace{0.50em}}}\texttt{v}\texttt{\makebox[1.22ex][r]{$ {)} $}}\texttt{{\nopagebreak \newline%
}\vphantom{$\{$}}\texttt{mapOld}\texttt{\mbox{\hspace{0.50em}}}\texttt{f}\texttt{\mbox{\hspace{0.50em}}}\texttt{\makebox[1.22ex][l]{$ {(} $}}\texttt{Old}\texttt{\mbox{\hspace{0.50em}}}\texttt{x}\texttt{\makebox[1.22ex][r]{$ {)} $}}\texttt{\mbox{\hspace{0.50em}}}\texttt{{\char `\=}}\texttt{\mbox{\hspace{0.50em}}}\texttt{Old}\texttt{\mbox{\hspace{0.50em}}}\texttt{\makebox[1.22ex][l]{$ {(} $}}\texttt{f}\texttt{\mbox{\hspace{0.50em}}}\texttt{x}\texttt{\makebox[1.22ex][r]{$ {)} $}}\texttt{{\nopagebreak \newline%
}\vphantom{$\{$}}\texttt{mapOld}\texttt{\mbox{\hspace{0.50em}}}\texttt{\makebox[1.22ex][c]{\_{}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\makebox[1.22ex][l]{$ {(} $}}\texttt{New}\texttt{\mbox{\hspace{0.50em}}}\texttt{x}\texttt{\makebox[1.22ex][r]{$ {)} $}}\texttt{\mbox{\hspace{0.50em}}}\texttt{{\char `\=}}\texttt{\mbox{\hspace{0.50em}}}\texttt{New}\texttt{\mbox{\hspace{0.50em}}}\texttt{x}\texttt{{\nopagebreak \newline%
}\vphantom{$\{$}}\texttt{{\nopagebreak \newline%
}\vphantom{$\{$}}\texttt{mapNew}\texttt{\mbox{\hspace{0.50em}}}\texttt{{:}{:}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\makebox[1.22ex][l]{$ {(} $}}\texttt{v}\texttt{\mbox{\hspace{0.50em}}}\texttt{$ \rightarrow $}\texttt{\mbox{\hspace{0.50em}}}\texttt{v{'}}\texttt{\makebox[1.22ex][r]{$ {)} $}}\texttt{\mbox{\hspace{0.50em}}}\texttt{$ \rightarrow $}\texttt{\mbox{\hspace{0.50em}}}\texttt{\makebox[1.22ex][l]{$ {(} $}}\texttt{a}\texttt{\mbox{\hspace{0.50em}}}\texttt{$ \vartriangleright $}\texttt{\mbox{\hspace{0.50em}}}\texttt{v}\texttt{\makebox[1.22ex][r]{$ {)} $}}\texttt{\mbox{\hspace{0.50em}}}\texttt{$ \rightarrow $}\texttt{\mbox{\hspace{0.50em}}}\texttt{\makebox[1.22ex][l]{$ {(} $}}\texttt{a}\texttt{\mbox{\hspace{0.50em}}}\texttt{$ \vartriangleright $}\texttt{\mbox{\hspace{0.50em}}}\texttt{v{'}}\texttt{\makebox[1.22ex][r]{$ {)} $}}\texttt{{\nopagebreak \newline%
}\vphantom{$\{$}}\texttt{mapNew}\texttt{\mbox{\hspace{0.50em}}}\texttt{\makebox[1.22ex][c]{\_{}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\makebox[1.22ex][l]{$ {(} $}}\texttt{Old}\texttt{\mbox{\hspace{0.50em}}}\texttt{x}\texttt{\makebox[1.22ex][r]{$ {)} $}}\texttt{\mbox{\hspace{0.50em}}}\texttt{{\char `\=}}\texttt{\mbox{\hspace{0.50em}}}\texttt{Old}\texttt{\mbox{\hspace{0.50em}}}\texttt{x}\texttt{{\nopagebreak \newline%
}\vphantom{$\{$}}\texttt{mapNew}\texttt{\mbox{\hspace{0.50em}}}\texttt{f}\texttt{\mbox{\hspace{0.50em}}}\texttt{\makebox[1.22ex][l]{$ {(} $}}\texttt{New}\texttt{\mbox{\hspace{0.50em}}}\texttt{x}\texttt{\makebox[1.22ex][r]{$ {)} $}}\texttt{\mbox{\hspace{0.50em}}}\texttt{{\char `\=}}\texttt{\mbox{\hspace{0.50em}}}\texttt{New}\texttt{\mbox{\hspace{0.50em}}}\texttt{\makebox[1.22ex][l]{$ {(} $}}\texttt{f}\texttt{\mbox{\hspace{0.50em}}}\texttt{x}\texttt{\makebox[1.22ex][r]{$ {)} $}}\texttt{{\nopagebreak \newline%
}\vphantom{$\{$}}%


%
%paragraphName: apNested example
Using the \texttt{Tm} representation, the implementation of the
    application function{~}\texttt{$ \lambda $}\texttt{\mbox{\hspace{0.50em}}}\texttt{f}\texttt{\mbox{\hspace{0.50em}}}\texttt{x}\texttt{\mbox{\hspace{0.50em}}}\texttt{$ \rightarrow $}\texttt{\mbox{\hspace{0.50em}}}\texttt{f}\texttt{\mbox{\hspace{0.50em}}}\texttt{x} is the following{:}%


{\nopagebreak }

%
%code:
%
%comment: apNested :: Tm Zero
%apNested = Lam $ Lam $ Var (Old $ New ())
%                 `App` Var (New ())
%
~\\~\vphantom{$\{$}\texttt{apNested}\texttt{\mbox{\hspace{0.50em}}}\texttt{{:}{:}}\texttt{\mbox{\hspace{0.50em}}}\texttt{Tm}\texttt{\mbox{\hspace{0.50em}}}\texttt{Zero}\texttt{{\nopagebreak \newline%
}\vphantom{$\{$}}\texttt{apNested}\texttt{\mbox{\hspace{0.50em}}}\texttt{{\char `\=}}\texttt{\mbox{\hspace{0.50em}}}\texttt{Lam}\texttt{\mbox{\hspace{0.50em}}}\texttt{\${}}\texttt{\mbox{\hspace{0.50em}}}\texttt{Lam}\texttt{\mbox{\hspace{0.50em}}}\texttt{\${}}\texttt{\mbox{\hspace{0.50em}}}\texttt{Var}\texttt{\mbox{\hspace{0.50em}}}\texttt{\makebox[1.22ex][l]{$ {(} $}}\texttt{Old}\texttt{\mbox{\hspace{0.50em}}}\texttt{\${}}\texttt{\mbox{\hspace{0.50em}}}\texttt{New}\texttt{\mbox{\hspace{0.50em}}}\texttt{\makebox[1.22ex][l]{$ {(} $}}\texttt{\makebox[1.22ex][r]{$ {)} $}}\texttt{\makebox[1.22ex][r]{$ {)} $}}\texttt{{\nopagebreak \newline%
}\vphantom{$\{$}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{{`}App{`}}\texttt{\mbox{\hspace{0.50em}}}\texttt{Var}\texttt{\mbox{\hspace{0.50em}}}\texttt{\makebox[1.22ex][l]{$ {(} $}}\texttt{New}\texttt{\mbox{\hspace{0.50em}}}\texttt{\makebox[1.22ex][l]{$ {(} $}}\texttt{\makebox[1.22ex][r]{$ {)} $}}\texttt{\makebox[1.22ex][r]{$ {)} $}}\texttt{{\nopagebreak \newline%
}\vphantom{$\{$}}%


%
%paragraphName: the type of apNested
As promised, the type is explicit about{~}\texttt{apNested} being a closed
    term{:} this is ensured by using the empty type{~}\texttt{Zero} as an
    argument to{~}\texttt{Tm}.%


{\nopagebreak }

%
%code:
%
%comment: data Zero -- no constructors
%
~\\~\vphantom{$\{$}\texttt{data}\texttt{\mbox{\hspace{0.50em}}}\texttt{Zero}\texttt{\mbox{\hspace{0.50em}}}\texttt{\makebox[1.22ex][c]{-}\makebox[1.22ex][c]{-}\mbox{\hspace{0.50em}}no\mbox{\hspace{0.50em}}constructors}\texttt{{\nopagebreak \newline%
}\vphantom{$\{$}}%


%
%paragraphName: polymorphic terms are closed
In passing, we remark that another type which faithfully captures
    closed terms is{~}\texttt{\makebox[1.22ex][c]{$ \forall $}}\texttt{\mbox{\hspace{0.50em}}}\texttt{a}\texttt{.}\texttt{\mbox{\hspace{0.50em}}}\texttt{Tm}\texttt{\mbox{\hspace{0.50em}}}\texttt{a} --- literally{:} the type of terms
    which are meaningful in any context. Indeed, because{~}\texttt{a} is
    universally quantified, there is no way to construct an inhabitant
    of it; therefore one cannot possibly refer to any free variable. In
    particular one can instantiate{~}\texttt{a} to be the type{~}\texttt{Zero}.%


%
%paragraphName: de Bruijn drawback
However the main drawback of using de{~}Bruijn indices remains{:} one
    must still count the number of binders between the declaration of a
    variable and its occurrences.%


\subsection{Referring to Bound Variables by Name}

%
%paragraphName: flow
To address the issues just touched upon, we propose to build
    $ \lambda $-abstractions with a function called{~}\texttt{lam}. What matters the most
    is its type{:}%


{\nopagebreak }

%
%code:
%
%comment: lam :: (∀ v. v → Tm (a :▹ v)) → Tm a
%lam f = Lam (f ())
%
~\\~\vphantom{$\{$}\texttt{lam}\texttt{\mbox{\hspace{0.50em}}}\texttt{{:}{:}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\makebox[1.22ex][l]{$ {(} $}}\texttt{\makebox[1.22ex][c]{$ \forall $}}\texttt{\mbox{\hspace{0.50em}}}\texttt{v}\texttt{.}\texttt{\mbox{\hspace{0.50em}}}\texttt{v}\texttt{\mbox{\hspace{0.50em}}}\texttt{$ \rightarrow $}\texttt{\mbox{\hspace{0.50em}}}\texttt{Tm}\texttt{\mbox{\hspace{0.50em}}}\texttt{\makebox[1.22ex][l]{$ {(} $}}\texttt{a}\texttt{\mbox{\hspace{0.50em}}}\texttt{$ \vartriangleright $}\texttt{\mbox{\hspace{0.50em}}}\texttt{v}\texttt{\makebox[1.22ex][r]{$ {)} $}}\texttt{\makebox[1.22ex][r]{$ {)} $}}\texttt{\mbox{\hspace{0.50em}}}\texttt{$ \rightarrow $}\texttt{\mbox{\hspace{0.50em}}}\texttt{Tm}\texttt{\mbox{\hspace{0.50em}}}\texttt{a}\texttt{{\nopagebreak \newline%
}\vphantom{$\{$}}\texttt{lam}\texttt{\mbox{\hspace{0.50em}}}\texttt{f}\texttt{\mbox{\hspace{0.50em}}}\texttt{{\char `\=}}\texttt{\mbox{\hspace{0.50em}}}\texttt{Lam}\texttt{\mbox{\hspace{0.50em}}}\texttt{\makebox[1.22ex][l]{$ {(} $}}\texttt{f}\texttt{\mbox{\hspace{0.50em}}}\texttt{\makebox[1.22ex][l]{$ {(} $}}\texttt{\makebox[1.22ex][r]{$ {)} $}}\texttt{\makebox[1.22ex][r]{$ {)} $}}\texttt{{\nopagebreak \newline%
}\vphantom{$\{$}}%


%
%paragraphName: explain ∀ v, v →
That is, instead of adding a concrete unique type{~}(namely \texttt{\makebox[1.22ex][l]{$ {(} $}}\texttt{\makebox[1.22ex][r]{$ {)} $}}) in
    the recursive parameter of{~}\texttt{Tm}, we quantify universally over a
    type variable{~}\texttt{v} and add this type variable to the type of free
    variables. The body of the lambda-abstraction receives an arbitrary
    value of type{~}\texttt{v}, to be used at occurrences of the variable bound
    by{~}\texttt{lam}.%


%
%paragraphName: const
The application function is then built as follows{:}%


{\nopagebreak }

%
%code:
%
%comment: apTm_ :: Tm Zero
%apTm_ = lam $ \ f → lam $ \ x →
%          Var (Old (New f)) `App` Var (New x)
%
~\\~\vphantom{$\{$}\texttt{apTm\makebox[1.22ex][c]{\_{}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{{:}{:}}\texttt{\mbox{\hspace{0.50em}}}\texttt{Tm}\texttt{\mbox{\hspace{0.50em}}}\texttt{Zero}\texttt{{\nopagebreak \newline%
}\vphantom{$\{$}}\texttt{apTm\makebox[1.22ex][c]{\_{}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{{\char `\=}}\texttt{\mbox{\hspace{0.50em}}}\texttt{lam}\texttt{\mbox{\hspace{0.50em}}}\texttt{\${}}\texttt{\mbox{\hspace{0.50em}}}\texttt{$ \lambda $}\texttt{\mbox{\hspace{0.50em}}}\texttt{f}\texttt{\mbox{\hspace{0.50em}}}\texttt{$ \rightarrow $}\texttt{\mbox{\hspace{0.50em}}}\texttt{lam}\texttt{\mbox{\hspace{0.50em}}}\texttt{\${}}\texttt{\mbox{\hspace{0.50em}}}\texttt{$ \lambda $}\texttt{\mbox{\hspace{0.50em}}}\texttt{x}\texttt{\mbox{\hspace{0.50em}}}\texttt{$ \rightarrow $}\texttt{{\nopagebreak \newline%
}\vphantom{$\{$}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{Var}\texttt{\mbox{\hspace{0.50em}}}\texttt{\makebox[1.22ex][l]{$ {(} $}}\texttt{Old}\texttt{\mbox{\hspace{0.50em}}}\texttt{\makebox[1.22ex][l]{$ {(} $}}\texttt{New}\texttt{\mbox{\hspace{0.50em}}}\texttt{f}\texttt{\makebox[1.22ex][r]{$ {)} $}}\texttt{\makebox[1.22ex][r]{$ {)} $}}\texttt{\mbox{\hspace{0.50em}}}\texttt{{`}App{`}}\texttt{\mbox{\hspace{0.50em}}}\texttt{Var}\texttt{\mbox{\hspace{0.50em}}}\texttt{\makebox[1.22ex][l]{$ {(} $}}\texttt{New}\texttt{\mbox{\hspace{0.50em}}}\texttt{x}\texttt{\makebox[1.22ex][r]{$ {)} $}}\texttt{{\nopagebreak \newline%
}\vphantom{$\{$}}%


%
%paragraphName: still the same elephant
By unfolding the definition of{~}\texttt{lam} in{~}\texttt{apTm\makebox[1.22ex][c]{\_{}}} one recovers the
    definition of{~}\texttt{apNested}.%


\paragraph*{Safety}

%
%paragraphName: host bindings are the spec
Using our approach, the binding structure, which can be identified
    as the \emph{specification}, is written using the host language
    binders.
    However at variable occurrences, de{~}Bruijn indices are still present
    in the form of the constructors{~}\texttt{New} and{~}\texttt{Old}, and are purely
    part of the \emph{implementation}.%


%
%paragraphName: type-checking the number of Old...
The type-checker then makes sure that the implementation matches the
    specification{:} for example if one now makes a mistake and forgets
    one{~}\texttt{Old} when entering the term, the \textsc{Haskell} type system
    rejects the definition.%


%
%comment: {- --
%


{\nopagebreak }

%
%code:
%
%comment: oops_ = lam $ \ f → lam $ \ x →
%          Var (New f) `App` Var (New x)
%-- Couldn't match expected type `v1'
%--             with actual type `v'
%
~\\~\vphantom{$\{$}\texttt{oops\makebox[1.22ex][c]{\_{}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{{\char `\=}}\texttt{\mbox{\hspace{0.50em}}}\texttt{lam}\texttt{\mbox{\hspace{0.50em}}}\texttt{\${}}\texttt{\mbox{\hspace{0.50em}}}\texttt{$ \lambda $}\texttt{\mbox{\hspace{0.50em}}}\texttt{f}\texttt{\mbox{\hspace{0.50em}}}\texttt{$ \rightarrow $}\texttt{\mbox{\hspace{0.50em}}}\texttt{lam}\texttt{\mbox{\hspace{0.50em}}}\texttt{\${}}\texttt{\mbox{\hspace{0.50em}}}\texttt{$ \lambda $}\texttt{\mbox{\hspace{0.50em}}}\texttt{x}\texttt{\mbox{\hspace{0.50em}}}\texttt{$ \rightarrow $}\texttt{{\nopagebreak \newline%
}\vphantom{$\{$}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{Var}\texttt{\mbox{\hspace{0.50em}}}\texttt{\makebox[1.22ex][l]{$ {(} $}}\texttt{New}\texttt{\mbox{\hspace{0.50em}}}\texttt{f}\texttt{\makebox[1.22ex][r]{$ {)} $}}\texttt{\mbox{\hspace{0.50em}}}\texttt{{`}App{`}}\texttt{\mbox{\hspace{0.50em}}}\texttt{Var}\texttt{\mbox{\hspace{0.50em}}}\texttt{\makebox[1.22ex][l]{$ {(} $}}\texttt{New}\texttt{\mbox{\hspace{0.50em}}}\texttt{x}\texttt{\makebox[1.22ex][r]{$ {)} $}}\texttt{{\nopagebreak \newline%
}\vphantom{$\{$}}\texttt{\makebox[1.22ex][c]{-}\makebox[1.22ex][c]{-}\mbox{\hspace{0.50em}}Couldn{'}t\mbox{\hspace{0.50em}}match\mbox{\hspace{0.50em}}expected\mbox{\hspace{0.50em}}type\mbox{\hspace{0.50em}}{`}v1{'}}\texttt{{\nopagebreak \newline%
}\vphantom{$\{$}}\texttt{\makebox[1.22ex][c]{-}\makebox[1.22ex][c]{-}\mbox{\hspace{6.50em}}with\mbox{\hspace{0.50em}}actual\mbox{\hspace{0.50em}}type\mbox{\hspace{0.50em}}{`}v{'}}\texttt{{\nopagebreak \newline%
}\vphantom{$\{$}}%


%
%comment: -- -}
%


%
%paragraphName: no mistakes at all
In fact, if all variables are introduced with the{~}\texttt{lam} combinator
    the possibility of making a mistake in the \emph{implementation} is
    nonexistent, if we ignore obviously diverging terms. Indeed, because
    the type{~}\texttt{v} corresponding to a bound variable is universally
    quantified, the only way to construct a value of its type is to
    use the variable bound by{~}\texttt{lam}. (In \textsc{Haskell} one can use a
    diverging program; however one has to make a conscious decision to
    produce a value of such an obviously empty type.)%


%
%paragraphName: unicity of injections
In general, in a closed context, if one considers the
    expression{~}\texttt{Var}\texttt{\mbox{\hspace{0.50em}}}\texttt{\makebox[1.22ex][l]{$ {(} $}}\texttt{\makebox[1.22ex][l]{$ {(} $}}\texttt{Old}\texttt{\makebox[1.22ex][r]{$ {)} $}}\texttt{\makebox[0.61ex][l]{\textsuperscript{n}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\makebox[1.22ex][l]{$ {(} $}}\texttt{New}\texttt{\mbox{\hspace{0.50em}}}\texttt{x}\texttt{\makebox[1.22ex][r]{$ {)} $}}\texttt{\makebox[1.22ex][r]{$ {)} $}}, only one possible value
    of{~}\texttt{n} is admissible. Indeed, anywhere in the formation of a term
    using{~}\texttt{lam}, the type of variables is{~}\texttt{a}\texttt{\mbox{\hspace{0.50em}}}\texttt{{\char `\=}}\texttt{\mbox{\hspace{0.50em}}}\texttt{a\makebox[0.61ex][l]{$ _{{0}} $}}\texttt{\mbox{\hspace{0.50em}}}\texttt{$ \vartriangleright $}\texttt{\mbox{\hspace{0.50em}}}\texttt{v\makebox[0.61ex][l]{$ _{{0}} $}}\texttt{\mbox{\hspace{0.50em}}}\texttt{$ \vartriangleright $}\texttt{\mbox{\hspace{0.50em}}}\texttt{v\makebox[0.61ex][l]{$ _{{1}} $}}\texttt{\mbox{\hspace{0.50em}}}\texttt{$ \vartriangleright $}\texttt{\mbox{\hspace{0.50em}}}\texttt{$ \cdots $}\texttt{\mbox{\hspace{0.50em}}}\texttt{$ \vartriangleright $}\texttt{\mbox{\hspace{0.50em}}}\texttt{v\makebox[0.61ex][l]{$ _{{n}} $}}    where{~}\texttt{v\makebox[0.61ex][l]{$ _{{0}} $}}, \texttt{v\makebox[0.61ex][l]{$ _{{1}} $}}, $ \ldots $ , \texttt{v\makebox[0.61ex][l]{$ _{{n}} $}} are all distinct and universally
    quantified, and none of them occurs as part of{~}\texttt{a\makebox[0.61ex][l]{$ _{{0}} $}}. Hence, there
    is only one injection function from a given{~}\texttt{v\makebox[0.61ex][l]{$ _{{i}} $}} to{~}\texttt{a}.%


\paragraph*{Auto-Inject}

%
%paragraphName: auto-inject
Knowing that the injection functions are uniquely determined by
    their type, one may wish to infer them mechanically. Thanks the
    powerful instance search mechanism implemented in GHC, this is
    feasible. To this effect, we define a class{~}\texttt{v}\texttt{\mbox{\hspace{0.50em}}}\texttt{\makebox[1.22ex][c]{$ \in $}}\texttt{\mbox{\hspace{0.50em}}}\texttt{a} capturing
    that{~}\texttt{v} occurs as part of a context{~}\texttt{a}{:}%


{\nopagebreak }

%
%code:
%
%comment: class v :∈ a where
%  inj :: v → a
%
~\\~\vphantom{$\{$}\texttt{class}\texttt{\mbox{\hspace{0.50em}}}\texttt{v}\texttt{\mbox{\hspace{0.50em}}}\texttt{\makebox[1.22ex][c]{$ \in $}}\texttt{\mbox{\hspace{0.50em}}}\texttt{a}\texttt{\mbox{\hspace{0.50em}}}\texttt{where}\texttt{{\nopagebreak \newline%
}\vphantom{$\{$}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{inj}\texttt{\mbox{\hspace{0.50em}}}\texttt{{:}{:}}\texttt{\mbox{\hspace{0.50em}}}\texttt{v}\texttt{\mbox{\hspace{0.50em}}}\texttt{$ \rightarrow $}\texttt{\mbox{\hspace{0.50em}}}\texttt{a}\texttt{{\nopagebreak \newline%
}\vphantom{$\{$}}%


%
%paragraphName: var
We can then wrap the injection function and{~}\texttt{Var} in a convenient
    package{:}%


%
%comment: {- --
%


{\nopagebreak }

%
%code:
%
%comment: var :: ∀ v a. (v :∈ a) ⇒ v → Tm a
%var = Var . inj
%
~\\~\vphantom{$\{$}\texttt{var}\texttt{\mbox{\hspace{0.50em}}}\texttt{{:}{:}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\makebox[1.22ex][c]{$ \forall $}}\texttt{\mbox{\hspace{0.50em}}}\texttt{v}\texttt{\mbox{\hspace{0.50em}}}\texttt{a}\texttt{.}\texttt{\mbox{\hspace{0.50em}}}\texttt{\makebox[1.22ex][l]{$ {(} $}}\texttt{v}\texttt{\mbox{\hspace{0.50em}}}\texttt{\makebox[1.22ex][c]{$ \in $}}\texttt{\mbox{\hspace{0.50em}}}\texttt{a}\texttt{\makebox[1.22ex][r]{$ {)} $}}\texttt{\mbox{\hspace{0.50em}}}\texttt{$ \Rightarrow $}\texttt{\mbox{\hspace{0.50em}}}\texttt{v}\texttt{\mbox{\hspace{0.50em}}}\texttt{$ \rightarrow $}\texttt{\mbox{\hspace{0.50em}}}\texttt{Tm}\texttt{\mbox{\hspace{0.50em}}}\texttt{a}\texttt{{\nopagebreak \newline%
}\vphantom{$\{$}}\texttt{var}\texttt{\mbox{\hspace{0.50em}}}\texttt{{\char `\=}}\texttt{\mbox{\hspace{0.50em}}}\texttt{Var}\texttt{\mbox{\hspace{0.50em}}}\texttt{.}\texttt{\mbox{\hspace{0.50em}}}\texttt{inj}\texttt{{\nopagebreak \newline%
}\vphantom{$\{$}}%


%
%comment: -- -}
%


%
%paragraphName: apTm
and the application function can be conveniently written{:}%


{\nopagebreak }

%
%code:
%
%comment: -- Building the following term: \ f x → f x
%apTm = lam $ \ f → lam $ \ x → var f `App` var x
%
~\\~\vphantom{$\{$}\texttt{\makebox[1.22ex][c]{-}\makebox[1.22ex][c]{-}\mbox{\hspace{0.50em}}Building\mbox{\hspace{0.50em}}the\mbox{\hspace{0.50em}}following\mbox{\hspace{0.50em}}term{:}\mbox{\hspace{0.50em}}$ \lambda $\mbox{\hspace{0.50em}}f\mbox{\hspace{0.50em}}x\mbox{\hspace{0.50em}}$ \rightarrow $\mbox{\hspace{0.50em}}f\mbox{\hspace{0.50em}}x}\texttt{{\nopagebreak \newline%
}\vphantom{$\{$}}\texttt{apTm}\texttt{\mbox{\hspace{0.50em}}}\texttt{{\char `\=}}\texttt{\mbox{\hspace{0.50em}}}\texttt{lam}\texttt{\mbox{\hspace{0.50em}}}\texttt{\${}}\texttt{\mbox{\hspace{0.50em}}}\texttt{$ \lambda $}\texttt{\mbox{\hspace{0.50em}}}\texttt{f}\texttt{\mbox{\hspace{0.50em}}}\texttt{$ \rightarrow $}\texttt{\mbox{\hspace{0.50em}}}\texttt{lam}\texttt{\mbox{\hspace{0.50em}}}\texttt{\${}}\texttt{\mbox{\hspace{0.50em}}}\texttt{$ \lambda $}\texttt{\mbox{\hspace{0.50em}}}\texttt{x}\texttt{\mbox{\hspace{0.50em}}}\texttt{$ \rightarrow $}\texttt{\mbox{\hspace{0.50em}}}\texttt{var}\texttt{\mbox{\hspace{0.50em}}}\texttt{f}\texttt{\mbox{\hspace{0.50em}}}\texttt{{`}App{`}}\texttt{\mbox{\hspace{0.50em}}}\texttt{var}\texttt{\mbox{\hspace{0.50em}}}\texttt{x}\texttt{{\nopagebreak \newline%
}\vphantom{$\{$}}%


%
%paragraphName: more intuitions
In a nutshell, our de{~}Bruijn indices are typed with the context
    where they are valid. If that context is sufficiently polymorphic,
    they can not be mistakenly used in a wrong context. Another
    intuition is that \texttt{New} and{~}\texttt{Old} are building proofs of
    {``}context membership{''}. Thus, when a de{~}Bruijn index is given a
    maximally polymorphic context, it is similar to a well-scoped name.%


%
%paragraphName: flow to next section
So far, we have seen that by taking advantage of polymorphism,
    our interface allows to construct terms with de{~}Bruijn indices,
    combined with the safety and convenience of named variables. In the
    next section we show how to use the same idea to provide the same
    advantages for the analysis and manipulation of terms.%


\subsection{Referring to Free Variables by Name}

%
%paragraphName: unpack
Often, one wants to be able to check if an occurrence of a
    variable is a reference to some previously bound variable. With
    de{~}Bruijn indices, one must (yet again) count the number of
    binders traversed between the variable bindings and its potential
    occurrences --- an error prone task. Here as well, we can take
    advantage of polymorphism to ensure that no mistake happens. We
    provide a combinator{~}\texttt{unpack}, which hides the type of the newly
    bound variables (the type{~}\texttt{\makebox[1.22ex][l]{$ {(} $}}\texttt{\makebox[1.22ex][r]{$ {)} $}}) as an existentially quantified
    type{~}\texttt{v}. The combinator{~}\texttt{unpack} takes a binding structure
    (of type{~}\texttt{Tm}\texttt{\mbox{\hspace{0.50em}}}\texttt{\makebox[1.22ex][l]{$ {(} $}}\texttt{Succ}\texttt{\mbox{\hspace{0.50em}}}\texttt{a}\texttt{\makebox[1.22ex][r]{$ {)} $}}) and gives a pair of a value{~}\texttt{x} of
    type{~}\texttt{v} and a sub-term of type{~}\texttt{Tm}\texttt{\mbox{\hspace{0.50em}}}\texttt{\makebox[1.22ex][l]{$ {(} $}}\texttt{a}\texttt{\mbox{\hspace{0.50em}}}\texttt{$ \vartriangleright $}\texttt{\mbox{\hspace{0.50em}}}\texttt{v}\texttt{\makebox[1.22ex][r]{$ {)} $}}. Here we represent
    the existential using continuation-passing style instead of a
    data-type, as it appears more convenient to use this way. Because
    this combinator is not specific to our type{~}\texttt{Tm} we generalize it
    to any type constructor{~}\texttt{f}{:}%


{\nopagebreak }

%
%code:
%
%comment: unpack :: f (Succ a) →
%          (∀ v. v → f (a :▹ v) → r) → r
%unpack e k = k () e
%
~\\~\vphantom{$\{$}\texttt{unpack}\texttt{\mbox{\hspace{0.50em}}}\texttt{{:}{:}}\texttt{\mbox{\hspace{0.50em}}}\texttt{f}\texttt{\mbox{\hspace{0.50em}}}\texttt{\makebox[1.22ex][l]{$ {(} $}}\texttt{Succ}\texttt{\mbox{\hspace{0.50em}}}\texttt{a}\texttt{\makebox[1.22ex][r]{$ {)} $}}\texttt{\mbox{\hspace{0.50em}}}\texttt{$ \rightarrow $}\texttt{\mbox{\hspace{0.50em}}}\texttt{{\nopagebreak \newline%
}\vphantom{$\{$}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\makebox[1.22ex][l]{$ {(} $}}\texttt{\makebox[1.22ex][c]{$ \forall $}}\texttt{\mbox{\hspace{0.50em}}}\texttt{v}\texttt{.}\texttt{\mbox{\hspace{0.50em}}}\texttt{v}\texttt{\mbox{\hspace{0.50em}}}\texttt{$ \rightarrow $}\texttt{\mbox{\hspace{0.50em}}}\texttt{f}\texttt{\mbox{\hspace{0.50em}}}\texttt{\makebox[1.22ex][l]{$ {(} $}}\texttt{a}\texttt{\mbox{\hspace{0.50em}}}\texttt{$ \vartriangleright $}\texttt{\mbox{\hspace{0.50em}}}\texttt{v}\texttt{\makebox[1.22ex][r]{$ {)} $}}\texttt{\mbox{\hspace{0.50em}}}\texttt{$ \rightarrow $}\texttt{\mbox{\hspace{0.50em}}}\texttt{r}\texttt{\makebox[1.22ex][r]{$ {)} $}}\texttt{\mbox{\hspace{0.50em}}}\texttt{$ \rightarrow $}\texttt{\mbox{\hspace{0.50em}}}\texttt{r}\texttt{{\nopagebreak \newline%
}\vphantom{$\{$}}\texttt{unpack}\texttt{\mbox{\hspace{0.50em}}}\texttt{e}\texttt{\mbox{\hspace{0.50em}}}\texttt{k}\texttt{\mbox{\hspace{0.50em}}}\texttt{{\char `\=}}\texttt{\mbox{\hspace{0.50em}}}\texttt{k}\texttt{\mbox{\hspace{0.50em}}}\texttt{\makebox[1.22ex][l]{$ {(} $}}\texttt{\makebox[1.22ex][r]{$ {)} $}}\texttt{\mbox{\hspace{0.50em}}}\texttt{e}\texttt{{\nopagebreak \newline%
}\vphantom{$\{$}}%


%
%paragraphName: why unpack works
Because{~}\texttt{v} is existentially bound, \texttt{x} can never be used in a
    computation. It only acts as a reference to a variable in a context,
    in a way which is only accessible to the type-checker.
    For instance, when facing a term{~}\texttt{t} of type
    \texttt{Tm}\texttt{\mbox{\hspace{0.50em}}}\texttt{\makebox[1.22ex][l]{$ {(} $}}\texttt{a}\texttt{\mbox{\hspace{0.50em}}}\texttt{$ \vartriangleright $}\texttt{\mbox{\hspace{0.50em}}}\texttt{v\makebox[0.61ex][l]{$ _{{0}} $}}\texttt{\mbox{\hspace{0.50em}}}\texttt{$ \vartriangleright $}\texttt{\mbox{\hspace{0.50em}}}\texttt{v\makebox[0.61ex][l]{$ _{{1}} $}}\texttt{\mbox{\hspace{0.50em}}}\texttt{$ \vartriangleright $}\texttt{\mbox{\hspace{0.50em}}}\texttt{v}\texttt{\makebox[1.22ex][r]{$ {)} $}}, \texttt{x} refers to the last introduced free
    variable in{~}\texttt{t}.
    Using{~}\texttt{unpack}, one can write a function which can recognize an
    eta-contractible term as follows{:} (Recall that an eta-contractible
    term has the form{~}\texttt{$ \lambda $}\texttt{\mbox{\hspace{0.50em}}}\texttt{x}\texttt{\mbox{\hspace{0.50em}}}\texttt{$ \rightarrow $}\texttt{\mbox{\hspace{0.50em}}}\texttt{e}\texttt{\mbox{\hspace{0.50em}}}\texttt{x}, where{~}\texttt{x} does not occur free
    in{~}\texttt{e}.)%


{\nopagebreak }

%
%code:
%
%comment: canEta :: Tm Zero → Bool
%canEta (Lam e) = unpack e $ \ x t → case t of
%  App e1 (Var y) → y `isOccurenceOf` x &&
%                    x `freshFor` e1
%  _ → False
%canEta _ = False
%
~\\~\vphantom{$\{$}\texttt{canEta}\texttt{\mbox{\hspace{0.50em}}}\texttt{{:}{:}}\texttt{\mbox{\hspace{0.50em}}}\texttt{Tm}\texttt{\mbox{\hspace{0.50em}}}\texttt{Zero}\texttt{\mbox{\hspace{0.50em}}}\texttt{$ \rightarrow $}\texttt{\mbox{\hspace{0.50em}}}\texttt{Bool}\texttt{{\nopagebreak \newline%
}\vphantom{$\{$}}\texttt{canEta}\texttt{\mbox{\hspace{0.50em}}}\texttt{\makebox[1.22ex][l]{$ {(} $}}\texttt{Lam}\texttt{\mbox{\hspace{0.50em}}}\texttt{e}\texttt{\makebox[1.22ex][r]{$ {)} $}}\texttt{\mbox{\hspace{0.50em}}}\texttt{{\char `\=}}\texttt{\mbox{\hspace{0.50em}}}\texttt{unpack}\texttt{\mbox{\hspace{0.50em}}}\texttt{e}\texttt{\mbox{\hspace{0.50em}}}\texttt{\${}}\texttt{\mbox{\hspace{0.50em}}}\texttt{$ \lambda $}\texttt{\mbox{\hspace{0.50em}}}\texttt{x}\texttt{\mbox{\hspace{0.50em}}}\texttt{t}\texttt{\mbox{\hspace{0.50em}}}\texttt{$ \rightarrow $}\texttt{\mbox{\hspace{0.50em}}}\texttt{case}\texttt{\mbox{\hspace{0.50em}}}\texttt{t}\texttt{\mbox{\hspace{0.50em}}}\texttt{of}\texttt{{\nopagebreak \newline%
}\vphantom{$\{$}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{App}\texttt{\mbox{\hspace{0.50em}}}\texttt{e1}\texttt{\mbox{\hspace{0.50em}}}\texttt{\makebox[1.22ex][l]{$ {(} $}}\texttt{Var}\texttt{\mbox{\hspace{0.50em}}}\texttt{y}\texttt{\makebox[1.22ex][r]{$ {)} $}}\texttt{\mbox{\hspace{0.50em}}}\texttt{$ \rightarrow $}\texttt{\mbox{\hspace{0.50em}}}\texttt{y}\texttt{\mbox{\hspace{0.50em}}}\texttt{{`}isOccurenceOf{`}}\texttt{\mbox{\hspace{0.50em}}}\texttt{x}\texttt{\mbox{\hspace{0.50em}}}\texttt{\&{}\&{}}\texttt{{\nopagebreak \newline%
}\vphantom{$\{$}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{x}\texttt{\mbox{\hspace{0.50em}}}\texttt{{`}freshFor{`}}\texttt{\mbox{\hspace{0.50em}}}\texttt{e1}\texttt{{\nopagebreak \newline%
}\vphantom{$\{$}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\makebox[1.22ex][c]{\_{}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{$ \rightarrow $}\texttt{\mbox{\hspace{0.50em}}}\texttt{False}\texttt{{\nopagebreak \newline%
}\vphantom{$\{$}}\texttt{canEta}\texttt{\mbox{\hspace{0.50em}}}\texttt{\makebox[1.22ex][c]{\_{}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{{\char `\=}}\texttt{\mbox{\hspace{0.50em}}}\texttt{False}\texttt{{\nopagebreak \newline%
}\vphantom{$\{$}}%


%
%paragraphName: canEta
In the above example, the two functions{~}\texttt{isOccurenceOf}    and{~}\texttt{freshFor} use the{~}\texttt{inj} function to lift{~}\texttt{x} to
    a reference in the right context before comparing it to the
    occurrences. The calls to these functions do not get more
    complicated in the presence of multiple binders. For example, the
    code which recognizes the pattern{~}\texttt{$ \lambda $}\texttt{\mbox{\hspace{0.50em}}}\texttt{x}\texttt{\mbox{\hspace{0.50em}}}\texttt{y}\texttt{\mbox{\hspace{0.50em}}}\texttt{$ \rightarrow $}\texttt{\mbox{\hspace{0.50em}}}\texttt{e}\texttt{\mbox{\hspace{0.50em}}}\texttt{x} is as follows{:}%


{\nopagebreak }

%
%code:
%
%comment: recognizeExample :: Tm Zero → Bool
%recognizeExample t0 = case t0 of
%    Lam f → unpack f $ \ x t1 → case t1 of
%      Lam g → unpack g $ \ y t2 → case t2 of
%        App e1 (Var z) → z `isOccurenceOf` x &&
%                          x `freshFor` e1 &&
%                          y `freshFor` e1
%        _ → False
%      _ → False
%    _ → False
%
~\\~\vphantom{$\{$}\texttt{recognizeExample}\texttt{\mbox{\hspace{0.50em}}}\texttt{{:}{:}}\texttt{\mbox{\hspace{0.50em}}}\texttt{Tm}\texttt{\mbox{\hspace{0.50em}}}\texttt{Zero}\texttt{\mbox{\hspace{0.50em}}}\texttt{$ \rightarrow $}\texttt{\mbox{\hspace{0.50em}}}\texttt{Bool}\texttt{{\nopagebreak \newline%
}\vphantom{$\{$}}\texttt{recognizeExample}\texttt{\mbox{\hspace{0.50em}}}\texttt{t0}\texttt{\mbox{\hspace{0.50em}}}\texttt{{\char `\=}}\texttt{\mbox{\hspace{0.50em}}}\texttt{case}\texttt{\mbox{\hspace{0.50em}}}\texttt{t0}\texttt{\mbox{\hspace{0.50em}}}\texttt{of}\texttt{{\nopagebreak \newline%
}\vphantom{$\{$}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{Lam}\texttt{\mbox{\hspace{0.50em}}}\texttt{f}\texttt{\mbox{\hspace{0.50em}}}\texttt{$ \rightarrow $}\texttt{\mbox{\hspace{0.50em}}}\texttt{unpack}\texttt{\mbox{\hspace{0.50em}}}\texttt{f}\texttt{\mbox{\hspace{0.50em}}}\texttt{\${}}\texttt{\mbox{\hspace{0.50em}}}\texttt{$ \lambda $}\texttt{\mbox{\hspace{0.50em}}}\texttt{x}\texttt{\mbox{\hspace{0.50em}}}\texttt{t1}\texttt{\mbox{\hspace{0.50em}}}\texttt{$ \rightarrow $}\texttt{\mbox{\hspace{0.50em}}}\texttt{case}\texttt{\mbox{\hspace{0.50em}}}\texttt{t1}\texttt{\mbox{\hspace{0.50em}}}\texttt{of}\texttt{{\nopagebreak \newline%
}\vphantom{$\{$}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{Lam}\texttt{\mbox{\hspace{0.50em}}}\texttt{g}\texttt{\mbox{\hspace{0.50em}}}\texttt{$ \rightarrow $}\texttt{\mbox{\hspace{0.50em}}}\texttt{unpack}\texttt{\mbox{\hspace{0.50em}}}\texttt{g}\texttt{\mbox{\hspace{0.50em}}}\texttt{\${}}\texttt{\mbox{\hspace{0.50em}}}\texttt{$ \lambda $}\texttt{\mbox{\hspace{0.50em}}}\texttt{y}\texttt{\mbox{\hspace{0.50em}}}\texttt{t2}\texttt{\mbox{\hspace{0.50em}}}\texttt{$ \rightarrow $}\texttt{\mbox{\hspace{0.50em}}}\texttt{case}\texttt{\mbox{\hspace{0.50em}}}\texttt{t2}\texttt{\mbox{\hspace{0.50em}}}\texttt{of}\texttt{{\nopagebreak \newline%
}\vphantom{$\{$}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{App}\texttt{\mbox{\hspace{0.50em}}}\texttt{e1}\texttt{\mbox{\hspace{0.50em}}}\texttt{\makebox[1.22ex][l]{$ {(} $}}\texttt{Var}\texttt{\mbox{\hspace{0.50em}}}\texttt{z}\texttt{\makebox[1.22ex][r]{$ {)} $}}\texttt{\mbox{\hspace{0.50em}}}\texttt{$ \rightarrow $}\texttt{\mbox{\hspace{0.50em}}}\texttt{z}\texttt{\mbox{\hspace{0.50em}}}\texttt{{`}isOccurenceOf{`}}\texttt{\mbox{\hspace{0.50em}}}\texttt{x}\texttt{\mbox{\hspace{0.50em}}}\texttt{\&{}\&{}}\texttt{{\nopagebreak \newline%
}\vphantom{$\{$}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{x}\texttt{\mbox{\hspace{0.50em}}}\texttt{{`}freshFor{`}}\texttt{\mbox{\hspace{0.50em}}}\texttt{e1}\texttt{\mbox{\hspace{0.50em}}}\texttt{\&{}\&{}}\texttt{{\nopagebreak \newline%
}\vphantom{$\{$}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{y}\texttt{\mbox{\hspace{0.50em}}}\texttt{{`}freshFor{`}}\texttt{\mbox{\hspace{0.50em}}}\texttt{e1}\texttt{{\nopagebreak \newline%
}\vphantom{$\{$}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\makebox[1.22ex][c]{\_{}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{$ \rightarrow $}\texttt{\mbox{\hspace{0.50em}}}\texttt{False}\texttt{{\nopagebreak \newline%
}\vphantom{$\{$}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\makebox[1.22ex][c]{\_{}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{$ \rightarrow $}\texttt{\mbox{\hspace{0.50em}}}\texttt{False}\texttt{{\nopagebreak \newline%
}\vphantom{$\{$}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\makebox[1.22ex][c]{\_{}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{$ \rightarrow $}\texttt{\mbox{\hspace{0.50em}}}\texttt{False}\texttt{{\nopagebreak \newline%
}\vphantom{$\{$}}%


%
%paragraphName: slogan
Again, even though variables are represented by mere indices, the
    use of polymorphism allows the user to refer to them by name,
    using the instance search mechanism to fill in the details of
    implementation.%


\paragraph*{Pack}

%
%paragraphName: pack
It is easy to invert the job of{~}\texttt{unpack}. Indeed, given a
    value{~}\texttt{x} of type{~}\texttt{v} and a term of type{~}\texttt{Tm}\texttt{\mbox{\hspace{0.50em}}}\texttt{\makebox[1.22ex][l]{$ {(} $}}\texttt{a}\texttt{\mbox{\hspace{0.50em}}}\texttt{$ \vartriangleright $}\texttt{\mbox{\hspace{0.50em}}}\texttt{v}\texttt{\makebox[1.22ex][r]{$ {)} $}} one can
    reconstruct a binder as follows{:} %


{\nopagebreak }

%
%code:
%
%comment: pack :: Functor tm ⇒ v → tm (a :▹ v) → tm (Succ a)
%pack x = fmap (mapNew (const ()))
%
~\\~\vphantom{$\{$}\texttt{pack}\texttt{\mbox{\hspace{0.50em}}}\texttt{{:}{:}}\texttt{\mbox{\hspace{0.50em}}}\texttt{Functor}\texttt{\mbox{\hspace{0.50em}}}\texttt{tm}\texttt{\mbox{\hspace{0.50em}}}\texttt{$ \Rightarrow $}\texttt{\mbox{\hspace{0.50em}}}\texttt{v}\texttt{\mbox{\hspace{0.50em}}}\texttt{$ \rightarrow $}\texttt{\mbox{\hspace{0.50em}}}\texttt{tm}\texttt{\mbox{\hspace{0.50em}}}\texttt{\makebox[1.22ex][l]{$ {(} $}}\texttt{a}\texttt{\mbox{\hspace{0.50em}}}\texttt{$ \vartriangleright $}\texttt{\mbox{\hspace{0.50em}}}\texttt{v}\texttt{\makebox[1.22ex][r]{$ {)} $}}\texttt{\mbox{\hspace{0.50em}}}\texttt{$ \rightarrow $}\texttt{\mbox{\hspace{0.50em}}}\texttt{tm}\texttt{\mbox{\hspace{0.50em}}}\texttt{\makebox[1.22ex][l]{$ {(} $}}\texttt{Succ}\texttt{\mbox{\hspace{0.50em}}}\texttt{a}\texttt{\makebox[1.22ex][r]{$ {)} $}}\texttt{{\nopagebreak \newline%
}\vphantom{$\{$}}\texttt{pack}\texttt{\mbox{\hspace{0.50em}}}\texttt{x}\texttt{\mbox{\hspace{0.50em}}}\texttt{{\char `\=}}\texttt{\mbox{\hspace{0.50em}}}\texttt{fmap}\texttt{\mbox{\hspace{0.50em}}}\texttt{\makebox[1.22ex][l]{$ {(} $}}\texttt{mapNew}\texttt{\mbox{\hspace{0.50em}}}\texttt{\makebox[1.22ex][l]{$ {(} $}}\texttt{const}\texttt{\mbox{\hspace{0.50em}}}\texttt{\makebox[1.22ex][l]{$ {(} $}}\texttt{\makebox[1.22ex][r]{$ {)} $}}\texttt{\makebox[1.22ex][r]{$ {)} $}}\texttt{\makebox[1.22ex][r]{$ {)} $}}\texttt{{\nopagebreak \newline%
}\vphantom{$\{$}}%


%
%paragraphName:
(The{~}\texttt{Functor} constraint is harmless, as we will see in sec.
    \ref{termStructure}.) As we can see, the value{~}\texttt{x} is not used
    by pack. However it statically helps as a specification of the
    user intention{:} it makes sure the programmer relies on host-level
    variable names, and not indices.%


%
%paragraphName:
A production-quality version of \texttt{pack} would allow to bind any
    free variable. Writing the constraint{~}\texttt{Insert}\texttt{\mbox{\hspace{0.50em}}}\texttt{v}\texttt{\mbox{\hspace{0.50em}}}\texttt{a}\texttt{\mbox{\hspace{0.50em}}}\texttt{b} to mean
    that by removing the variable{~}\texttt{v} from the context{~}\texttt{b} one
    obtains{~}\texttt{a}, then a generic{~}\texttt{pack} would have the following
    type{:}%


{\nopagebreak }

%
%code:
%
%comment: packGen :: ∀ f v a b w. (Functor f, Insert v a b) ⇒
%           v → f b → (w → f (a :▹ w))
%
~\\~\vphantom{$\{$}\texttt{packGen}\texttt{\mbox{\hspace{0.50em}}}\texttt{{:}{:}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\makebox[1.22ex][c]{$ \forall $}}\texttt{\mbox{\hspace{0.50em}}}\texttt{f}\texttt{\mbox{\hspace{0.50em}}}\texttt{v}\texttt{\mbox{\hspace{0.50em}}}\texttt{a}\texttt{\mbox{\hspace{0.50em}}}\texttt{b}\texttt{\mbox{\hspace{0.50em}}}\texttt{w}\texttt{.}\texttt{\mbox{\hspace{0.50em}}}\texttt{\makebox[1.22ex][l]{$ {(} $}}\texttt{Functor}\texttt{\mbox{\hspace{0.50em}}}\texttt{f,}\texttt{\mbox{\hspace{0.50em}}}\texttt{Insert}\texttt{\mbox{\hspace{0.50em}}}\texttt{v}\texttt{\mbox{\hspace{0.50em}}}\texttt{a}\texttt{\mbox{\hspace{0.50em}}}\texttt{b}\texttt{\makebox[1.22ex][r]{$ {)} $}}\texttt{\mbox{\hspace{0.50em}}}\texttt{$ \Rightarrow $}\texttt{{\nopagebreak \newline%
}\vphantom{$\{$}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{v}\texttt{\mbox{\hspace{0.50em}}}\texttt{$ \rightarrow $}\texttt{\mbox{\hspace{0.50em}}}\texttt{f}\texttt{\mbox{\hspace{0.50em}}}\texttt{b}\texttt{\mbox{\hspace{0.50em}}}\texttt{$ \rightarrow $}\texttt{\mbox{\hspace{0.50em}}}\texttt{\makebox[1.22ex][l]{$ {(} $}}\texttt{w}\texttt{\mbox{\hspace{0.50em}}}\texttt{$ \rightarrow $}\texttt{\mbox{\hspace{0.50em}}}\texttt{f}\texttt{\mbox{\hspace{0.50em}}}\texttt{\makebox[1.22ex][l]{$ {(} $}}\texttt{a}\texttt{\mbox{\hspace{0.50em}}}\texttt{$ \vartriangleright $}\texttt{\mbox{\hspace{0.50em}}}\texttt{w}\texttt{\makebox[1.22ex][r]{$ {)} $}}\texttt{\makebox[1.22ex][r]{$ {)} $}}\texttt{{\nopagebreak \newline%
}\vphantom{$\{$}}%


%
%paragraphName:
The implementation of{~}\texttt{packGen} and{~}\texttt{Insert} is a
    straightforward extension of{~}\texttt{inj} and{~}\texttt{\makebox[1.22ex][l]{$ {(} $}}\texttt{\makebox[1.22ex][c]{$ \in $}}\texttt{\makebox[1.22ex][r]{$ {)} $}}, but
    it does not fit here, so we defer it to the development
    online{~}\cite{namesforfreerepo}.%


%
%paragraphName: lamP
In sum, the{~}\texttt{pack} combinator makes it possible to give a
    nominal-style interface to binders. For example an alternative way
    to build the{~}\texttt{Lam} constructor is the following{:}%


{\nopagebreak }

%
%code:
%
%comment: lamP :: v → Tm (a :▹ v) → Tm a
%lamP x t = Lam (pack x t)
%
~\\~\vphantom{$\{$}\texttt{lamP}\texttt{\mbox{\hspace{0.50em}}}\texttt{{:}{:}}\texttt{\mbox{\hspace{0.50em}}}\texttt{v}\texttt{\mbox{\hspace{0.50em}}}\texttt{$ \rightarrow $}\texttt{\mbox{\hspace{0.50em}}}\texttt{Tm}\texttt{\mbox{\hspace{0.50em}}}\texttt{\makebox[1.22ex][l]{$ {(} $}}\texttt{a}\texttt{\mbox{\hspace{0.50em}}}\texttt{$ \vartriangleright $}\texttt{\mbox{\hspace{0.50em}}}\texttt{v}\texttt{\makebox[1.22ex][r]{$ {)} $}}\texttt{\mbox{\hspace{0.50em}}}\texttt{$ \rightarrow $}\texttt{\mbox{\hspace{0.50em}}}\texttt{Tm}\texttt{\mbox{\hspace{0.50em}}}\texttt{a}\texttt{{\nopagebreak \newline%
}\vphantom{$\{$}}\texttt{lamP}\texttt{\mbox{\hspace{0.50em}}}\texttt{x}\texttt{\mbox{\hspace{0.50em}}}\texttt{t}\texttt{\mbox{\hspace{0.50em}}}\texttt{{\char `\=}}\texttt{\mbox{\hspace{0.50em}}}\texttt{Lam}\texttt{\mbox{\hspace{0.50em}}}\texttt{\makebox[1.22ex][l]{$ {(} $}}\texttt{pack}\texttt{\mbox{\hspace{0.50em}}}\texttt{x}\texttt{\mbox{\hspace{0.50em}}}\texttt{t}\texttt{\makebox[1.22ex][r]{$ {)} $}}\texttt{{\nopagebreak \newline%
}\vphantom{$\{$}}%


\section{Contexts\label{contextSec}}

%
%paragraphName: flow
Having introduced our interface informally, we now begin a
           systematic description of is realization and the concepts it builds upon.%


%
%paragraphName: flow, ▹
We have seen that the type of free variables essentially describes
    the context where they are meaningful. A context can either be
    empty (and we represent it by the type{~}\texttt{Zero}) or not (which we
    can represent by the type{~}\texttt{a}\texttt{\mbox{\hspace{0.50em}}}\texttt{$ \vartriangleright $}\texttt{\mbox{\hspace{0.50em}}}\texttt{v}).%


%
%paragraphName: explain remove
An important function of the{~}\texttt{v} type variable is to make sure
    programmers refer to the variable they intend to. For example,
    consider the following function, which takes a list of (free)
    variables and removes one of them from the list. It takes a list
    of variables in the context{~}\texttt{a}\texttt{\mbox{\hspace{0.50em}}}\texttt{$ \vartriangleright $}\texttt{\mbox{\hspace{0.50em}}}\texttt{v} and returns a list in the
    context{~}\texttt{a}. For extra safety, it also takes the name of the
    variable being removed, which is used only for type-checking
    purposes.%


{\nopagebreak }

%
%code:
%
%comment: remove :: v → [a :▹ v] → [a]
%remove _ xs = [x | Old x ← xs]
%
~\\~\vphantom{$\{$}\texttt{remove}\texttt{\mbox{\hspace{0.50em}}}\texttt{{:}{:}}\texttt{\mbox{\hspace{0.50em}}}\texttt{v}\texttt{\mbox{\hspace{0.50em}}}\texttt{$ \rightarrow $}\texttt{\mbox{\hspace{0.50em}}}\texttt{{[}}\texttt{a}\texttt{\mbox{\hspace{0.50em}}}\texttt{$ \vartriangleright $}\texttt{\mbox{\hspace{0.50em}}}\texttt{v}\texttt{{]}}\texttt{\mbox{\hspace{0.50em}}}\texttt{$ \rightarrow $}\texttt{\mbox{\hspace{0.50em}}}\texttt{{[}}\texttt{a}\texttt{{]}}\texttt{{\nopagebreak \newline%
}\vphantom{$\{$}}\texttt{remove}\texttt{\mbox{\hspace{0.50em}}}\texttt{\makebox[1.22ex][c]{\_{}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{xs}\texttt{\mbox{\hspace{0.50em}}}\texttt{{\char `\=}}\texttt{\mbox{\hspace{0.50em}}}\texttt{{[}}\texttt{x}\texttt{\mbox{\hspace{0.50em}}}\texttt{\makebox[1.22ex][c]{\textbar{}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{Old}\texttt{\mbox{\hspace{0.50em}}}\texttt{x}\texttt{\mbox{\hspace{0.50em}}}\texttt{$ \leftarrow $}\texttt{\mbox{\hspace{0.50em}}}\texttt{xs}\texttt{{]}}\texttt{{\nopagebreak \newline%
}\vphantom{$\{$}}%


%
%paragraphName: explain freeVars_
The function which computes the list of occurrences of free variables in a term can
    be directly transcribed from its nominal-style definition, thanks
    to the{~}\texttt{unpack} combinator.%


{\nopagebreak }

%
%code:
%
%comment: freeVars_ :: Tm a → [a]
%freeVars_ (Var x) = [x]
%freeVars_ (Lam b) = unpack b $ \ x t →
%   remove x (freeVars_ t)
%freeVars_ (App f a) = freeVars_ f ++ freeVars_ a
%
~\\~\vphantom{$\{$}\texttt{freeVars\makebox[1.22ex][c]{\_{}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{{:}{:}}\texttt{\mbox{\hspace{0.50em}}}\texttt{Tm}\texttt{\mbox{\hspace{0.50em}}}\texttt{a}\texttt{\mbox{\hspace{0.50em}}}\texttt{$ \rightarrow $}\texttt{\mbox{\hspace{0.50em}}}\texttt{{[}}\texttt{a}\texttt{{]}}\texttt{{\nopagebreak \newline%
}\vphantom{$\{$}}\texttt{freeVars\makebox[1.22ex][c]{\_{}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\makebox[1.22ex][l]{$ {(} $}}\texttt{Var}\texttt{\mbox{\hspace{0.50em}}}\texttt{x}\texttt{\makebox[1.22ex][r]{$ {)} $}}\texttt{\mbox{\hspace{0.50em}}}\texttt{{\char `\=}}\texttt{\mbox{\hspace{0.50em}}}\texttt{{[}}\texttt{x}\texttt{{]}}\texttt{{\nopagebreak \newline%
}\vphantom{$\{$}}\texttt{freeVars\makebox[1.22ex][c]{\_{}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\makebox[1.22ex][l]{$ {(} $}}\texttt{Lam}\texttt{\mbox{\hspace{0.50em}}}\texttt{b}\texttt{\makebox[1.22ex][r]{$ {)} $}}\texttt{\mbox{\hspace{0.50em}}}\texttt{{\char `\=}}\texttt{\mbox{\hspace{0.50em}}}\texttt{unpack}\texttt{\mbox{\hspace{0.50em}}}\texttt{b}\texttt{\mbox{\hspace{0.50em}}}\texttt{\${}}\texttt{\mbox{\hspace{0.50em}}}\texttt{$ \lambda $}\texttt{\mbox{\hspace{0.50em}}}\texttt{x}\texttt{\mbox{\hspace{0.50em}}}\texttt{t}\texttt{\mbox{\hspace{0.50em}}}\texttt{$ \rightarrow $}\texttt{{\nopagebreak \newline%
}\vphantom{$\{$}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{remove}\texttt{\mbox{\hspace{0.50em}}}\texttt{x}\texttt{\mbox{\hspace{0.50em}}}\texttt{\makebox[1.22ex][l]{$ {(} $}}\texttt{freeVars\makebox[1.22ex][c]{\_{}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{t}\texttt{\makebox[1.22ex][r]{$ {)} $}}\texttt{{\nopagebreak \newline%
}\vphantom{$\{$}}\texttt{freeVars\makebox[1.22ex][c]{\_{}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\makebox[1.22ex][l]{$ {(} $}}\texttt{App}\texttt{\mbox{\hspace{0.50em}}}\texttt{f}\texttt{\mbox{\hspace{0.50em}}}\texttt{a}\texttt{\makebox[1.22ex][r]{$ {)} $}}\texttt{\mbox{\hspace{0.50em}}}\texttt{{\char `\=}}\texttt{\mbox{\hspace{0.50em}}}\texttt{freeVars\makebox[1.22ex][c]{\_{}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{f}\texttt{\mbox{\hspace{0.50em}}}\texttt{++}\texttt{\mbox{\hspace{0.50em}}}\texttt{freeVars\makebox[1.22ex][c]{\_{}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{a}\texttt{{\nopagebreak \newline%
}\vphantom{$\{$}}%


\subsection{Names Are Polymorphic Indices}

%
%paragraphName: Eq Zero
Checking whether two names are equal or not is necessary to implement a large 
    class of term manipulation functions.
    To implement comparison between names, we provide the following two{~}\texttt{Eq} instances.
    First, the{~}\texttt{Zero} type is vacuously equipped with equality{:}%


{\nopagebreak }

%
%code:
%
%comment: instance Eq Zero where
%  (==) = magic
%
%magic :: Zero → a
%magic _ = error "impossible"
%
~\\~\vphantom{$\{$}\texttt{instance}\texttt{\mbox{\hspace{0.50em}}}\texttt{Eq}\texttt{\mbox{\hspace{0.50em}}}\texttt{Zero}\texttt{\mbox{\hspace{0.50em}}}\texttt{where}\texttt{{\nopagebreak \newline%
}\vphantom{$\{$}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\makebox[1.22ex][l]{$ {(} $}}\texttt{{\char `\=}{\char `\=}}\texttt{\makebox[1.22ex][r]{$ {)} $}}\texttt{\mbox{\hspace{0.50em}}}\texttt{{\char `\=}}\texttt{\mbox{\hspace{0.50em}}}\texttt{magic}\texttt{{\nopagebreak \newline%
}\vphantom{$\{$}}\texttt{{\nopagebreak \newline%
}\vphantom{$\{$}}\texttt{magic}\texttt{\mbox{\hspace{0.50em}}}\texttt{{:}{:}}\texttt{\mbox{\hspace{0.50em}}}\texttt{Zero}\texttt{\mbox{\hspace{0.50em}}}\texttt{$ \rightarrow $}\texttt{\mbox{\hspace{0.50em}}}\texttt{a}\texttt{{\nopagebreak \newline%
}\vphantom{$\{$}}\texttt{magic}\texttt{\mbox{\hspace{0.50em}}}\texttt{\makebox[1.22ex][c]{\_{}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{{\char `\=}}\texttt{\mbox{\hspace{0.50em}}}\texttt{error}\texttt{\mbox{\hspace{0.50em}}}\texttt{"impossible"}\texttt{{\nopagebreak \newline%
}\vphantom{$\{$}}%


%
%paragraphName:
Second, if two indices refer to the first variable they are equal;
    otherwise we recurse. We stress that this equality inspects only the
    \emph{indices}, not the values contained in the type. For
    example{~}\texttt{New}\texttt{\mbox{\hspace{0.50em}}}\texttt{0}\texttt{\mbox{\hspace{0.50em}}}\texttt{{\char `\=}{\char `\=}}\texttt{\mbox{\hspace{0.50em}}}\texttt{New}\texttt{\mbox{\hspace{0.50em}}}\texttt{1} is{~}\texttt{True}{:}%


{\nopagebreak }

%
%code:
%
%comment: instance Eq a ⇒ Eq (a :▹ v) where
%  New _ == New _ = True
%  Old x == Old y = x == y
%  _     == _     = False
%
~\\~\vphantom{$\{$}\texttt{instance}\texttt{\mbox{\hspace{0.50em}}}\texttt{Eq}\texttt{\mbox{\hspace{0.50em}}}\texttt{a}\texttt{\mbox{\hspace{0.50em}}}\texttt{$ \Rightarrow $}\texttt{\mbox{\hspace{0.50em}}}\texttt{Eq}\texttt{\mbox{\hspace{0.50em}}}\texttt{\makebox[1.22ex][l]{$ {(} $}}\texttt{a}\texttt{\mbox{\hspace{0.50em}}}\texttt{$ \vartriangleright $}\texttt{\mbox{\hspace{0.50em}}}\texttt{v}\texttt{\makebox[1.22ex][r]{$ {)} $}}\texttt{\mbox{\hspace{0.50em}}}\texttt{where}\texttt{{\nopagebreak \newline%
}\vphantom{$\{$}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{New}\texttt{\mbox{\hspace{0.50em}}}\texttt{\makebox[1.22ex][c]{\_{}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{{\char `\=}{\char `\=}}\texttt{\mbox{\hspace{0.50em}}}\texttt{New}\texttt{\mbox{\hspace{0.50em}}}\texttt{\makebox[1.22ex][c]{\_{}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{{\char `\=}}\texttt{\mbox{\hspace{0.50em}}}\texttt{True}\texttt{{\nopagebreak \newline%
}\vphantom{$\{$}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{Old}\texttt{\mbox{\hspace{0.50em}}}\texttt{x}\texttt{\mbox{\hspace{0.50em}}}\texttt{{\char `\=}{\char `\=}}\texttt{\mbox{\hspace{0.50em}}}\texttt{Old}\texttt{\mbox{\hspace{0.50em}}}\texttt{y}\texttt{\mbox{\hspace{0.50em}}}\texttt{{\char `\=}}\texttt{\mbox{\hspace{0.50em}}}\texttt{x}\texttt{\mbox{\hspace{0.50em}}}\texttt{{\char `\=}{\char `\=}}\texttt{\mbox{\hspace{0.50em}}}\texttt{y}\texttt{{\nopagebreak \newline%
}\vphantom{$\{$}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\makebox[1.22ex][c]{\_{}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{{\char `\=}{\char `\=}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\makebox[1.22ex][c]{\_{}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{{\char `\=}}\texttt{\mbox{\hspace{0.50em}}}\texttt{False}\texttt{{\nopagebreak \newline%
}\vphantom{$\{$}}%


%
%paragraphName:
Comparing naked de{~}Bruijn indices for equality is an error prone
    operation, because one index might be valid in a context different
    from the other, and thus an arbitrary adjustment might be required.
    With Nested Abstract Syntax, the situation improves{:} by requiring
    equality to be performed between indices of the same type, a whole
    class of errors are prevented by type-checking. Some mistakes are
    possible though{:} given an index of type \texttt{a}\texttt{\mbox{\hspace{0.50em}}}\texttt{$ \vartriangleright $}\texttt{\mbox{\hspace{0.50em}}}\texttt{\makebox[1.22ex][l]{$ {(} $}}\texttt{\makebox[1.22ex][r]{$ {)} $}}\texttt{\mbox{\hspace{0.50em}}}\texttt{$ \vartriangleright $}\texttt{\mbox{\hspace{0.50em}}}\texttt{\makebox[1.22ex][l]{$ {(} $}}\texttt{\makebox[1.22ex][r]{$ {)} $}}, a swap
    of the last two variables might be the right thing to do, but
    one cannot decide if it is so from the types only. By making the
    contexts fully polymorphic as we propose, no mistake is possible.
    Hence the slogan{:} names are polymorphic indices.%


%
%paragraphName:
Consequently, the derived equality instance of{~}\texttt{Tm} gives
    $ \alpha $-equality, and is guaranteed safe in fully-polymorphic contexts.%


\subsection{Membership}

%
%paragraphName:
Given the above representation of contexts, we can implement
    the relation of context membership by a type class{~}\texttt{\makebox[1.22ex][c]{$ \in $}}, whose
    sole method performs the injection from a member of the context to
    the full context. The relation is defined by two inference rules,
    corresponding to finding the variable in the first position of the
    context, or further away in it, with the necessary injections{:}%


{\nopagebreak }

%
%code:
%
%comment: instance v :∈ (a :▹ v) where
%  inj = New
%
%instance (v :∈ a) ⇒ v :∈ (a :▹ v') where
%  inj = Old . inj
%
~\\~\vphantom{$\{$}\texttt{instance}\texttt{\mbox{\hspace{0.50em}}}\texttt{v}\texttt{\mbox{\hspace{0.50em}}}\texttt{\makebox[1.22ex][c]{$ \in $}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\makebox[1.22ex][l]{$ {(} $}}\texttt{a}\texttt{\mbox{\hspace{0.50em}}}\texttt{$ \vartriangleright $}\texttt{\mbox{\hspace{0.50em}}}\texttt{v}\texttt{\makebox[1.22ex][r]{$ {)} $}}\texttt{\mbox{\hspace{0.50em}}}\texttt{where}\texttt{{\nopagebreak \newline%
}\vphantom{$\{$}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{inj}\texttt{\mbox{\hspace{0.50em}}}\texttt{{\char `\=}}\texttt{\mbox{\hspace{0.50em}}}\texttt{New}\texttt{{\nopagebreak \newline%
}\vphantom{$\{$}}\texttt{{\nopagebreak \newline%
}\vphantom{$\{$}}\texttt{instance}\texttt{\mbox{\hspace{0.50em}}}\texttt{\makebox[1.22ex][l]{$ {(} $}}\texttt{v}\texttt{\mbox{\hspace{0.50em}}}\texttt{\makebox[1.22ex][c]{$ \in $}}\texttt{\mbox{\hspace{0.50em}}}\texttt{a}\texttt{\makebox[1.22ex][r]{$ {)} $}}\texttt{\mbox{\hspace{0.50em}}}\texttt{$ \Rightarrow $}\texttt{\mbox{\hspace{0.50em}}}\texttt{v}\texttt{\mbox{\hspace{0.50em}}}\texttt{\makebox[1.22ex][c]{$ \in $}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\makebox[1.22ex][l]{$ {(} $}}\texttt{a}\texttt{\mbox{\hspace{0.50em}}}\texttt{$ \vartriangleright $}\texttt{\mbox{\hspace{0.50em}}}\texttt{v{'}}\texttt{\makebox[1.22ex][r]{$ {)} $}}\texttt{\mbox{\hspace{0.50em}}}\texttt{where}\texttt{{\nopagebreak \newline%
}\vphantom{$\{$}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{inj}\texttt{\mbox{\hspace{0.50em}}}\texttt{{\char `\=}}\texttt{\mbox{\hspace{0.50em}}}\texttt{Old}\texttt{\mbox{\hspace{0.50em}}}\texttt{.}\texttt{\mbox{\hspace{0.50em}}}\texttt{inj}\texttt{{\nopagebreak \newline%
}\vphantom{$\{$}}%


%
%paragraphName: incoherent instances
The cognoscenti will recognize the two above instances as
    \emph{incoherent}, that is, if{~}\texttt{v} and{~}\texttt{v{'}} were instantiated
    to the same type, both instances would apply, but the injections would be different. Fortunately,
    this incoherence never triggers as long as one keeps the contexts
    maximally polymorphic contexts{:} \texttt{v} and{~}\texttt{v{'}} will always be
    different.%


%
%paragraphName: inj enables var
We have seen before that the overloading of the{~}\texttt{inj} function
    in the type class{~}\texttt{\makebox[1.22ex][c]{$ \in $}} allows to automatically convert a type-level
    reference to a term into a properly tagged de{~}Bruijn index, namely
    the function{~}\texttt{var}.%


%
%paragraphName: explain isOccurenceOf
Conversely, one can implement occurrence-check by combining  \texttt{inj} with \texttt{\makebox[1.22ex][l]{$ {(} $}}\texttt{{\char `\=}{\char `\=}}\texttt{\makebox[1.22ex][r]{$ {)} $}}{:}
    one first lifts the bound variable to the context of the chosen occurrence and
    then tests for equality.%


{\nopagebreak }

%
%code:
%
%comment: isOccurenceOf :: (Eq a, v :∈ a) ⇒ a → v → Bool
%x `isOccurenceOf` y = x == inj y
%
~\\~\vphantom{$\{$}\texttt{isOccurenceOf}\texttt{\mbox{\hspace{0.50em}}}\texttt{{:}{:}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\makebox[1.22ex][l]{$ {(} $}}\texttt{Eq}\texttt{\mbox{\hspace{0.50em}}}\texttt{a,}\texttt{\mbox{\hspace{0.50em}}}\texttt{v}\texttt{\mbox{\hspace{0.50em}}}\texttt{\makebox[1.22ex][c]{$ \in $}}\texttt{\mbox{\hspace{0.50em}}}\texttt{a}\texttt{\makebox[1.22ex][r]{$ {)} $}}\texttt{\mbox{\hspace{0.50em}}}\texttt{$ \Rightarrow $}\texttt{\mbox{\hspace{0.50em}}}\texttt{a}\texttt{\mbox{\hspace{0.50em}}}\texttt{$ \rightarrow $}\texttt{\mbox{\hspace{0.50em}}}\texttt{v}\texttt{\mbox{\hspace{0.50em}}}\texttt{$ \rightarrow $}\texttt{\mbox{\hspace{0.50em}}}\texttt{Bool}\texttt{{\nopagebreak \newline%
}\vphantom{$\{$}}\texttt{x}\texttt{\mbox{\hspace{0.50em}}}\texttt{{`}isOccurenceOf{`}}\texttt{\mbox{\hspace{0.50em}}}\texttt{y}\texttt{\mbox{\hspace{0.50em}}}\texttt{{\char `\=}}\texttt{\mbox{\hspace{0.50em}}}\texttt{x}\texttt{\mbox{\hspace{0.50em}}}\texttt{{\char `\=}{\char `\=}}\texttt{\mbox{\hspace{0.50em}}}\texttt{inj}\texttt{\mbox{\hspace{0.50em}}}\texttt{y}\texttt{{\nopagebreak \newline%
}\vphantom{$\{$}}%


%
%paragraphName: occursIn
One can test if a variable is fresh for a given term as follows{:}%


{\nopagebreak }

%
%code:
%
%comment: freshFor_ :: (Eq a, v :∈ a) ⇒ v → Tm a → Bool
%x `freshFor_` t = not (inj x `elem` freeVars_ t)
%
~\\~\vphantom{$\{$}\texttt{freshFor\makebox[1.22ex][c]{\_{}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{{:}{:}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\makebox[1.22ex][l]{$ {(} $}}\texttt{Eq}\texttt{\mbox{\hspace{0.50em}}}\texttt{a,}\texttt{\mbox{\hspace{0.50em}}}\texttt{v}\texttt{\mbox{\hspace{0.50em}}}\texttt{\makebox[1.22ex][c]{$ \in $}}\texttt{\mbox{\hspace{0.50em}}}\texttt{a}\texttt{\makebox[1.22ex][r]{$ {)} $}}\texttt{\mbox{\hspace{0.50em}}}\texttt{$ \Rightarrow $}\texttt{\mbox{\hspace{0.50em}}}\texttt{v}\texttt{\mbox{\hspace{0.50em}}}\texttt{$ \rightarrow $}\texttt{\mbox{\hspace{0.50em}}}\texttt{Tm}\texttt{\mbox{\hspace{0.50em}}}\texttt{a}\texttt{\mbox{\hspace{0.50em}}}\texttt{$ \rightarrow $}\texttt{\mbox{\hspace{0.50em}}}\texttt{Bool}\texttt{{\nopagebreak \newline%
}\vphantom{$\{$}}\texttt{x}\texttt{\mbox{\hspace{0.50em}}}\texttt{{`}freshFor\makebox[1.22ex][c]{\_{}}{`}}\texttt{\mbox{\hspace{0.50em}}}\texttt{t}\texttt{\mbox{\hspace{0.50em}}}\texttt{{\char `\=}}\texttt{\mbox{\hspace{0.50em}}}\texttt{not}\texttt{\mbox{\hspace{0.50em}}}\texttt{\makebox[1.22ex][l]{$ {(} $}}\texttt{inj}\texttt{\mbox{\hspace{0.50em}}}\texttt{x}\texttt{\mbox{\hspace{0.50em}}}\texttt{{`}elem{`}}\texttt{\mbox{\hspace{0.50em}}}\texttt{freeVars\makebox[1.22ex][c]{\_{}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{t}\texttt{\makebox[1.22ex][r]{$ {)} $}}\texttt{{\nopagebreak \newline%
}\vphantom{$\{$}}%


\subsection{Inclusion}

%
%paragraphName: context inclusion, ⊆
Another useful relation is context inclusion between contexts, which we also
    represent by a type class, named{~}\texttt{\makebox[1.83ex][c]{$ \subseteq $}}. The sole method of the
    typeclass is again an injection, from the small context to the
    bigger one. The main application of \texttt{\makebox[1.83ex][c]{$ \subseteq $}} is in term weakening,
    presented at the end of sec. \ref{functorSec}.%


{\nopagebreak }

%
%code:
%
%comment: class a :⊆ b where
%  injMany :: a → b
%
~\\~\vphantom{$\{$}\texttt{class}\texttt{\mbox{\hspace{0.50em}}}\texttt{a}\texttt{\mbox{\hspace{0.50em}}}\texttt{\makebox[1.83ex][c]{$ \subseteq $}}\texttt{\mbox{\hspace{0.50em}}}\texttt{b}\texttt{\mbox{\hspace{0.50em}}}\texttt{where}\texttt{{\nopagebreak \newline%
}\vphantom{$\{$}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{injMany}\texttt{\mbox{\hspace{0.50em}}}\texttt{{:}{:}}\texttt{\mbox{\hspace{0.50em}}}\texttt{a}\texttt{\mbox{\hspace{0.50em}}}\texttt{$ \rightarrow $}\texttt{\mbox{\hspace{0.50em}}}\texttt{b}\texttt{{\nopagebreak \newline%
}\vphantom{$\{$}}%


%
%paragraphName: ⊆ instances
This time we have four instances{:} inclusion is reflexive; the empty
    context is the smallest one; adding a variable makes the context
    larger; and variable append{~}\texttt{\makebox[1.22ex][l]{$ {(} $}}\texttt{$ \vartriangleright $}\texttt{\mbox{\hspace{0.50em}}}\texttt{v}\texttt{\makebox[1.22ex][r]{$ {)} $}} is monotonic for inclusion.%


{\nopagebreak }

%
%code:
%
%comment: instance a :⊆ a where injMany = id
%
%instance Zero :⊆ a where injMany = magic
%
%instance (a :⊆ b) ⇒ a :⊆ (b :▹ v) where
%  injMany = Old . injMany
%
%instance (a :⊆ b) ⇒ (a :▹ v) :⊆ (b :▹ v) where
%  injMany = mapOld injMany
%
~\\~\vphantom{$\{$}\texttt{instance}\texttt{\mbox{\hspace{0.50em}}}\texttt{a}\texttt{\mbox{\hspace{0.50em}}}\texttt{\makebox[1.83ex][c]{$ \subseteq $}}\texttt{\mbox{\hspace{0.50em}}}\texttt{a}\texttt{\mbox{\hspace{0.50em}}}\texttt{where}\texttt{\mbox{\hspace{0.50em}}}\texttt{injMany}\texttt{\mbox{\hspace{0.50em}}}\texttt{{\char `\=}}\texttt{\mbox{\hspace{0.50em}}}\texttt{id}\texttt{{\nopagebreak \newline%
}\vphantom{$\{$}}\texttt{{\nopagebreak \newline%
}\vphantom{$\{$}}\texttt{instance}\texttt{\mbox{\hspace{0.50em}}}\texttt{Zero}\texttt{\mbox{\hspace{0.50em}}}\texttt{\makebox[1.83ex][c]{$ \subseteq $}}\texttt{\mbox{\hspace{0.50em}}}\texttt{a}\texttt{\mbox{\hspace{0.50em}}}\texttt{where}\texttt{\mbox{\hspace{0.50em}}}\texttt{injMany}\texttt{\mbox{\hspace{0.50em}}}\texttt{{\char `\=}}\texttt{\mbox{\hspace{0.50em}}}\texttt{magic}\texttt{{\nopagebreak \newline%
}\vphantom{$\{$}}\texttt{{\nopagebreak \newline%
}\vphantom{$\{$}}\texttt{instance}\texttt{\mbox{\hspace{0.50em}}}\texttt{\makebox[1.22ex][l]{$ {(} $}}\texttt{a}\texttt{\mbox{\hspace{0.50em}}}\texttt{\makebox[1.83ex][c]{$ \subseteq $}}\texttt{\mbox{\hspace{0.50em}}}\texttt{b}\texttt{\makebox[1.22ex][r]{$ {)} $}}\texttt{\mbox{\hspace{0.50em}}}\texttt{$ \Rightarrow $}\texttt{\mbox{\hspace{0.50em}}}\texttt{a}\texttt{\mbox{\hspace{0.50em}}}\texttt{\makebox[1.83ex][c]{$ \subseteq $}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\makebox[1.22ex][l]{$ {(} $}}\texttt{b}\texttt{\mbox{\hspace{0.50em}}}\texttt{$ \vartriangleright $}\texttt{\mbox{\hspace{0.50em}}}\texttt{v}\texttt{\makebox[1.22ex][r]{$ {)} $}}\texttt{\mbox{\hspace{0.50em}}}\texttt{where}\texttt{{\nopagebreak \newline%
}\vphantom{$\{$}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{injMany}\texttt{\mbox{\hspace{0.50em}}}\texttt{{\char `\=}}\texttt{\mbox{\hspace{0.50em}}}\texttt{Old}\texttt{\mbox{\hspace{0.50em}}}\texttt{.}\texttt{\mbox{\hspace{0.50em}}}\texttt{injMany}\texttt{{\nopagebreak \newline%
}\vphantom{$\{$}}\texttt{{\nopagebreak \newline%
}\vphantom{$\{$}}\texttt{instance}\texttt{\mbox{\hspace{0.50em}}}\texttt{\makebox[1.22ex][l]{$ {(} $}}\texttt{a}\texttt{\mbox{\hspace{0.50em}}}\texttt{\makebox[1.83ex][c]{$ \subseteq $}}\texttt{\mbox{\hspace{0.50em}}}\texttt{b}\texttt{\makebox[1.22ex][r]{$ {)} $}}\texttt{\mbox{\hspace{0.50em}}}\texttt{$ \Rightarrow $}\texttt{\mbox{\hspace{0.50em}}}\texttt{\makebox[1.22ex][l]{$ {(} $}}\texttt{a}\texttt{\mbox{\hspace{0.50em}}}\texttt{$ \vartriangleright $}\texttt{\mbox{\hspace{0.50em}}}\texttt{v}\texttt{\makebox[1.22ex][r]{$ {)} $}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\makebox[1.83ex][c]{$ \subseteq $}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\makebox[1.22ex][l]{$ {(} $}}\texttt{b}\texttt{\mbox{\hspace{0.50em}}}\texttt{$ \vartriangleright $}\texttt{\mbox{\hspace{0.50em}}}\texttt{v}\texttt{\makebox[1.22ex][r]{$ {)} $}}\texttt{\mbox{\hspace{0.50em}}}\texttt{where}\texttt{{\nopagebreak \newline%
}\vphantom{$\{$}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{injMany}\texttt{\mbox{\hspace{0.50em}}}\texttt{{\char `\=}}\texttt{\mbox{\hspace{0.50em}}}\texttt{mapOld}\texttt{\mbox{\hspace{0.50em}}}\texttt{injMany}\texttt{{\nopagebreak \newline%
}\vphantom{$\{$}}%


%
%paragraphName: (▹) functoriality
This last case uses the fact that{~}\texttt{\makebox[1.22ex][l]{$ {(} $}}\texttt{$ \vartriangleright $}\texttt{\makebox[1.22ex][r]{$ {)} $}} is functorial in its first argument.%


\section{Term Structure\label{termStructure}}

%
%paragraphName: motivation
It is well-known that every term representation parameterized
    on the type of free variables should exhibit monadic structure,
    with substitution corresponding to the binding operator \cite{bellegarde-94,bird-paterson-99,altenkirch-reus-99}. That is, a{~}\texttt{Monad}\texttt{\mbox{\hspace{0.50em}}}\texttt{tm} constraint means that a
    term representation{~}\texttt{tm} is stable under substitution. In this
    section we review this structure, as well as other standard
    related structures on terms. These structures are perhaps easier
    to implement directly on a concrete term representation, rather
    than our interface. However, we give an implementation solely based
    on it, to demonstrate that it is complete with respect to these
    structures. By doing so, we also illustrate how to work with our
    interface in practice.%


\subsection{Renaming and Functors\label{functorSec}}

%
%paragraphName: intro functor
The first, perhaps simplest, property of terms is that free
    variables can be renamed. This property is captured by
    the{~}\texttt{Functor} structure.%


%
%paragraphName: describe Functor Tm
The {``}renaming{''} to apply is given as a function{~}\texttt{f} from{~}\texttt{a}    to{~}\texttt{b} where{~}\texttt{a} is the type of free variables of the input
    term{~}(\texttt{Tm}\texttt{\mbox{\hspace{0.50em}}}\texttt{a}) and{~}\texttt{b} is the type of free variables of the
    {``}renamed{''} term{~}(\texttt{Tm}\texttt{\mbox{\hspace{0.50em}}}\texttt{b}). While the function \texttt{f} should be injective
    to be considered a renaming, the functor instance
    works well for any function{~}\texttt{f}. The renaming operation then
    simply preserves the structure of the input term. At occurrence
    sites it uses{~}\texttt{f} to rename free variables. At binding sites,
    \texttt{f} is upgraded from{~}\texttt{\makebox[1.22ex][l]{$ {(} $}}\texttt{a}\texttt{\mbox{\hspace{0.50em}}}\texttt{$ \rightarrow $}\texttt{\mbox{\hspace{0.50em}}}\texttt{b}\texttt{\makebox[1.22ex][r]{$ {)} $}} to{~}\texttt{\makebox[1.22ex][l]{$ {(} $}}\texttt{a}\texttt{\mbox{\hspace{0.50em}}}\texttt{$ \vartriangleright $}\texttt{\mbox{\hspace{0.50em}}}\texttt{v}\texttt{\mbox{\hspace{0.50em}}}\texttt{$ \rightarrow $}\texttt{\mbox{\hspace{0.50em}}}\texttt{b}\texttt{\mbox{\hspace{0.50em}}}\texttt{$ \vartriangleright $}\texttt{\mbox{\hspace{0.50em}}}\texttt{v}\texttt{\makebox[1.22ex][r]{$ {)} $}} using
    the functoriality of{~}\texttt{\makebox[1.22ex][l]{$ {(} $}}\texttt{$ \vartriangleright $}\texttt{\mbox{\hspace{0.50em}}}\texttt{v}\texttt{\makebox[1.22ex][r]{$ {)} $}} with{~}\texttt{mapOld}\texttt{\mbox{\hspace{0.50em}}}\texttt{f}. Adapting the
    function{~}\texttt{f} is necessary to protect the bound name from being
    altered by{~}\texttt{f}, and thanks to our use of polymorphism, the
    type-checker ensures that we make no mistake in doing so.%


{\nopagebreak }

%
%code:
%
%comment: instance Functor Tm where
%  fmap f (Var x)   = Var (f x)
%  fmap f (Lam b)   = unpack b $ \ x t →
%                       lamP x $ fmap (mapOld f) t
%  fmap f (App t u) = App (fmap f t) (fmap f u)
%
~\\~\vphantom{$\{$}\texttt{instance}\texttt{\mbox{\hspace{0.50em}}}\texttt{Functor}\texttt{\mbox{\hspace{0.50em}}}\texttt{Tm}\texttt{\mbox{\hspace{0.50em}}}\texttt{where}\texttt{{\nopagebreak \newline%
}\vphantom{$\{$}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{fmap}\texttt{\mbox{\hspace{0.50em}}}\texttt{f}\texttt{\mbox{\hspace{0.50em}}}\texttt{\makebox[1.22ex][l]{$ {(} $}}\texttt{Var}\texttt{\mbox{\hspace{0.50em}}}\texttt{x}\texttt{\makebox[1.22ex][r]{$ {)} $}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{{\char `\=}}\texttt{\mbox{\hspace{0.50em}}}\texttt{Var}\texttt{\mbox{\hspace{0.50em}}}\texttt{\makebox[1.22ex][l]{$ {(} $}}\texttt{f}\texttt{\mbox{\hspace{0.50em}}}\texttt{x}\texttt{\makebox[1.22ex][r]{$ {)} $}}\texttt{{\nopagebreak \newline%
}\vphantom{$\{$}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{fmap}\texttt{\mbox{\hspace{0.50em}}}\texttt{f}\texttt{\mbox{\hspace{0.50em}}}\texttt{\makebox[1.22ex][l]{$ {(} $}}\texttt{Lam}\texttt{\mbox{\hspace{0.50em}}}\texttt{b}\texttt{\makebox[1.22ex][r]{$ {)} $}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{{\char `\=}}\texttt{\mbox{\hspace{0.50em}}}\texttt{unpack}\texttt{\mbox{\hspace{0.50em}}}\texttt{b}\texttt{\mbox{\hspace{0.50em}}}\texttt{\${}}\texttt{\mbox{\hspace{0.50em}}}\texttt{$ \lambda $}\texttt{\mbox{\hspace{0.50em}}}\texttt{x}\texttt{\mbox{\hspace{0.50em}}}\texttt{t}\texttt{\mbox{\hspace{0.50em}}}\texttt{$ \rightarrow $}\texttt{{\nopagebreak \newline%
}\vphantom{$\{$}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{lamP}\texttt{\mbox{\hspace{0.50em}}}\texttt{x}\texttt{\mbox{\hspace{0.50em}}}\texttt{\${}}\texttt{\mbox{\hspace{0.50em}}}\texttt{fmap}\texttt{\mbox{\hspace{0.50em}}}\texttt{\makebox[1.22ex][l]{$ {(} $}}\texttt{mapOld}\texttt{\mbox{\hspace{0.50em}}}\texttt{f}\texttt{\makebox[1.22ex][r]{$ {)} $}}\texttt{\mbox{\hspace{0.50em}}}\texttt{t}\texttt{{\nopagebreak \newline%
}\vphantom{$\{$}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{fmap}\texttt{\mbox{\hspace{0.50em}}}\texttt{f}\texttt{\mbox{\hspace{0.50em}}}\texttt{\makebox[1.22ex][l]{$ {(} $}}\texttt{App}\texttt{\mbox{\hspace{0.50em}}}\texttt{t}\texttt{\mbox{\hspace{0.50em}}}\texttt{u}\texttt{\makebox[1.22ex][r]{$ {)} $}}\texttt{\mbox{\hspace{0.50em}}}\texttt{{\char `\=}}\texttt{\mbox{\hspace{0.50em}}}\texttt{App}\texttt{\mbox{\hspace{0.50em}}}\texttt{\makebox[1.22ex][l]{$ {(} $}}\texttt{fmap}\texttt{\mbox{\hspace{0.50em}}}\texttt{f}\texttt{\mbox{\hspace{0.50em}}}\texttt{t}\texttt{\makebox[1.22ex][r]{$ {)} $}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\makebox[1.22ex][l]{$ {(} $}}\texttt{fmap}\texttt{\mbox{\hspace{0.50em}}}\texttt{f}\texttt{\mbox{\hspace{0.50em}}}\texttt{u}\texttt{\makebox[1.22ex][r]{$ {)} $}}\texttt{{\nopagebreak \newline%
}\vphantom{$\{$}}%


%
%paragraphName: functor laws
As usual satisfying functor laws implies that the structure is
    preserved by the functor action (\texttt{fmap}). The type for terms being
    a functor therefore means that applying a renaming is going to only
    affect the free variables and leave the structure untouched. That is,
    whatever the function{~}\texttt{f} is doing, the bound names are not
    changing. The \texttt{Functor} laws are the following{:}%


%
%comment: {- --
%


{\nopagebreak }

%
%code:
%
%comment: fmap id ≡ id
%fmap (f . g) ≡ fmap f . fmap g
%
~\\~\vphantom{$\{$}\texttt{fmap}\texttt{\mbox{\hspace{0.50em}}}\texttt{id}\texttt{\mbox{\hspace{0.50em}}}\texttt{$ \equiv $}\texttt{\mbox{\hspace{0.50em}}}\texttt{id}\texttt{{\nopagebreak \newline%
}\vphantom{$\{$}}\texttt{fmap}\texttt{\mbox{\hspace{0.50em}}}\texttt{\makebox[1.22ex][l]{$ {(} $}}\texttt{f}\texttt{\mbox{\hspace{0.50em}}}\texttt{.}\texttt{\mbox{\hspace{0.50em}}}\texttt{g}\texttt{\makebox[1.22ex][r]{$ {)} $}}\texttt{\mbox{\hspace{0.50em}}}\texttt{$ \equiv $}\texttt{\mbox{\hspace{0.50em}}}\texttt{fmap}\texttt{\mbox{\hspace{0.50em}}}\texttt{f}\texttt{\mbox{\hspace{0.50em}}}\texttt{.}\texttt{\mbox{\hspace{0.50em}}}\texttt{fmap}\texttt{\mbox{\hspace{0.50em}}}\texttt{g}\texttt{{\nopagebreak \newline%
}\vphantom{$\{$}}%


%
%comment: -- -}
%


%
%paragraphName: reading the laws
In terms of renaming, they mean that the identity function corresponds
    to not renaming anything
    and compositions of renaming functions corresponds to two sequential
    renaming operations.%


%
%paragraphName:
Assuming only a functor structure, it is possible to write useful
    functions on terms which involve only renaming. A couple of examples
    follow.%


%
%paragraphName:
First, let us assume an equality test on free variables. 
    We can then write a function
    \texttt{rename}\texttt{\mbox{\hspace{0.50em}}}\texttt{\makebox[1.22ex][l]{$ {(} $}}\texttt{x,y}\texttt{\makebox[1.22ex][r]{$ {)} $}}\texttt{\mbox{\hspace{0.50em}}}\texttt{t} which replaces free occurrences of{~}\texttt{x} in{~}\texttt{t}    by{~}\texttt{y} and{~}\texttt{swap}\texttt{\mbox{\hspace{0.50em}}}\texttt{\makebox[1.22ex][l]{$ {(} $}}\texttt{x,y}\texttt{\makebox[1.22ex][r]{$ {)} $}}\texttt{\mbox{\hspace{0.50em}}}\texttt{t} which exchanges free occurrences
    of{~}\texttt{x} and{~}\texttt{y} in{~}\texttt{t}.%


{\nopagebreak }

%
%code:
%
%comment: rename0 :: Eq a ⇒ (a, a) → a → a
%rename0 (x,y) z | z == x    = y
%                | otherwise = z
%
%rename :: (Functor f, Eq a) ⇒ (a, a) → f a → f a
%rename = fmap . rename0
%
~\\~\vphantom{$\{$}\texttt{rename0}\texttt{\mbox{\hspace{0.50em}}}\texttt{{:}{:}}\texttt{\mbox{\hspace{0.50em}}}\texttt{Eq}\texttt{\mbox{\hspace{0.50em}}}\texttt{a}\texttt{\mbox{\hspace{0.50em}}}\texttt{$ \Rightarrow $}\texttt{\mbox{\hspace{0.50em}}}\texttt{\makebox[1.22ex][l]{$ {(} $}}\texttt{a,}\texttt{\mbox{\hspace{0.50em}}}\texttt{a}\texttt{\makebox[1.22ex][r]{$ {)} $}}\texttt{\mbox{\hspace{0.50em}}}\texttt{$ \rightarrow $}\texttt{\mbox{\hspace{0.50em}}}\texttt{a}\texttt{\mbox{\hspace{0.50em}}}\texttt{$ \rightarrow $}\texttt{\mbox{\hspace{0.50em}}}\texttt{a}\texttt{{\nopagebreak \newline%
}\vphantom{$\{$}}\texttt{rename0}\texttt{\mbox{\hspace{0.50em}}}\texttt{\makebox[1.22ex][l]{$ {(} $}}\texttt{x,y}\texttt{\makebox[1.22ex][r]{$ {)} $}}\texttt{\mbox{\hspace{0.50em}}}\texttt{z}\texttt{\mbox{\hspace{0.50em}}}\texttt{\makebox[1.22ex][c]{\textbar{}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{z}\texttt{\mbox{\hspace{0.50em}}}\texttt{{\char `\=}{\char `\=}}\texttt{\mbox{\hspace{0.50em}}}\texttt{x}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{{\char `\=}}\texttt{\mbox{\hspace{0.50em}}}\texttt{y}\texttt{{\nopagebreak \newline%
}\vphantom{$\{$}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\makebox[1.22ex][c]{\textbar{}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{otherwise}\texttt{\mbox{\hspace{0.50em}}}\texttt{{\char `\=}}\texttt{\mbox{\hspace{0.50em}}}\texttt{z}\texttt{{\nopagebreak \newline%
}\vphantom{$\{$}}\texttt{{\nopagebreak \newline%
}\vphantom{$\{$}}\texttt{rename}\texttt{\mbox{\hspace{0.50em}}}\texttt{{:}{:}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\makebox[1.22ex][l]{$ {(} $}}\texttt{Functor}\texttt{\mbox{\hspace{0.50em}}}\texttt{f,}\texttt{\mbox{\hspace{0.50em}}}\texttt{Eq}\texttt{\mbox{\hspace{0.50em}}}\texttt{a}\texttt{\makebox[1.22ex][r]{$ {)} $}}\texttt{\mbox{\hspace{0.50em}}}\texttt{$ \Rightarrow $}\texttt{\mbox{\hspace{0.50em}}}\texttt{\makebox[1.22ex][l]{$ {(} $}}\texttt{a,}\texttt{\mbox{\hspace{0.50em}}}\texttt{a}\texttt{\makebox[1.22ex][r]{$ {)} $}}\texttt{\mbox{\hspace{0.50em}}}\texttt{$ \rightarrow $}\texttt{\mbox{\hspace{0.50em}}}\texttt{f}\texttt{\mbox{\hspace{0.50em}}}\texttt{a}\texttt{\mbox{\hspace{0.50em}}}\texttt{$ \rightarrow $}\texttt{\mbox{\hspace{0.50em}}}\texttt{f}\texttt{\mbox{\hspace{0.50em}}}\texttt{a}\texttt{{\nopagebreak \newline%
}\vphantom{$\{$}}\texttt{rename}\texttt{\mbox{\hspace{0.50em}}}\texttt{{\char `\=}}\texttt{\mbox{\hspace{0.50em}}}\texttt{fmap}\texttt{\mbox{\hspace{0.50em}}}\texttt{.}\texttt{\mbox{\hspace{0.50em}}}\texttt{rename0}\texttt{{\nopagebreak \newline%
}\vphantom{$\{$}}%


%
%code:
{\noindent}%
%comment: swap0 :: Eq a ⇒ (a, a) → a → a
%swap0 (x,y) z | z == y    = x
%              | z == x    = y
%              | otherwise = z
%
%swap :: (Functor f, Eq a) ⇒ (a, a) → f a → f a
%swap = fmap . swap0
%
\vphantom{$\{$}\texttt{swap0}\texttt{\mbox{\hspace{0.50em}}}\texttt{{:}{:}}\texttt{\mbox{\hspace{0.50em}}}\texttt{Eq}\texttt{\mbox{\hspace{0.50em}}}\texttt{a}\texttt{\mbox{\hspace{0.50em}}}\texttt{$ \Rightarrow $}\texttt{\mbox{\hspace{0.50em}}}\texttt{\makebox[1.22ex][l]{$ {(} $}}\texttt{a,}\texttt{\mbox{\hspace{0.50em}}}\texttt{a}\texttt{\makebox[1.22ex][r]{$ {)} $}}\texttt{\mbox{\hspace{0.50em}}}\texttt{$ \rightarrow $}\texttt{\mbox{\hspace{0.50em}}}\texttt{a}\texttt{\mbox{\hspace{0.50em}}}\texttt{$ \rightarrow $}\texttt{\mbox{\hspace{0.50em}}}\texttt{a}\texttt{{\nopagebreak \newline%
}\vphantom{$\{$}}\texttt{swap0}\texttt{\mbox{\hspace{0.50em}}}\texttt{\makebox[1.22ex][l]{$ {(} $}}\texttt{x,y}\texttt{\makebox[1.22ex][r]{$ {)} $}}\texttt{\mbox{\hspace{0.50em}}}\texttt{z}\texttt{\mbox{\hspace{0.50em}}}\texttt{\makebox[1.22ex][c]{\textbar{}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{z}\texttt{\mbox{\hspace{0.50em}}}\texttt{{\char `\=}{\char `\=}}\texttt{\mbox{\hspace{0.50em}}}\texttt{y}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{{\char `\=}}\texttt{\mbox{\hspace{0.50em}}}\texttt{x}\texttt{{\nopagebreak \newline%
}\vphantom{$\{$}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\makebox[1.22ex][c]{\textbar{}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{z}\texttt{\mbox{\hspace{0.50em}}}\texttt{{\char `\=}{\char `\=}}\texttt{\mbox{\hspace{0.50em}}}\texttt{x}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{{\char `\=}}\texttt{\mbox{\hspace{0.50em}}}\texttt{y}\texttt{{\nopagebreak \newline%
}\vphantom{$\{$}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\makebox[1.22ex][c]{\textbar{}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{otherwise}\texttt{\mbox{\hspace{0.50em}}}\texttt{{\char `\=}}\texttt{\mbox{\hspace{0.50em}}}\texttt{z}\texttt{{\nopagebreak \newline%
}\vphantom{$\{$}}\texttt{{\nopagebreak \newline%
}\vphantom{$\{$}}\texttt{swap}\texttt{\mbox{\hspace{0.50em}}}\texttt{{:}{:}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\makebox[1.22ex][l]{$ {(} $}}\texttt{Functor}\texttt{\mbox{\hspace{0.50em}}}\texttt{f,}\texttt{\mbox{\hspace{0.50em}}}\texttt{Eq}\texttt{\mbox{\hspace{0.50em}}}\texttt{a}\texttt{\makebox[1.22ex][r]{$ {)} $}}\texttt{\mbox{\hspace{0.50em}}}\texttt{$ \Rightarrow $}\texttt{\mbox{\hspace{0.50em}}}\texttt{\makebox[1.22ex][l]{$ {(} $}}\texttt{a,}\texttt{\mbox{\hspace{0.50em}}}\texttt{a}\texttt{\makebox[1.22ex][r]{$ {)} $}}\texttt{\mbox{\hspace{0.50em}}}\texttt{$ \rightarrow $}\texttt{\mbox{\hspace{0.50em}}}\texttt{f}\texttt{\mbox{\hspace{0.50em}}}\texttt{a}\texttt{\mbox{\hspace{0.50em}}}\texttt{$ \rightarrow $}\texttt{\mbox{\hspace{0.50em}}}\texttt{f}\texttt{\mbox{\hspace{0.50em}}}\texttt{a}\texttt{{\nopagebreak \newline%
}\vphantom{$\{$}}\texttt{swap}\texttt{\mbox{\hspace{0.50em}}}\texttt{{\char `\=}}\texttt{\mbox{\hspace{0.50em}}}\texttt{fmap}\texttt{\mbox{\hspace{0.50em}}}\texttt{.}\texttt{\mbox{\hspace{0.50em}}}\texttt{swap0}\texttt{{\nopagebreak \newline%
}\vphantom{$\{$}}%


%
%paragraphName: auto-weakening
Second, let us assume two arguments{~}\texttt{a} and{~}\texttt{b} related by the
    type class{~}\texttt{\makebox[1.83ex][c]{$ \subseteq $}}. Thus we have{~}\texttt{injMany} of type{~}\texttt{a}\texttt{\mbox{\hspace{0.50em}}}\texttt{$ \rightarrow $}\texttt{\mbox{\hspace{0.50em}}}\texttt{b}, which
    can be seen as a renaming of free variables via the functorial
    structure of terms. By applying{~}\texttt{fmap} to it, one obtains
    an arbitrary weakening from the context{~}\texttt{a} to the bigger
    context{~}\texttt{b}.%


{\nopagebreak }

%
%code:
%
%comment: wk :: (Functor f, a :⊆ b) ⇒ f a → f b
%wk = fmap injMany
%
~\\~\vphantom{$\{$}\texttt{wk}\texttt{\mbox{\hspace{0.50em}}}\texttt{{:}{:}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\makebox[1.22ex][l]{$ {(} $}}\texttt{Functor}\texttt{\mbox{\hspace{0.50em}}}\texttt{f,}\texttt{\mbox{\hspace{0.50em}}}\texttt{a}\texttt{\mbox{\hspace{0.50em}}}\texttt{\makebox[1.83ex][c]{$ \subseteq $}}\texttt{\mbox{\hspace{0.50em}}}\texttt{b}\texttt{\makebox[1.22ex][r]{$ {)} $}}\texttt{\mbox{\hspace{0.50em}}}\texttt{$ \Rightarrow $}\texttt{\mbox{\hspace{0.50em}}}\texttt{f}\texttt{\mbox{\hspace{0.50em}}}\texttt{a}\texttt{\mbox{\hspace{0.50em}}}\texttt{$ \rightarrow $}\texttt{\mbox{\hspace{0.50em}}}\texttt{f}\texttt{\mbox{\hspace{0.50em}}}\texttt{b}\texttt{{\nopagebreak \newline%
}\vphantom{$\{$}}\texttt{wk}\texttt{\mbox{\hspace{0.50em}}}\texttt{{\char `\=}}\texttt{\mbox{\hspace{0.50em}}}\texttt{fmap}\texttt{\mbox{\hspace{0.50em}}}\texttt{injMany}\texttt{{\nopagebreak \newline%
}\vphantom{$\{$}}%


%
%paragraphName:
Again, this arbitrary weakening function relieves the programmer from
    tediously counting indices and constructing an appropriate renaming function. We
    demonstrate this feature in sec. \ref{examples}.%


\subsection{Substitution and Monads\label{monadSec}}

%
%paragraphName:
Another useful property of terms is that they can be substituted for free variables in
    other terms. This property is captured algebraically by asserting
    that terms form a{~}\texttt{Monad}, where \texttt{return} is the variable
    constructor and{~}\texttt{\makebox[1.22ex][c]{\textgreater{}}\makebox[1.22ex][c]{\textgreater{}}{\char `\=}} acts as parallel substitution. Indeed, one
    can see a substitution from a context{~}\texttt{a} to a context{~}\texttt{b} as
    mapping from{~}\texttt{a} to{~}\texttt{Tm}\texttt{\mbox{\hspace{0.50em}}}\texttt{b}, (technically a morphism in the associated Kleisli
    category) and{~}\texttt{\makebox[1.22ex][l]{$ {(} $}}\texttt{\makebox[1.22ex][c]{\textgreater{}}\makebox[1.22ex][c]{\textgreater{}}{\char `\=}}\texttt{\makebox[1.22ex][r]{$ {)} $}} applies a substitution everywhere in a term.%


%
%paragraphName:
The definition of the{~}\texttt{Monad} instance is straightforward for
    variable and application, and we isolate the handling of binders in
    the{~}\texttt{\makebox[1.22ex][l]{$ {(} $}}\texttt{\makebox[1.22ex][c]{\textgreater{}}\makebox[1.22ex][c]{\textgreater{}}\makebox[1.22ex][c]{\textgreater{}}{\char `\=}}\texttt{\makebox[1.22ex][r]{$ {)} $}} function.%


{\nopagebreak }

%
%code:
%
%comment: instance Monad Tm where
%  return = Var
%  Var x   >>= θ = θ x
%  Lam s   >>= θ = Lam (s >>>= θ)
%  App t u >>= θ = App (t >>= θ) (u >>= θ)
%
~\\~\vphantom{$\{$}\texttt{instance}\texttt{\mbox{\hspace{0.50em}}}\texttt{Monad}\texttt{\mbox{\hspace{0.50em}}}\texttt{Tm}\texttt{\mbox{\hspace{0.50em}}}\texttt{where}\texttt{{\nopagebreak \newline%
}\vphantom{$\{$}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{return}\texttt{\mbox{\hspace{0.50em}}}\texttt{{\char `\=}}\texttt{\mbox{\hspace{0.50em}}}\texttt{Var}\texttt{{\nopagebreak \newline%
}\vphantom{$\{$}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{Var}\texttt{\mbox{\hspace{0.50em}}}\texttt{x}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\makebox[1.22ex][c]{\textgreater{}}\makebox[1.22ex][c]{\textgreater{}}{\char `\=}}\texttt{\mbox{\hspace{0.50em}}}\texttt{$ \theta $}\texttt{\mbox{\hspace{0.50em}}}\texttt{{\char `\=}}\texttt{\mbox{\hspace{0.50em}}}\texttt{$ \theta $}\texttt{\mbox{\hspace{0.50em}}}\texttt{x}\texttt{{\nopagebreak \newline%
}\vphantom{$\{$}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{Lam}\texttt{\mbox{\hspace{0.50em}}}\texttt{s}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\makebox[1.22ex][c]{\textgreater{}}\makebox[1.22ex][c]{\textgreater{}}{\char `\=}}\texttt{\mbox{\hspace{0.50em}}}\texttt{$ \theta $}\texttt{\mbox{\hspace{0.50em}}}\texttt{{\char `\=}}\texttt{\mbox{\hspace{0.50em}}}\texttt{Lam}\texttt{\mbox{\hspace{0.50em}}}\texttt{\makebox[1.22ex][l]{$ {(} $}}\texttt{s}\texttt{\mbox{\hspace{0.50em}}}\texttt{\makebox[1.22ex][c]{\textgreater{}}\makebox[1.22ex][c]{\textgreater{}}\makebox[1.22ex][c]{\textgreater{}}{\char `\=}}\texttt{\mbox{\hspace{0.50em}}}\texttt{$ \theta $}\texttt{\makebox[1.22ex][r]{$ {)} $}}\texttt{{\nopagebreak \newline%
}\vphantom{$\{$}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{App}\texttt{\mbox{\hspace{0.50em}}}\texttt{t}\texttt{\mbox{\hspace{0.50em}}}\texttt{u}\texttt{\mbox{\hspace{0.50em}}}\texttt{\makebox[1.22ex][c]{\textgreater{}}\makebox[1.22ex][c]{\textgreater{}}{\char `\=}}\texttt{\mbox{\hspace{0.50em}}}\texttt{$ \theta $}\texttt{\mbox{\hspace{0.50em}}}\texttt{{\char `\=}}\texttt{\mbox{\hspace{0.50em}}}\texttt{App}\texttt{\mbox{\hspace{0.50em}}}\texttt{\makebox[1.22ex][l]{$ {(} $}}\texttt{t}\texttt{\mbox{\hspace{0.50em}}}\texttt{\makebox[1.22ex][c]{\textgreater{}}\makebox[1.22ex][c]{\textgreater{}}{\char `\=}}\texttt{\mbox{\hspace{0.50em}}}\texttt{$ \theta $}\texttt{\makebox[1.22ex][r]{$ {)} $}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\makebox[1.22ex][l]{$ {(} $}}\texttt{u}\texttt{\mbox{\hspace{0.50em}}}\texttt{\makebox[1.22ex][c]{\textgreater{}}\makebox[1.22ex][c]{\textgreater{}}{\char `\=}}\texttt{\mbox{\hspace{0.50em}}}\texttt{$ \theta $}\texttt{\makebox[1.22ex][r]{$ {)} $}}\texttt{{\nopagebreak \newline%
}\vphantom{$\{$}}%


%
%paragraphName:
At binding sites, one needs to lift the substitution so that it does not
    act on the newly bound variables, a behavior isolated in the helper \texttt{\makebox[1.22ex][c]{\textgreater{}}\makebox[1.22ex][c]{\textgreater{}}\makebox[1.22ex][c]{\textgreater{}}{\char `\=}}. As for the{~}\texttt{Functor} instance,
    the type system guarantees that no mistake is made. Perhaps
    noteworthy is that this operation is independent of the concrete
    term structure{:} we only {``}rename{''} with{~}\texttt{fmap} and inject variables
    with{~}\texttt{return}.%


{\nopagebreak }

%
%code:
%
%comment: liftSubst :: (Functor tm, Monad tm) ⇒
%          v → (a → tm b) → (a :▹ v) → tm (b :▹ v)
%liftSubst _ θ (Old x) = fmap Old (θ x)
%liftSubst _ θ (New x) = return (New x)
%
~\\~\vphantom{$\{$}\texttt{liftSubst}\texttt{\mbox{\hspace{0.50em}}}\texttt{{:}{:}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\makebox[1.22ex][l]{$ {(} $}}\texttt{Functor}\texttt{\mbox{\hspace{0.50em}}}\texttt{tm,}\texttt{\mbox{\hspace{0.50em}}}\texttt{Monad}\texttt{\mbox{\hspace{0.50em}}}\texttt{tm}\texttt{\makebox[1.22ex][r]{$ {)} $}}\texttt{\mbox{\hspace{0.50em}}}\texttt{$ \Rightarrow $}\texttt{{\nopagebreak \newline%
}\vphantom{$\{$}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{v}\texttt{\mbox{\hspace{0.50em}}}\texttt{$ \rightarrow $}\texttt{\mbox{\hspace{0.50em}}}\texttt{\makebox[1.22ex][l]{$ {(} $}}\texttt{a}\texttt{\mbox{\hspace{0.50em}}}\texttt{$ \rightarrow $}\texttt{\mbox{\hspace{0.50em}}}\texttt{tm}\texttt{\mbox{\hspace{0.50em}}}\texttt{b}\texttt{\makebox[1.22ex][r]{$ {)} $}}\texttt{\mbox{\hspace{0.50em}}}\texttt{$ \rightarrow $}\texttt{\mbox{\hspace{0.50em}}}\texttt{\makebox[1.22ex][l]{$ {(} $}}\texttt{a}\texttt{\mbox{\hspace{0.50em}}}\texttt{$ \vartriangleright $}\texttt{\mbox{\hspace{0.50em}}}\texttt{v}\texttt{\makebox[1.22ex][r]{$ {)} $}}\texttt{\mbox{\hspace{0.50em}}}\texttt{$ \rightarrow $}\texttt{\mbox{\hspace{0.50em}}}\texttt{tm}\texttt{\mbox{\hspace{0.50em}}}\texttt{\makebox[1.22ex][l]{$ {(} $}}\texttt{b}\texttt{\mbox{\hspace{0.50em}}}\texttt{$ \vartriangleright $}\texttt{\mbox{\hspace{0.50em}}}\texttt{v}\texttt{\makebox[1.22ex][r]{$ {)} $}}\texttt{{\nopagebreak \newline%
}\vphantom{$\{$}}\texttt{liftSubst}\texttt{\mbox{\hspace{0.50em}}}\texttt{\makebox[1.22ex][c]{\_{}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{$ \theta $}\texttt{\mbox{\hspace{0.50em}}}\texttt{\makebox[1.22ex][l]{$ {(} $}}\texttt{Old}\texttt{\mbox{\hspace{0.50em}}}\texttt{x}\texttt{\makebox[1.22ex][r]{$ {)} $}}\texttt{\mbox{\hspace{0.50em}}}\texttt{{\char `\=}}\texttt{\mbox{\hspace{0.50em}}}\texttt{fmap}\texttt{\mbox{\hspace{0.50em}}}\texttt{Old}\texttt{\mbox{\hspace{0.50em}}}\texttt{\makebox[1.22ex][l]{$ {(} $}}\texttt{$ \theta $}\texttt{\mbox{\hspace{0.50em}}}\texttt{x}\texttt{\makebox[1.22ex][r]{$ {)} $}}\texttt{{\nopagebreak \newline%
}\vphantom{$\{$}}\texttt{liftSubst}\texttt{\mbox{\hspace{0.50em}}}\texttt{\makebox[1.22ex][c]{\_{}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{$ \theta $}\texttt{\mbox{\hspace{0.50em}}}\texttt{\makebox[1.22ex][l]{$ {(} $}}\texttt{New}\texttt{\mbox{\hspace{0.50em}}}\texttt{x}\texttt{\makebox[1.22ex][r]{$ {)} $}}\texttt{\mbox{\hspace{0.50em}}}\texttt{{\char `\=}}\texttt{\mbox{\hspace{0.50em}}}\texttt{return}\texttt{\mbox{\hspace{0.50em}}}\texttt{\makebox[1.22ex][l]{$ {(} $}}\texttt{New}\texttt{\mbox{\hspace{0.50em}}}\texttt{x}\texttt{\makebox[1.22ex][r]{$ {)} $}}\texttt{{\nopagebreak \newline%
}\vphantom{$\{$}}%


%
%paragraphName:
Substitution under a binder{~}\texttt{\makebox[1.22ex][l]{$ {(} $}}\texttt{\makebox[1.22ex][c]{\textgreater{}}\makebox[1.22ex][c]{\textgreater{}}\makebox[1.22ex][c]{\textgreater{}}{\char `\=}}\texttt{\makebox[1.22ex][r]{$ {)} $}} is then the wrapping
    of{~}\texttt{liftSubst} between{~}\texttt{unpack} and{~}\texttt{pack}. It is uniform as
    well, and thus can be reused for every structure with binders.%


{\nopagebreak }

%
%code:
%
%comment: (>>>=) :: (Functor tm, Monad tm) ⇒
%          tm (Succ a) → (a → tm b) → tm (Succ b)
%s >>>= θ = unpack s $ \ x t →
%             pack x (t >>= liftSubst x θ)
%
~\\~\vphantom{$\{$}\texttt{\makebox[1.22ex][l]{$ {(} $}}\texttt{\makebox[1.22ex][c]{\textgreater{}}\makebox[1.22ex][c]{\textgreater{}}\makebox[1.22ex][c]{\textgreater{}}{\char `\=}}\texttt{\makebox[1.22ex][r]{$ {)} $}}\texttt{\mbox{\hspace{0.50em}}}\texttt{{:}{:}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\makebox[1.22ex][l]{$ {(} $}}\texttt{Functor}\texttt{\mbox{\hspace{0.50em}}}\texttt{tm,}\texttt{\mbox{\hspace{0.50em}}}\texttt{Monad}\texttt{\mbox{\hspace{0.50em}}}\texttt{tm}\texttt{\makebox[1.22ex][r]{$ {)} $}}\texttt{\mbox{\hspace{0.50em}}}\texttt{$ \Rightarrow $}\texttt{{\nopagebreak \newline%
}\vphantom{$\{$}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{tm}\texttt{\mbox{\hspace{0.50em}}}\texttt{\makebox[1.22ex][l]{$ {(} $}}\texttt{Succ}\texttt{\mbox{\hspace{0.50em}}}\texttt{a}\texttt{\makebox[1.22ex][r]{$ {)} $}}\texttt{\mbox{\hspace{0.50em}}}\texttt{$ \rightarrow $}\texttt{\mbox{\hspace{0.50em}}}\texttt{\makebox[1.22ex][l]{$ {(} $}}\texttt{a}\texttt{\mbox{\hspace{0.50em}}}\texttt{$ \rightarrow $}\texttt{\mbox{\hspace{0.50em}}}\texttt{tm}\texttt{\mbox{\hspace{0.50em}}}\texttt{b}\texttt{\makebox[1.22ex][r]{$ {)} $}}\texttt{\mbox{\hspace{0.50em}}}\texttt{$ \rightarrow $}\texttt{\mbox{\hspace{0.50em}}}\texttt{tm}\texttt{\mbox{\hspace{0.50em}}}\texttt{\makebox[1.22ex][l]{$ {(} $}}\texttt{Succ}\texttt{\mbox{\hspace{0.50em}}}\texttt{b}\texttt{\makebox[1.22ex][r]{$ {)} $}}\texttt{{\nopagebreak \newline%
}\vphantom{$\{$}}\texttt{s}\texttt{\mbox{\hspace{0.50em}}}\texttt{\makebox[1.22ex][c]{\textgreater{}}\makebox[1.22ex][c]{\textgreater{}}\makebox[1.22ex][c]{\textgreater{}}{\char `\=}}\texttt{\mbox{\hspace{0.50em}}}\texttt{$ \theta $}\texttt{\mbox{\hspace{0.50em}}}\texttt{{\char `\=}}\texttt{\mbox{\hspace{0.50em}}}\texttt{unpack}\texttt{\mbox{\hspace{0.50em}}}\texttt{s}\texttt{\mbox{\hspace{0.50em}}}\texttt{\${}}\texttt{\mbox{\hspace{0.50em}}}\texttt{$ \lambda $}\texttt{\mbox{\hspace{0.50em}}}\texttt{x}\texttt{\mbox{\hspace{0.50em}}}\texttt{t}\texttt{\mbox{\hspace{0.50em}}}\texttt{$ \rightarrow $}\texttt{{\nopagebreak \newline%
}\vphantom{$\{$}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{pack}\texttt{\mbox{\hspace{0.50em}}}\texttt{x}\texttt{\mbox{\hspace{0.50em}}}\texttt{\makebox[1.22ex][l]{$ {(} $}}\texttt{t}\texttt{\mbox{\hspace{0.50em}}}\texttt{\makebox[1.22ex][c]{\textgreater{}}\makebox[1.22ex][c]{\textgreater{}}{\char `\=}}\texttt{\mbox{\hspace{0.50em}}}\texttt{liftSubst}\texttt{\mbox{\hspace{0.50em}}}\texttt{x}\texttt{\mbox{\hspace{0.50em}}}\texttt{$ \theta $}\texttt{\makebox[1.22ex][r]{$ {)} $}}\texttt{{\nopagebreak \newline%
}\vphantom{$\{$}}%


%
%paragraphName: laws
For terms, the meaning of the monad laws can be interpreted as follows.
    The associativity law ensures that applying a composition of
    substitutions is equivalent to sequentially applying them, while the
    identity laws ensure that variables act indeed as such.%


%
%paragraphName:
We can write useful functions for terms based only on the \texttt{Monad} structure. 
    For example, given the membership (\texttt{\makebox[1.22ex][c]{$ \in $}}), one can provide the a
    generic combinator to reference to a variable within any term structure{:}%


{\nopagebreak }

%
%code:
%
%comment: var :: (Monad tm, v :∈ a) ⇒ v → tm a
%var = return . inj
%
~\\~\vphantom{$\{$}\texttt{var}\texttt{\mbox{\hspace{0.50em}}}\texttt{{:}{:}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\makebox[1.22ex][l]{$ {(} $}}\texttt{Monad}\texttt{\mbox{\hspace{0.50em}}}\texttt{tm,}\texttt{\mbox{\hspace{0.50em}}}\texttt{v}\texttt{\mbox{\hspace{0.50em}}}\texttt{\makebox[1.22ex][c]{$ \in $}}\texttt{\mbox{\hspace{0.50em}}}\texttt{a}\texttt{\makebox[1.22ex][r]{$ {)} $}}\texttt{\mbox{\hspace{0.50em}}}\texttt{$ \Rightarrow $}\texttt{\mbox{\hspace{0.50em}}}\texttt{v}\texttt{\mbox{\hspace{0.50em}}}\texttt{$ \rightarrow $}\texttt{\mbox{\hspace{0.50em}}}\texttt{tm}\texttt{\mbox{\hspace{0.50em}}}\texttt{a}\texttt{{\nopagebreak \newline%
}\vphantom{$\{$}}\texttt{var}\texttt{\mbox{\hspace{0.50em}}}\texttt{{\char `\=}}\texttt{\mbox{\hspace{0.50em}}}\texttt{return}\texttt{\mbox{\hspace{0.50em}}}\texttt{.}\texttt{\mbox{\hspace{0.50em}}}\texttt{inj}\texttt{{\nopagebreak \newline%
}\vphantom{$\{$}}%


%
%paragraphName:
One can also substitute an arbitrary variable{:}%


{\nopagebreak }

%
%code:
%
%comment: substitute :: (Monad tm, Eq a, v :∈ a) ⇒
%              v → tm a → tm a → tm a
%substitute x t u = u >>= \ y →
%     if y `isOccurenceOf` x then t else return y
%
~\\~\vphantom{$\{$}\texttt{substitute}\texttt{\mbox{\hspace{0.50em}}}\texttt{{:}{:}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\makebox[1.22ex][l]{$ {(} $}}\texttt{Monad}\texttt{\mbox{\hspace{0.50em}}}\texttt{tm,}\texttt{\mbox{\hspace{0.50em}}}\texttt{Eq}\texttt{\mbox{\hspace{0.50em}}}\texttt{a,}\texttt{\mbox{\hspace{0.50em}}}\texttt{v}\texttt{\mbox{\hspace{0.50em}}}\texttt{\makebox[1.22ex][c]{$ \in $}}\texttt{\mbox{\hspace{0.50em}}}\texttt{a}\texttt{\makebox[1.22ex][r]{$ {)} $}}\texttt{\mbox{\hspace{0.50em}}}\texttt{$ \Rightarrow $}\texttt{{\nopagebreak \newline%
}\vphantom{$\{$}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{v}\texttt{\mbox{\hspace{0.50em}}}\texttt{$ \rightarrow $}\texttt{\mbox{\hspace{0.50em}}}\texttt{tm}\texttt{\mbox{\hspace{0.50em}}}\texttt{a}\texttt{\mbox{\hspace{0.50em}}}\texttt{$ \rightarrow $}\texttt{\mbox{\hspace{0.50em}}}\texttt{tm}\texttt{\mbox{\hspace{0.50em}}}\texttt{a}\texttt{\mbox{\hspace{0.50em}}}\texttt{$ \rightarrow $}\texttt{\mbox{\hspace{0.50em}}}\texttt{tm}\texttt{\mbox{\hspace{0.50em}}}\texttt{a}\texttt{{\nopagebreak \newline%
}\vphantom{$\{$}}\texttt{substitute}\texttt{\mbox{\hspace{0.50em}}}\texttt{x}\texttt{\mbox{\hspace{0.50em}}}\texttt{t}\texttt{\mbox{\hspace{0.50em}}}\texttt{u}\texttt{\mbox{\hspace{0.50em}}}\texttt{{\char `\=}}\texttt{\mbox{\hspace{0.50em}}}\texttt{u}\texttt{\mbox{\hspace{0.50em}}}\texttt{\makebox[1.22ex][c]{\textgreater{}}\makebox[1.22ex][c]{\textgreater{}}{\char `\=}}\texttt{\mbox{\hspace{0.50em}}}\texttt{$ \lambda $}\texttt{\mbox{\hspace{0.50em}}}\texttt{y}\texttt{\mbox{\hspace{0.50em}}}\texttt{$ \rightarrow $}\texttt{{\nopagebreak \newline%
}\vphantom{$\{$}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{if}\texttt{\mbox{\hspace{0.50em}}}\texttt{y}\texttt{\mbox{\hspace{0.50em}}}\texttt{{`}isOccurenceOf{`}}\texttt{\mbox{\hspace{0.50em}}}\texttt{x}\texttt{\mbox{\hspace{0.50em}}}\texttt{then}\texttt{\mbox{\hspace{0.50em}}}\texttt{t}\texttt{\mbox{\hspace{0.50em}}}\texttt{else}\texttt{\mbox{\hspace{0.50em}}}\texttt{return}\texttt{\mbox{\hspace{0.50em}}}\texttt{y}\texttt{{\nopagebreak \newline%
}\vphantom{$\{$}}%


%
%paragraphName:
One might however also want to remove the substituted
    variable from the context while performing the substitution{:}%


{\nopagebreak }

%
%code:
%
%comment: substituteOut :: Monad tm ⇒
%                 v → tm a → tm (a :▹ v) → tm a
%substituteOut x t u = u >>= \ y → case y of
%     New _ → t
%     Old x → return x
%
~\\~\vphantom{$\{$}\texttt{substituteOut}\texttt{\mbox{\hspace{0.50em}}}\texttt{{:}{:}}\texttt{\mbox{\hspace{0.50em}}}\texttt{Monad}\texttt{\mbox{\hspace{0.50em}}}\texttt{tm}\texttt{\mbox{\hspace{0.50em}}}\texttt{$ \Rightarrow $}\texttt{{\nopagebreak \newline%
}\vphantom{$\{$}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{v}\texttt{\mbox{\hspace{0.50em}}}\texttt{$ \rightarrow $}\texttt{\mbox{\hspace{0.50em}}}\texttt{tm}\texttt{\mbox{\hspace{0.50em}}}\texttt{a}\texttt{\mbox{\hspace{0.50em}}}\texttt{$ \rightarrow $}\texttt{\mbox{\hspace{0.50em}}}\texttt{tm}\texttt{\mbox{\hspace{0.50em}}}\texttt{\makebox[1.22ex][l]{$ {(} $}}\texttt{a}\texttt{\mbox{\hspace{0.50em}}}\texttt{$ \vartriangleright $}\texttt{\mbox{\hspace{0.50em}}}\texttt{v}\texttt{\makebox[1.22ex][r]{$ {)} $}}\texttt{\mbox{\hspace{0.50em}}}\texttt{$ \rightarrow $}\texttt{\mbox{\hspace{0.50em}}}\texttt{tm}\texttt{\mbox{\hspace{0.50em}}}\texttt{a}\texttt{{\nopagebreak \newline%
}\vphantom{$\{$}}\texttt{substituteOut}\texttt{\mbox{\hspace{0.50em}}}\texttt{x}\texttt{\mbox{\hspace{0.50em}}}\texttt{t}\texttt{\mbox{\hspace{0.50em}}}\texttt{u}\texttt{\mbox{\hspace{0.50em}}}\texttt{{\char `\=}}\texttt{\mbox{\hspace{0.50em}}}\texttt{u}\texttt{\mbox{\hspace{0.50em}}}\texttt{\makebox[1.22ex][c]{\textgreater{}}\makebox[1.22ex][c]{\textgreater{}}{\char `\=}}\texttt{\mbox{\hspace{0.50em}}}\texttt{$ \lambda $}\texttt{\mbox{\hspace{0.50em}}}\texttt{y}\texttt{\mbox{\hspace{0.50em}}}\texttt{$ \rightarrow $}\texttt{\mbox{\hspace{0.50em}}}\texttt{case}\texttt{\mbox{\hspace{0.50em}}}\texttt{y}\texttt{\mbox{\hspace{0.50em}}}\texttt{of}\texttt{{\nopagebreak \newline%
}\vphantom{$\{$}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{New}\texttt{\mbox{\hspace{0.50em}}}\texttt{\makebox[1.22ex][c]{\_{}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{$ \rightarrow $}\texttt{\mbox{\hspace{0.50em}}}\texttt{t}\texttt{{\nopagebreak \newline%
}\vphantom{$\{$}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{Old}\texttt{\mbox{\hspace{0.50em}}}\texttt{x}\texttt{\mbox{\hspace{0.50em}}}\texttt{$ \rightarrow $}\texttt{\mbox{\hspace{0.50em}}}\texttt{return}\texttt{\mbox{\hspace{0.50em}}}\texttt{x}\texttt{{\nopagebreak \newline%
}\vphantom{$\{$}}%


\subsection{Traversable}

%
%paragraphName: explain traverse
Functors enable to apply any pure function{~}\texttt{f}\texttt{\mbox{\hspace{0.50em}}}\texttt{{:}{:}}\texttt{\mbox{\hspace{0.50em}}}\texttt{a}\texttt{\mbox{\hspace{0.50em}}}\texttt{$ \rightarrow $}\texttt{\mbox{\hspace{0.50em}}}\texttt{b} to the
    elements of a structure to get a new structure holding the images
    of{~}\texttt{f}. Traversable structures enable to apply an effectful
    function{~}\texttt{f}\texttt{\mbox{\hspace{0.50em}}}\texttt{{:}{:}}\texttt{\mbox{\hspace{0.50em}}}\texttt{a}\texttt{\mbox{\hspace{0.50em}}}\texttt{$ \rightarrow $}\texttt{\mbox{\hspace{0.50em}}}\texttt{m}\texttt{\mbox{\hspace{0.50em}}}\texttt{b} where{~}\texttt{m} can be any{~}\texttt{Applicative}    functor. An{~}\texttt{Applicative} functor is strictly more powerful
    than a{~}\texttt{Functor} and strictly less powerful than a{~}\texttt{Monad}.
    Any{~}\texttt{Monad} is an{~}\texttt{Applicative} and any{~}\texttt{Applicative}    is a{~}\texttt{Functor}. To be traversed a structure only needs
    an applicative and therefore support monadic actions
    directly{~}\cite{mcbride_applicative_2007}.%


{\nopagebreak }

%
%code:
%
%comment: instance Traversable Tm where
%  traverse f (Var x)   = Var <$> f x
%  traverse f (App t u) =
%    App <$> traverse f t <*> traverse f u
%  traverse f (Lam t)   =
%    unpack t $ \ x b →
%      lamP x <$> traverse (bitraverse f pure) b
%
~\\~\vphantom{$\{$}\texttt{instance}\texttt{\mbox{\hspace{0.50em}}}\texttt{Traversable}\texttt{\mbox{\hspace{0.50em}}}\texttt{Tm}\texttt{\mbox{\hspace{0.50em}}}\texttt{where}\texttt{{\nopagebreak \newline%
}\vphantom{$\{$}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{traverse}\texttt{\mbox{\hspace{0.50em}}}\texttt{f}\texttt{\mbox{\hspace{0.50em}}}\texttt{\makebox[1.22ex][l]{$ {(} $}}\texttt{Var}\texttt{\mbox{\hspace{0.50em}}}\texttt{x}\texttt{\makebox[1.22ex][r]{$ {)} $}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{{\char `\=}}\texttt{\mbox{\hspace{0.50em}}}\texttt{Var}\texttt{\mbox{\hspace{0.50em}}}\texttt{\makebox[1.22ex][c]{\textless{}}\${}\makebox[1.22ex][c]{\textgreater{}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{f}\texttt{\mbox{\hspace{0.50em}}}\texttt{x}\texttt{{\nopagebreak \newline%
}\vphantom{$\{$}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{traverse}\texttt{\mbox{\hspace{0.50em}}}\texttt{f}\texttt{\mbox{\hspace{0.50em}}}\texttt{\makebox[1.22ex][l]{$ {(} $}}\texttt{App}\texttt{\mbox{\hspace{0.50em}}}\texttt{t}\texttt{\mbox{\hspace{0.50em}}}\texttt{u}\texttt{\makebox[1.22ex][r]{$ {)} $}}\texttt{\mbox{\hspace{0.50em}}}\texttt{{\char `\=}}\texttt{{\nopagebreak \newline%
}\vphantom{$\{$}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{App}\texttt{\mbox{\hspace{0.50em}}}\texttt{\makebox[1.22ex][c]{\textless{}}\${}\makebox[1.22ex][c]{\textgreater{}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{traverse}\texttt{\mbox{\hspace{0.50em}}}\texttt{f}\texttt{\mbox{\hspace{0.50em}}}\texttt{t}\texttt{\mbox{\hspace{0.50em}}}\texttt{\makebox[1.22ex][c]{\textless{}}*\makebox[1.22ex][c]{\textgreater{}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{traverse}\texttt{\mbox{\hspace{0.50em}}}\texttt{f}\texttt{\mbox{\hspace{0.50em}}}\texttt{u}\texttt{{\nopagebreak \newline%
}\vphantom{$\{$}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{traverse}\texttt{\mbox{\hspace{0.50em}}}\texttt{f}\texttt{\mbox{\hspace{0.50em}}}\texttt{\makebox[1.22ex][l]{$ {(} $}}\texttt{Lam}\texttt{\mbox{\hspace{0.50em}}}\texttt{t}\texttt{\makebox[1.22ex][r]{$ {)} $}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{{\char `\=}}\texttt{{\nopagebreak \newline%
}\vphantom{$\{$}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{unpack}\texttt{\mbox{\hspace{0.50em}}}\texttt{t}\texttt{\mbox{\hspace{0.50em}}}\texttt{\${}}\texttt{\mbox{\hspace{0.50em}}}\texttt{$ \lambda $}\texttt{\mbox{\hspace{0.50em}}}\texttt{x}\texttt{\mbox{\hspace{0.50em}}}\texttt{b}\texttt{\mbox{\hspace{0.50em}}}\texttt{$ \rightarrow $}\texttt{{\nopagebreak \newline%
}\vphantom{$\{$}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{lamP}\texttt{\mbox{\hspace{0.50em}}}\texttt{x}\texttt{\mbox{\hspace{0.50em}}}\texttt{\makebox[1.22ex][c]{\textless{}}\${}\makebox[1.22ex][c]{\textgreater{}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{traverse}\texttt{\mbox{\hspace{0.50em}}}\texttt{\makebox[1.22ex][l]{$ {(} $}}\texttt{bitraverse}\texttt{\mbox{\hspace{0.50em}}}\texttt{f}\texttt{\mbox{\hspace{0.50em}}}\texttt{pure}\texttt{\makebox[1.22ex][r]{$ {)} $}}\texttt{\mbox{\hspace{0.50em}}}\texttt{b}\texttt{{\nopagebreak \newline%
}\vphantom{$\{$}}%


%
%paragraphName: explain bitraverse
In order to traverse name abstractions, indices need to be traversed
    as well. The type{~}\texttt{\makebox[1.22ex][l]{$ {(} $}}\texttt{$ \vartriangleright $}\texttt{\makebox[1.22ex][r]{$ {)} $}} is a bi-functor and is bi-traversable.
    The function{~}\texttt{bitraverse} is given two effectful functions, one for
    each case{:}%


{\nopagebreak }

%
%code:
%
%comment: bitraverse :: Functor f ⇒ (a     → f a')
%                        → (b     → f b')
%                        → (a :▹ b → f (a' :▹ b'))
%bitraverse f _ (Old x) = Old <$> f x
%bitraverse _ g (New x) = New <$> g x
%
~\\~\vphantom{$\{$}\texttt{bitraverse}\texttt{\mbox{\hspace{0.50em}}}\texttt{{:}{:}}\texttt{\mbox{\hspace{0.50em}}}\texttt{Functor}\texttt{\mbox{\hspace{0.50em}}}\texttt{f}\texttt{\mbox{\hspace{0.50em}}}\texttt{$ \Rightarrow $}\texttt{\mbox{\hspace{0.50em}}}\texttt{\makebox[1.22ex][l]{$ {(} $}}\texttt{a}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{$ \rightarrow $}\texttt{\mbox{\hspace{0.50em}}}\texttt{f}\texttt{\mbox{\hspace{0.50em}}}\texttt{a{'}}\texttt{\makebox[1.22ex][r]{$ {)} $}}\texttt{{\nopagebreak \newline%
}\vphantom{$\{$}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{$ \rightarrow $}\texttt{\mbox{\hspace{0.50em}}}\texttt{\makebox[1.22ex][l]{$ {(} $}}\texttt{b}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{$ \rightarrow $}\texttt{\mbox{\hspace{0.50em}}}\texttt{f}\texttt{\mbox{\hspace{0.50em}}}\texttt{b{'}}\texttt{\makebox[1.22ex][r]{$ {)} $}}\texttt{{\nopagebreak \newline%
}\vphantom{$\{$}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{$ \rightarrow $}\texttt{\mbox{\hspace{0.50em}}}\texttt{\makebox[1.22ex][l]{$ {(} $}}\texttt{a}\texttt{\mbox{\hspace{0.50em}}}\texttt{$ \vartriangleright $}\texttt{\mbox{\hspace{0.50em}}}\texttt{b}\texttt{\mbox{\hspace{0.50em}}}\texttt{$ \rightarrow $}\texttt{\mbox{\hspace{0.50em}}}\texttt{f}\texttt{\mbox{\hspace{0.50em}}}\texttt{\makebox[1.22ex][l]{$ {(} $}}\texttt{a{'}}\texttt{\mbox{\hspace{0.50em}}}\texttt{$ \vartriangleright $}\texttt{\mbox{\hspace{0.50em}}}\texttt{b{'}}\texttt{\makebox[1.22ex][r]{$ {)} $}}\texttt{\makebox[1.22ex][r]{$ {)} $}}\texttt{{\nopagebreak \newline%
}\vphantom{$\{$}}\texttt{bitraverse}\texttt{\mbox{\hspace{0.50em}}}\texttt{f}\texttt{\mbox{\hspace{0.50em}}}\texttt{\makebox[1.22ex][c]{\_{}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\makebox[1.22ex][l]{$ {(} $}}\texttt{Old}\texttt{\mbox{\hspace{0.50em}}}\texttt{x}\texttt{\makebox[1.22ex][r]{$ {)} $}}\texttt{\mbox{\hspace{0.50em}}}\texttt{{\char `\=}}\texttt{\mbox{\hspace{0.50em}}}\texttt{Old}\texttt{\mbox{\hspace{0.50em}}}\texttt{\makebox[1.22ex][c]{\textless{}}\${}\makebox[1.22ex][c]{\textgreater{}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{f}\texttt{\mbox{\hspace{0.50em}}}\texttt{x}\texttt{{\nopagebreak \newline%
}\vphantom{$\{$}}\texttt{bitraverse}\texttt{\mbox{\hspace{0.50em}}}\texttt{\makebox[1.22ex][c]{\_{}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{g}\texttt{\mbox{\hspace{0.50em}}}\texttt{\makebox[1.22ex][l]{$ {(} $}}\texttt{New}\texttt{\mbox{\hspace{0.50em}}}\texttt{x}\texttt{\makebox[1.22ex][r]{$ {)} $}}\texttt{\mbox{\hspace{0.50em}}}\texttt{{\char `\=}}\texttt{\mbox{\hspace{0.50em}}}\texttt{New}\texttt{\mbox{\hspace{0.50em}}}\texttt{\makebox[1.22ex][c]{\textless{}}\${}\makebox[1.22ex][c]{\textgreater{}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{g}\texttt{\mbox{\hspace{0.50em}}}\texttt{x}\texttt{{\nopagebreak \newline%
}\vphantom{$\{$}}%


%
%paragraphName:
An example of a useful effect to apply is throwing an exception,
    implemented for example as the \texttt{Maybe} monad. If a term has no
    free variable, then it can be converted from the type{~}\texttt{Tm}\texttt{\mbox{\hspace{0.50em}}}\texttt{a}    to{~}\texttt{Tm}\texttt{\mbox{\hspace{0.50em}}}\texttt{Zero} (or equivalently{~}\texttt{\makebox[1.22ex][c]{$ \forall $}}\texttt{\mbox{\hspace{0.50em}}}\texttt{b}\texttt{.}\texttt{\mbox{\hspace{0.50em}}}\texttt{Tm}\texttt{\mbox{\hspace{0.50em}}}\texttt{b}), but this requires a dynamic
    check. It may seem like a complicated implementation is necessary,
    but in fact it is a direct application of the{~}\texttt{traverse}    function.%


{\nopagebreak }

%
%code:
%
%comment: closed :: Traversable tm ⇒ tm a → Maybe (tm b)
%closed = traverse (const Nothing)
%
~\\~\vphantom{$\{$}\texttt{closed}\texttt{\mbox{\hspace{0.50em}}}\texttt{{:}{:}}\texttt{\mbox{\hspace{0.50em}}}\texttt{Traversable}\texttt{\mbox{\hspace{0.50em}}}\texttt{tm}\texttt{\mbox{\hspace{0.50em}}}\texttt{$ \Rightarrow $}\texttt{\mbox{\hspace{0.50em}}}\texttt{tm}\texttt{\mbox{\hspace{0.50em}}}\texttt{a}\texttt{\mbox{\hspace{0.50em}}}\texttt{$ \rightarrow $}\texttt{\mbox{\hspace{0.50em}}}\texttt{Maybe}\texttt{\mbox{\hspace{0.50em}}}\texttt{\makebox[1.22ex][l]{$ {(} $}}\texttt{tm}\texttt{\mbox{\hspace{0.50em}}}\texttt{b}\texttt{\makebox[1.22ex][r]{$ {)} $}}\texttt{{\nopagebreak \newline%
}\vphantom{$\{$}}\texttt{closed}\texttt{\mbox{\hspace{0.50em}}}\texttt{{\char `\=}}\texttt{\mbox{\hspace{0.50em}}}\texttt{traverse}\texttt{\mbox{\hspace{0.50em}}}\texttt{\makebox[1.22ex][l]{$ {(} $}}\texttt{const}\texttt{\mbox{\hspace{0.50em}}}\texttt{Nothing}\texttt{\makebox[1.22ex][r]{$ {)} $}}\texttt{{\nopagebreak \newline%
}\vphantom{$\{$}}%


%
%paragraphName: freeVars is toList
Thanks to terms being an instance of{~}\texttt{Traversable} they are
    also{~}\texttt{Foldable} meaning that we can combine all the elements of
    the structure (i.e. the occurrences of free variables in the term)
    using any{~}\texttt{Monoid}. One particular monoid is the free monoid of
    lists. Consequently, \texttt{Data.Foldable.toList} is computing the
    free variables of a term and{~}\texttt{Data.Foldable.elem} can be used to
    build{~}\texttt{freshFor}{:}%


{\nopagebreak }

%
%code:
%
%comment: freeVars :: Tm a → [a]
%freeVars = toList
%
%freshFor :: (Eq a, v :∈ a) ⇒ v → Tm a → Bool
%x `freshFor` t = not (inj x `elem` t)
%
~\\~\vphantom{$\{$}\texttt{freeVars}\texttt{\mbox{\hspace{0.50em}}}\texttt{{:}{:}}\texttt{\mbox{\hspace{0.50em}}}\texttt{Tm}\texttt{\mbox{\hspace{0.50em}}}\texttt{a}\texttt{\mbox{\hspace{0.50em}}}\texttt{$ \rightarrow $}\texttt{\mbox{\hspace{0.50em}}}\texttt{{[}}\texttt{a}\texttt{{]}}\texttt{{\nopagebreak \newline%
}\vphantom{$\{$}}\texttt{freeVars}\texttt{\mbox{\hspace{0.50em}}}\texttt{{\char `\=}}\texttt{\mbox{\hspace{0.50em}}}\texttt{toList}\texttt{{\nopagebreak \newline%
}\vphantom{$\{$}}\texttt{{\nopagebreak \newline%
}\vphantom{$\{$}}\texttt{freshFor}\texttt{\mbox{\hspace{0.50em}}}\texttt{{:}{:}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\makebox[1.22ex][l]{$ {(} $}}\texttt{Eq}\texttt{\mbox{\hspace{0.50em}}}\texttt{a,}\texttt{\mbox{\hspace{0.50em}}}\texttt{v}\texttt{\mbox{\hspace{0.50em}}}\texttt{\makebox[1.22ex][c]{$ \in $}}\texttt{\mbox{\hspace{0.50em}}}\texttt{a}\texttt{\makebox[1.22ex][r]{$ {)} $}}\texttt{\mbox{\hspace{0.50em}}}\texttt{$ \Rightarrow $}\texttt{\mbox{\hspace{0.50em}}}\texttt{v}\texttt{\mbox{\hspace{0.50em}}}\texttt{$ \rightarrow $}\texttt{\mbox{\hspace{0.50em}}}\texttt{Tm}\texttt{\mbox{\hspace{0.50em}}}\texttt{a}\texttt{\mbox{\hspace{0.50em}}}\texttt{$ \rightarrow $}\texttt{\mbox{\hspace{0.50em}}}\texttt{Bool}\texttt{{\nopagebreak \newline%
}\vphantom{$\{$}}\texttt{x}\texttt{\mbox{\hspace{0.50em}}}\texttt{{`}freshFor{`}}\texttt{\mbox{\hspace{0.50em}}}\texttt{t}\texttt{\mbox{\hspace{0.50em}}}\texttt{{\char `\=}}\texttt{\mbox{\hspace{0.50em}}}\texttt{not}\texttt{\mbox{\hspace{0.50em}}}\texttt{\makebox[1.22ex][l]{$ {(} $}}\texttt{inj}\texttt{\mbox{\hspace{0.50em}}}\texttt{x}\texttt{\mbox{\hspace{0.50em}}}\texttt{{`}elem{`}}\texttt{\mbox{\hspace{0.50em}}}\texttt{t}\texttt{\makebox[1.22ex][r]{$ {)} $}}\texttt{{\nopagebreak \newline%
}\vphantom{$\{$}}%


\section{Scopes\label{scopesSec}}

%
%paragraphName: flow
Armed with an intuitive understanding of safe interfaces to
    manipulate de{~}Bruijn indices, and the knowledge that one can
    abstract over any substitutive structure by using standard
    type-classes, we can recapitulate and succinctly describe the
    essence of our constructions.%


%
%paragraphName:
In Nested Abstract Syntax, a binder introducing one variable in
    scope, for an arbitrary term structure \texttt{tm} is represented as
    follows{:}%


{\nopagebreak }

%
%code:
%
%comment: type SuccScope tm a = tm (Succ a)
%
~\\~\vphantom{$\{$}\texttt{type}\texttt{\mbox{\hspace{0.50em}}}\texttt{SuccScope}\texttt{\mbox{\hspace{0.50em}}}\texttt{tm}\texttt{\mbox{\hspace{0.50em}}}\texttt{a}\texttt{\mbox{\hspace{0.50em}}}\texttt{{\char `\=}}\texttt{\mbox{\hspace{0.50em}}}\texttt{tm}\texttt{\mbox{\hspace{0.50em}}}\texttt{\makebox[1.22ex][l]{$ {(} $}}\texttt{Succ}\texttt{\mbox{\hspace{0.50em}}}\texttt{a}\texttt{\makebox[1.22ex][r]{$ {)} $}}\texttt{{\nopagebreak \newline%
}\vphantom{$\{$}}%


%
%paragraphName:
In essence, we propose two new, dual representations of binders,
    one based on universal quantification, the other one based on
    existential quantification.%


%
%comment: {- --
%


{\nopagebreak }

%
%code:
%
%comment: type UnivScope  tm a = ∀ v.  v → tm (a :▹ v)
%type ExistScope tm a = ∃ v. (v ,  tm (a :▹ v))
%
~\\~\vphantom{$\{$}\texttt{type}\texttt{\mbox{\hspace{0.50em}}}\texttt{UnivScope}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{tm}\texttt{\mbox{\hspace{0.50em}}}\texttt{a}\texttt{\mbox{\hspace{0.50em}}}\texttt{{\char `\=}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\makebox[1.22ex][c]{$ \forall $}}\texttt{\mbox{\hspace{0.50em}}}\texttt{v}\texttt{.}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{v}\texttt{\mbox{\hspace{0.50em}}}\texttt{$ \rightarrow $}\texttt{\mbox{\hspace{0.50em}}}\texttt{tm}\texttt{\mbox{\hspace{0.50em}}}\texttt{\makebox[1.22ex][l]{$ {(} $}}\texttt{a}\texttt{\mbox{\hspace{0.50em}}}\texttt{$ \vartriangleright $}\texttt{\mbox{\hspace{0.50em}}}\texttt{v}\texttt{\makebox[1.22ex][r]{$ {)} $}}\texttt{{\nopagebreak \newline%
}\vphantom{$\{$}}\texttt{type}\texttt{\mbox{\hspace{0.50em}}}\texttt{ExistScope}\texttt{\mbox{\hspace{0.50em}}}\texttt{tm}\texttt{\mbox{\hspace{0.50em}}}\texttt{a}\texttt{\mbox{\hspace{0.50em}}}\texttt{{\char `\=}}\texttt{\mbox{\hspace{0.50em}}}\texttt{$ \exists $}\texttt{\mbox{\hspace{0.50em}}}\texttt{v}\texttt{.}\texttt{\mbox{\hspace{0.50em}}}\texttt{\makebox[1.22ex][l]{$ {(} $}}\texttt{v}\texttt{\mbox{\hspace{0.50em}}}\texttt{,}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{tm}\texttt{\mbox{\hspace{0.50em}}}\texttt{\makebox[1.22ex][l]{$ {(} $}}\texttt{a}\texttt{\mbox{\hspace{0.50em}}}\texttt{$ \vartriangleright $}\texttt{\mbox{\hspace{0.50em}}}\texttt{v}\texttt{\makebox[1.22ex][r]{$ {)} $}}\texttt{\makebox[1.22ex][r]{$ {)} $}}\texttt{{\nopagebreak \newline%
}\vphantom{$\{$}}%


%
%comment: -- -}
%


%
%paragraphName:
The above syntax for existentials is not supported in \textsc{Haskell},
    so we must use one of the lightweight encodings available. In
    the absence of view patterns, a CPS encoding is convenient for
    programming (so we used this so far), but a datatype representation
    is more convenient when dealing with scopes only{:}%


{\nopagebreak }

%
%code:
%
%comment: data ExistScope tm a where
%  E :: v → tm (a :▹ v) → ExistScope tm a
%
~\\~\vphantom{$\{$}\texttt{data}\texttt{\mbox{\hspace{0.50em}}}\texttt{ExistScope}\texttt{\mbox{\hspace{0.50em}}}\texttt{tm}\texttt{\mbox{\hspace{0.50em}}}\texttt{a}\texttt{\mbox{\hspace{0.50em}}}\texttt{where}\texttt{{\nopagebreak \newline%
}\vphantom{$\{$}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{E}\texttt{\mbox{\hspace{0.50em}}}\texttt{{:}{:}}\texttt{\mbox{\hspace{0.50em}}}\texttt{v}\texttt{\mbox{\hspace{0.50em}}}\texttt{$ \rightarrow $}\texttt{\mbox{\hspace{0.50em}}}\texttt{tm}\texttt{\mbox{\hspace{0.50em}}}\texttt{\makebox[1.22ex][l]{$ {(} $}}\texttt{a}\texttt{\mbox{\hspace{0.50em}}}\texttt{$ \vartriangleright $}\texttt{\mbox{\hspace{0.50em}}}\texttt{v}\texttt{\makebox[1.22ex][r]{$ {)} $}}\texttt{\mbox{\hspace{0.50em}}}\texttt{$ \rightarrow $}\texttt{\mbox{\hspace{0.50em}}}\texttt{ExistScope}\texttt{\mbox{\hspace{0.50em}}}\texttt{tm}\texttt{\mbox{\hspace{0.50em}}}\texttt{a}\texttt{{\nopagebreak \newline%
}\vphantom{$\{$}}%


%
%paragraphName:
As we have observed on a number of examples, these representations
    are dual from a usage perspective{:} the universal-based
    representation allows safe construction of terms, while the
    existential-based representation allows safe analysis of
    terms. Strictly speaking, safety holds only if one disregards
    non-termination and \texttt{seq}, but because the values of type \texttt{v}    are never used for computation, mistakenly using a diverging term in
    place of a witness of variable name is far-fetched.%


%
%paragraphName:
For the above reason, we do not commit to either side, and use the
    suitable representation on a case-by-case basis. This flexibility
    is possible because these scope representations (\texttt{SuccScope},
    \texttt{UnivScope} and \texttt{ExistScope}) are isomorphic. In the following
    we exhibit the conversion functions between \texttt{SuccScope} one side
    and either \texttt{UnivScope} or \texttt{ExistScope} on the other. We then
    prove that they form isomorphisms, assuming an idealized \textsc{Haskell}    lacking non-termination and \texttt{seq}.%


\subsection{\texttt{UnivScope}\texttt{\mbox{\hspace{0.50em}}}\texttt{tm}\texttt{\mbox{\hspace{0.50em}}}\texttt{a}\texttt{\mbox{\hspace{0.50em}}}\texttt{\ensuremath{\cong}}\texttt{\mbox{\hspace{0.50em}}}\texttt{SuccScope}\texttt{\mbox{\hspace{0.50em}}}\texttt{tm}\texttt{\mbox{\hspace{0.50em}}}\texttt{a}}

%
%paragraphName: conversions
The conversion functions witnessing the isomorphism are the
    following.%


\newpage

%
%code:
{\noindent}%
%comment: succToUniv :: Functor tm ⇒
%              SuccScope tm a → UnivScope tm a
%succToUniv t = \ x → mapNew (const x) <$> t
%
\vphantom{$\{$}\texttt{succToUniv}\texttt{\mbox{\hspace{0.50em}}}\texttt{{:}{:}}\texttt{\mbox{\hspace{0.50em}}}\texttt{Functor}\texttt{\mbox{\hspace{0.50em}}}\texttt{tm}\texttt{\mbox{\hspace{0.50em}}}\texttt{$ \Rightarrow $}\texttt{{\nopagebreak \newline%
}\vphantom{$\{$}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{SuccScope}\texttt{\mbox{\hspace{0.50em}}}\texttt{tm}\texttt{\mbox{\hspace{0.50em}}}\texttt{a}\texttt{\mbox{\hspace{0.50em}}}\texttt{$ \rightarrow $}\texttt{\mbox{\hspace{0.50em}}}\texttt{UnivScope}\texttt{\mbox{\hspace{0.50em}}}\texttt{tm}\texttt{\mbox{\hspace{0.50em}}}\texttt{a}\texttt{{\nopagebreak \newline%
}\vphantom{$\{$}}\texttt{succToUniv}\texttt{\mbox{\hspace{0.50em}}}\texttt{t}\texttt{\mbox{\hspace{0.50em}}}\texttt{{\char `\=}}\texttt{\mbox{\hspace{0.50em}}}\texttt{$ \lambda $}\texttt{\mbox{\hspace{0.50em}}}\texttt{x}\texttt{\mbox{\hspace{0.50em}}}\texttt{$ \rightarrow $}\texttt{\mbox{\hspace{0.50em}}}\texttt{mapNew}\texttt{\mbox{\hspace{0.50em}}}\texttt{\makebox[1.22ex][l]{$ {(} $}}\texttt{const}\texttt{\mbox{\hspace{0.50em}}}\texttt{x}\texttt{\makebox[1.22ex][r]{$ {)} $}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\makebox[1.22ex][c]{\textless{}}\${}\makebox[1.22ex][c]{\textgreater{}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{t}\texttt{{\nopagebreak \newline%
}\vphantom{$\{$}}%


%
%code:
{\noindent}%
%comment: univToSucc :: UnivScope tm a → SuccScope tm a
%univToSucc f = f ()
%
\vphantom{$\{$}\texttt{univToSucc}\texttt{\mbox{\hspace{0.50em}}}\texttt{{:}{:}}\texttt{\mbox{\hspace{0.50em}}}\texttt{UnivScope}\texttt{\mbox{\hspace{0.50em}}}\texttt{tm}\texttt{\mbox{\hspace{0.50em}}}\texttt{a}\texttt{\mbox{\hspace{0.50em}}}\texttt{$ \rightarrow $}\texttt{\mbox{\hspace{0.50em}}}\texttt{SuccScope}\texttt{\mbox{\hspace{0.50em}}}\texttt{tm}\texttt{\mbox{\hspace{0.50em}}}\texttt{a}\texttt{{\nopagebreak \newline%
}\vphantom{$\{$}}\texttt{univToSucc}\texttt{\mbox{\hspace{0.50em}}}\texttt{f}\texttt{\mbox{\hspace{0.50em}}}\texttt{{\char `\=}}\texttt{\mbox{\hspace{0.50em}}}\texttt{f}\texttt{\mbox{\hspace{0.50em}}}\texttt{\makebox[1.22ex][l]{$ {(} $}}\texttt{\makebox[1.22ex][r]{$ {)} $}}\texttt{{\nopagebreak \newline%
}\vphantom{$\{$}}%


%
%paragraphName:
The{~}\texttt{univToSucc} function has not been given a name in the
    previous sections, but was implicitly used in the definition
    of{~}\texttt{lam}. This is the first occurrence of the{~}\texttt{succToUniv}    function.%


%
%paragraphName:
We prove first that{~}\texttt{UnivScope} is a proper representation
    of{~}\texttt{SuccScope}, that is{~}\texttt{univToSucc}\texttt{\mbox{\hspace{0.50em}}}\texttt{.}\texttt{\mbox{\hspace{0.50em}}}\texttt{succToUniv}\texttt{\mbox{\hspace{0.50em}}}\texttt{$ \equiv $}\texttt{\mbox{\hspace{0.50em}}}\texttt{id}. This can
    be done by simple equational reasoning{:}%


%
%comment: {- --
%


{\nopagebreak }

%
%code:
%
%comment:    univToSucc (succToUniv t)
% ≡ {- by def -}
%   univToSucc (\ x → mapNew (const x) <$> t)
% ≡ {- by def -}
%   mapNew (const ()) <$> t
% ≡ {- by () having just one element -}
%   mapNew id <$> t
% ≡ {- by (bi)functor laws -}
%   t
%
~\\~\vphantom{$\{$}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{univToSucc}\texttt{\mbox{\hspace{0.50em}}}\texttt{\makebox[1.22ex][l]{$ {(} $}}\texttt{succToUniv}\texttt{\mbox{\hspace{0.50em}}}\texttt{t}\texttt{\makebox[1.22ex][r]{$ {)} $}}\texttt{{\nopagebreak \newline%
}\vphantom{$\{$}}\texttt{\mbox{\hspace{0.50em}}}\texttt{$ \equiv $}\texttt{\mbox{\hspace{0.50em}}}\texttt{\makebox[1.22ex][l]{\{{}}\makebox[1.22ex][c]{-}\mbox{\hspace{0.50em}}by\mbox{\hspace{0.50em}}def\mbox{\hspace{0.50em}}\makebox[1.22ex][c]{-}\makebox[1.22ex][r]{\}{}}}\texttt{{\nopagebreak \newline%
}\vphantom{$\{$}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{univToSucc}\texttt{\mbox{\hspace{0.50em}}}\texttt{\makebox[1.22ex][l]{$ {(} $}}\texttt{$ \lambda $}\texttt{\mbox{\hspace{0.50em}}}\texttt{x}\texttt{\mbox{\hspace{0.50em}}}\texttt{$ \rightarrow $}\texttt{\mbox{\hspace{0.50em}}}\texttt{mapNew}\texttt{\mbox{\hspace{0.50em}}}\texttt{\makebox[1.22ex][l]{$ {(} $}}\texttt{const}\texttt{\mbox{\hspace{0.50em}}}\texttt{x}\texttt{\makebox[1.22ex][r]{$ {)} $}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\makebox[1.22ex][c]{\textless{}}\${}\makebox[1.22ex][c]{\textgreater{}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{t}\texttt{\makebox[1.22ex][r]{$ {)} $}}\texttt{{\nopagebreak \newline%
}\vphantom{$\{$}}\texttt{\mbox{\hspace{0.50em}}}\texttt{$ \equiv $}\texttt{\mbox{\hspace{0.50em}}}\texttt{\makebox[1.22ex][l]{\{{}}\makebox[1.22ex][c]{-}\mbox{\hspace{0.50em}}by\mbox{\hspace{0.50em}}def\mbox{\hspace{0.50em}}\makebox[1.22ex][c]{-}\makebox[1.22ex][r]{\}{}}}\texttt{{\nopagebreak \newline%
}\vphantom{$\{$}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{mapNew}\texttt{\mbox{\hspace{0.50em}}}\texttt{\makebox[1.22ex][l]{$ {(} $}}\texttt{const}\texttt{\mbox{\hspace{0.50em}}}\texttt{\makebox[1.22ex][l]{$ {(} $}}\texttt{\makebox[1.22ex][r]{$ {)} $}}\texttt{\makebox[1.22ex][r]{$ {)} $}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\makebox[1.22ex][c]{\textless{}}\${}\makebox[1.22ex][c]{\textgreater{}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{t}\texttt{{\nopagebreak \newline%
}\vphantom{$\{$}}\texttt{\mbox{\hspace{0.50em}}}\texttt{$ \equiv $}\texttt{\mbox{\hspace{0.50em}}}\texttt{\makebox[1.22ex][l]{\{{}}\makebox[1.22ex][c]{-}\mbox{\hspace{0.50em}}by\mbox{\hspace{0.50em}}\makebox[1.22ex][l]{$ {(} $}\makebox[1.22ex][r]{$ {)} $}\mbox{\hspace{0.50em}}having\mbox{\hspace{0.50em}}just\mbox{\hspace{0.50em}}one\mbox{\hspace{0.50em}}element\mbox{\hspace{0.50em}}\makebox[1.22ex][c]{-}\makebox[1.22ex][r]{\}{}}}\texttt{{\nopagebreak \newline%
}\vphantom{$\{$}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{mapNew}\texttt{\mbox{\hspace{0.50em}}}\texttt{id}\texttt{\mbox{\hspace{0.50em}}}\texttt{\makebox[1.22ex][c]{\textless{}}\${}\makebox[1.22ex][c]{\textgreater{}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{t}\texttt{{\nopagebreak \newline%
}\vphantom{$\{$}}\texttt{\mbox{\hspace{0.50em}}}\texttt{$ \equiv $}\texttt{\mbox{\hspace{0.50em}}}\texttt{\makebox[1.22ex][l]{\{{}}\makebox[1.22ex][c]{-}\mbox{\hspace{0.50em}}by\mbox{\hspace{0.50em}}\makebox[1.22ex][l]{$ {(} $}bi\makebox[1.22ex][r]{$ {)} $}functor\mbox{\hspace{0.50em}}laws\mbox{\hspace{0.50em}}\makebox[1.22ex][c]{-}\makebox[1.22ex][r]{\}{}}}\texttt{{\nopagebreak \newline%
}\vphantom{$\{$}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{t}\texttt{{\nopagebreak \newline%
}\vphantom{$\{$}}%


%
%comment: -- -}
%


%
%paragraphName:
The second property (\texttt{succToUniv}\texttt{\mbox{\hspace{0.50em}}}\texttt{.}\texttt{\mbox{\hspace{0.50em}}}\texttt{univToSucc}\texttt{\mbox{\hspace{0.50em}}}\texttt{$ \equiv $}\texttt{\mbox{\hspace{0.50em}}}\texttt{id}) means that
    there is no {``}junk{''} in the representation{:} one cannot represent
    more terms in{~}\texttt{UnivScope} than in{~}\texttt{SuccScope}. It is more
    difficult to prove, as it relies on parametricity and in turn
    on the lack of junk (non-termination or \texttt{seq}) in the host
    language. Hence we need to use the free theorem for a value{~}\texttt{f}    of type{~}\texttt{UnivScope}\texttt{\mbox{\hspace{0.50em}}}\texttt{tm}\texttt{\mbox{\hspace{0.50em}}}\texttt{a}. Transcoding{~}\texttt{UnivScope}\texttt{\mbox{\hspace{0.50em}}}\texttt{tm}\texttt{\mbox{\hspace{0.50em}}}\texttt{a} to a
    relation by using Paterson{'}s version{~}\cite{fegaras_revisiting_1996}    of the abstraction theorem{~}\cite{reynolds-83,bernardy_proofs_2012},
    assuming additionally that{~}\texttt{tm} is a functor. We obtain the
    following lemma{:}%


%
%comment: {- --
%


{\nopagebreak }

%
%code:
%
%comment:  ∀ v₁:*.  ∀ v₂:*. ∀ v:v₁ → v₂.
% ∀ x₁:v₁. ∀ x₂:*. v x₁ ≡ x₂.
% ∀ g:(a :▹ v₁) → (a :▹ v₂).
% (∀ y:v₁. New (v y) ≡ g (New y)) →
% (∀ n:a.  Old n     ≡ g (Old n)) →
% f x₂ ≡ g <$> f x₁
%
~\\~\vphantom{$\{$}\texttt{\mbox{\hspace{0.50em}}}\texttt{\makebox[1.22ex][c]{$ \forall $}}\texttt{\mbox{\hspace{0.50em}}}\texttt{v\makebox[0.61ex][l]{$ _{{1}} $}{:}}\texttt{*.}\texttt{\mbox{\hspace{0.50em}}}\texttt{\ensuremath{\!}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\makebox[1.22ex][c]{$ \forall $}}\texttt{\mbox{\hspace{0.50em}}}\texttt{v\makebox[0.61ex][l]{$ _{{2}} $}{:}}\texttt{*.}\texttt{\mbox{\hspace{0.50em}}}\texttt{\makebox[1.22ex][c]{$ \forall $}}\texttt{\mbox{\hspace{0.50em}}}\texttt{v}\texttt{{:}}\texttt{v\makebox[0.61ex][l]{$ _{{1}} $}}\texttt{\mbox{\hspace{0.50em}}}\texttt{$ \rightarrow $}\texttt{\mbox{\hspace{0.50em}}}\texttt{v\makebox[0.61ex][l]{$ _{{2}} $}.}\texttt{{\nopagebreak \newline%
}\vphantom{$\{$}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\makebox[1.22ex][c]{$ \forall $}}\texttt{\mbox{\hspace{0.50em}}}\texttt{x\makebox[0.61ex][l]{$ _{{1}} $}{:}v\makebox[0.61ex][l]{$ _{{1}} $}.}\texttt{\mbox{\hspace{0.50em}}}\texttt{\makebox[1.22ex][c]{$ \forall $}}\texttt{\mbox{\hspace{0.50em}}}\texttt{x\makebox[0.61ex][l]{$ _{{2}} $}{:}}\texttt{*.}\texttt{\mbox{\hspace{0.50em}}}\texttt{v}\texttt{\mbox{\hspace{0.50em}}}\texttt{x\makebox[0.61ex][l]{$ _{{1}} $}}\texttt{\mbox{\hspace{0.50em}}}\texttt{$ \equiv $}\texttt{\mbox{\hspace{0.50em}}}\texttt{x\makebox[0.61ex][l]{$ _{{2}} $}.}\texttt{{\nopagebreak \newline%
}\vphantom{$\{$}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\makebox[1.22ex][c]{$ \forall $}}\texttt{\mbox{\hspace{0.50em}}}\texttt{g}\texttt{{:}}\texttt{\makebox[1.22ex][l]{$ {(} $}}\texttt{a}\texttt{\mbox{\hspace{0.50em}}}\texttt{$ \vartriangleright $}\texttt{\mbox{\hspace{0.50em}}}\texttt{v\makebox[0.61ex][l]{$ _{{1}} $}}\texttt{\makebox[1.22ex][r]{$ {)} $}}\texttt{\mbox{\hspace{0.50em}}}\texttt{$ \rightarrow $}\texttt{\mbox{\hspace{0.50em}}}\texttt{\makebox[1.22ex][l]{$ {(} $}}\texttt{a}\texttt{\mbox{\hspace{0.50em}}}\texttt{$ \vartriangleright $}\texttt{\mbox{\hspace{0.50em}}}\texttt{v\makebox[0.61ex][l]{$ _{{2}} $}}\texttt{\makebox[1.22ex][r]{$ {)} $}}\texttt{.}\texttt{{\nopagebreak \newline%
}\vphantom{$\{$}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\makebox[1.22ex][l]{$ {(} $}}\texttt{\makebox[1.22ex][c]{$ \forall $}}\texttt{\mbox{\hspace{0.50em}}}\texttt{y}\texttt{{:}}\texttt{v\makebox[0.61ex][l]{$ _{{1}} $}.}\texttt{\mbox{\hspace{0.50em}}}\texttt{New}\texttt{\mbox{\hspace{0.50em}}}\texttt{\makebox[1.22ex][l]{$ {(} $}}\texttt{v}\texttt{\mbox{\hspace{0.50em}}}\texttt{y}\texttt{\makebox[1.22ex][r]{$ {)} $}}\texttt{\mbox{\hspace{0.50em}}}\texttt{$ \equiv $}\texttt{\mbox{\hspace{0.50em}}}\texttt{g}\texttt{\mbox{\hspace{0.50em}}}\texttt{\makebox[1.22ex][l]{$ {(} $}}\texttt{New}\texttt{\mbox{\hspace{0.50em}}}\texttt{y}\texttt{\makebox[1.22ex][r]{$ {)} $}}\texttt{\makebox[1.22ex][r]{$ {)} $}}\texttt{\mbox{\hspace{0.50em}}}\texttt{$ \rightarrow $}\texttt{{\nopagebreak \newline%
}\vphantom{$\{$}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\makebox[1.22ex][l]{$ {(} $}}\texttt{\makebox[1.22ex][c]{$ \forall $}}\texttt{\mbox{\hspace{0.50em}}}\texttt{n}\texttt{{:}}\texttt{a}\texttt{.}\texttt{\mbox{\hspace{0.50em}}}\texttt{\ensuremath{\!}}\texttt{\mbox{\hspace{0.50em}}}\texttt{Old}\texttt{\mbox{\hspace{0.50em}}}\texttt{n}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{$ \equiv $}\texttt{\mbox{\hspace{0.50em}}}\texttt{g}\texttt{\mbox{\hspace{0.50em}}}\texttt{\makebox[1.22ex][l]{$ {(} $}}\texttt{Old}\texttt{\mbox{\hspace{0.50em}}}\texttt{n}\texttt{\makebox[1.22ex][r]{$ {)} $}}\texttt{\makebox[1.22ex][r]{$ {)} $}}\texttt{\mbox{\hspace{0.50em}}}\texttt{$ \rightarrow $}\texttt{{\nopagebreak \newline%
}\vphantom{$\{$}}\texttt{\mbox{\hspace{0.50em}}}\texttt{f}\texttt{\mbox{\hspace{0.50em}}}\texttt{x\makebox[0.61ex][l]{$ _{{2}} $}}\texttt{\mbox{\hspace{0.50em}}}\texttt{$ \equiv $}\texttt{\mbox{\hspace{0.50em}}}\texttt{g}\texttt{\mbox{\hspace{0.50em}}}\texttt{\makebox[1.22ex][c]{\textless{}}\${}\makebox[1.22ex][c]{\textgreater{}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{f}\texttt{\mbox{\hspace{0.50em}}}\texttt{x\makebox[0.61ex][l]{$ _{{1}} $}}\texttt{{\nopagebreak \newline%
}\vphantom{$\{$}}%


%
%comment: -- -}
%


%
%paragraphName:
We can then specialize{~}\texttt{v\makebox[0.61ex][l]{$ _{{1}} $}} and{~}\texttt{x\makebox[0.61ex][l]{$ _{{1}} $}} to{~}\texttt{\makebox[1.22ex][l]{$ {(} $}}\texttt{\makebox[1.22ex][r]{$ {)} $}}, \texttt{v}    to{~}\texttt{const}\texttt{\mbox{\hspace{0.50em}}}\texttt{x\makebox[0.61ex][l]{$ _{{2}} $}}, and{~}\texttt{g} to{~}\texttt{mapNew}\texttt{\mbox{\hspace{0.50em}}}\texttt{v}. By definition, \texttt{g}    satisfies the conditions of the lemma and we get{:}%


%
%comment: {- --
%


{\nopagebreak }

%
%code:
%
%comment: f x ≡ mapNew (const x) <$> f ()
%
~\\~\vphantom{$\{$}\texttt{f}\texttt{\mbox{\hspace{0.50em}}}\texttt{x}\texttt{\mbox{\hspace{0.50em}}}\texttt{$ \equiv $}\texttt{\mbox{\hspace{0.50em}}}\texttt{mapNew}\texttt{\mbox{\hspace{0.50em}}}\texttt{\makebox[1.22ex][l]{$ {(} $}}\texttt{const}\texttt{\mbox{\hspace{0.50em}}}\texttt{x}\texttt{\makebox[1.22ex][r]{$ {)} $}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\makebox[1.22ex][c]{\textless{}}\${}\makebox[1.22ex][c]{\textgreater{}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{f}\texttt{\mbox{\hspace{0.50em}}}\texttt{\makebox[1.22ex][l]{$ {(} $}}\texttt{\makebox[1.22ex][r]{$ {)} $}}\texttt{{\nopagebreak \newline%
}\vphantom{$\{$}}%


%
%comment: -- -}
%


%
%paragraphName:
We can then reason equationally{:}%


%
%comment: {- --
%


{\nopagebreak }

%
%code:
%
%comment:    f
% ≡ {- by the above -}
%   \ x → mapNew (const x) <$> f ()
% ≡ {- by def -}
%   succToUniv (f ())
% ≡ {- by def -}
%   succToUniv (univToSucc f)
%
~\\~\vphantom{$\{$}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{f}\texttt{{\nopagebreak \newline%
}\vphantom{$\{$}}\texttt{\mbox{\hspace{0.50em}}}\texttt{$ \equiv $}\texttt{\mbox{\hspace{0.50em}}}\texttt{\makebox[1.22ex][l]{\{{}}\makebox[1.22ex][c]{-}\mbox{\hspace{0.50em}}by\mbox{\hspace{0.50em}}the\mbox{\hspace{0.50em}}above\mbox{\hspace{0.50em}}\makebox[1.22ex][c]{-}\makebox[1.22ex][r]{\}{}}}\texttt{{\nopagebreak \newline%
}\vphantom{$\{$}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{$ \lambda $}\texttt{\mbox{\hspace{0.50em}}}\texttt{x}\texttt{\mbox{\hspace{0.50em}}}\texttt{$ \rightarrow $}\texttt{\mbox{\hspace{0.50em}}}\texttt{mapNew}\texttt{\mbox{\hspace{0.50em}}}\texttt{\makebox[1.22ex][l]{$ {(} $}}\texttt{const}\texttt{\mbox{\hspace{0.50em}}}\texttt{x}\texttt{\makebox[1.22ex][r]{$ {)} $}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\makebox[1.22ex][c]{\textless{}}\${}\makebox[1.22ex][c]{\textgreater{}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{f}\texttt{\mbox{\hspace{0.50em}}}\texttt{\makebox[1.22ex][l]{$ {(} $}}\texttt{\makebox[1.22ex][r]{$ {)} $}}\texttt{{\nopagebreak \newline%
}\vphantom{$\{$}}\texttt{\mbox{\hspace{0.50em}}}\texttt{$ \equiv $}\texttt{\mbox{\hspace{0.50em}}}\texttt{\makebox[1.22ex][l]{\{{}}\makebox[1.22ex][c]{-}\mbox{\hspace{0.50em}}by\mbox{\hspace{0.50em}}def\mbox{\hspace{0.50em}}\makebox[1.22ex][c]{-}\makebox[1.22ex][r]{\}{}}}\texttt{{\nopagebreak \newline%
}\vphantom{$\{$}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{succToUniv}\texttt{\mbox{\hspace{0.50em}}}\texttt{\makebox[1.22ex][l]{$ {(} $}}\texttt{f}\texttt{\mbox{\hspace{0.50em}}}\texttt{\makebox[1.22ex][l]{$ {(} $}}\texttt{\makebox[1.22ex][r]{$ {)} $}}\texttt{\makebox[1.22ex][r]{$ {)} $}}\texttt{{\nopagebreak \newline%
}\vphantom{$\{$}}\texttt{\mbox{\hspace{0.50em}}}\texttt{$ \equiv $}\texttt{\mbox{\hspace{0.50em}}}\texttt{\makebox[1.22ex][l]{\{{}}\makebox[1.22ex][c]{-}\mbox{\hspace{0.50em}}by\mbox{\hspace{0.50em}}def\mbox{\hspace{0.50em}}\makebox[1.22ex][c]{-}\makebox[1.22ex][r]{\}{}}}\texttt{{\nopagebreak \newline%
}\vphantom{$\{$}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{succToUniv}\texttt{\mbox{\hspace{0.50em}}}\texttt{\makebox[1.22ex][l]{$ {(} $}}\texttt{univToSucc}\texttt{\mbox{\hspace{0.50em}}}\texttt{f}\texttt{\makebox[1.22ex][r]{$ {)} $}}\texttt{{\nopagebreak \newline%
}\vphantom{$\{$}}%


%
%comment: -- -}
%


\subsection{\texttt{ExistScope}\texttt{\mbox{\hspace{0.50em}}}\texttt{tm}\texttt{\mbox{\hspace{0.50em}}}\texttt{a}\texttt{\mbox{\hspace{0.50em}}}\texttt{\ensuremath{\cong}}\texttt{\mbox{\hspace{0.50em}}}\texttt{SuccScope}\texttt{\mbox{\hspace{0.50em}}}\texttt{tm}\texttt{\mbox{\hspace{0.50em}}}\texttt{a} }

%
%paragraphName: conversions
The conversion functions witnessing the isomorphism are the
    following.%


\newpage

%
%code:
{\noindent}%
%comment: succToExist :: SuccScope tm a → ExistScope tm a
%succToExist = E ()
%
\vphantom{$\{$}\texttt{succToExist}\texttt{\mbox{\hspace{0.50em}}}\texttt{{:}{:}}\texttt{\mbox{\hspace{0.50em}}}\texttt{SuccScope}\texttt{\mbox{\hspace{0.50em}}}\texttt{tm}\texttt{\mbox{\hspace{0.50em}}}\texttt{a}\texttt{\mbox{\hspace{0.50em}}}\texttt{$ \rightarrow $}\texttt{\mbox{\hspace{0.50em}}}\texttt{ExistScope}\texttt{\mbox{\hspace{0.50em}}}\texttt{tm}\texttt{\mbox{\hspace{0.50em}}}\texttt{a}\texttt{{\nopagebreak \newline%
}\vphantom{$\{$}}\texttt{succToExist}\texttt{\mbox{\hspace{0.50em}}}\texttt{{\char `\=}}\texttt{\mbox{\hspace{0.50em}}}\texttt{E}\texttt{\mbox{\hspace{0.50em}}}\texttt{\makebox[1.22ex][l]{$ {(} $}}\texttt{\makebox[1.22ex][r]{$ {)} $}}\texttt{{\nopagebreak \newline%
}\vphantom{$\{$}}%


%
%code:
{\noindent}%
%comment: existToSucc :: Functor tm ⇒
%               ExistScope tm a → SuccScope tm a
%existToSucc (E _ t) = mapNew (const ()) <$> t
%
\vphantom{$\{$}\texttt{existToSucc}\texttt{\mbox{\hspace{0.50em}}}\texttt{{:}{:}}\texttt{\mbox{\hspace{0.50em}}}\texttt{Functor}\texttt{\mbox{\hspace{0.50em}}}\texttt{tm}\texttt{\mbox{\hspace{0.50em}}}\texttt{$ \Rightarrow $}\texttt{{\nopagebreak \newline%
}\vphantom{$\{$}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{ExistScope}\texttt{\mbox{\hspace{0.50em}}}\texttt{tm}\texttt{\mbox{\hspace{0.50em}}}\texttt{a}\texttt{\mbox{\hspace{0.50em}}}\texttt{$ \rightarrow $}\texttt{\mbox{\hspace{0.50em}}}\texttt{SuccScope}\texttt{\mbox{\hspace{0.50em}}}\texttt{tm}\texttt{\mbox{\hspace{0.50em}}}\texttt{a}\texttt{{\nopagebreak \newline%
}\vphantom{$\{$}}\texttt{existToSucc}\texttt{\mbox{\hspace{0.50em}}}\texttt{\makebox[1.22ex][l]{$ {(} $}}\texttt{E}\texttt{\mbox{\hspace{0.50em}}}\texttt{\makebox[1.22ex][c]{\_{}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{t}\texttt{\makebox[1.22ex][r]{$ {)} $}}\texttt{\mbox{\hspace{0.50em}}}\texttt{{\char `\=}}\texttt{\mbox{\hspace{0.50em}}}\texttt{mapNew}\texttt{\mbox{\hspace{0.50em}}}\texttt{\makebox[1.22ex][l]{$ {(} $}}\texttt{const}\texttt{\mbox{\hspace{0.50em}}}\texttt{\makebox[1.22ex][l]{$ {(} $}}\texttt{\makebox[1.22ex][r]{$ {)} $}}\texttt{\makebox[1.22ex][r]{$ {)} $}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\makebox[1.22ex][c]{\textless{}}\${}\makebox[1.22ex][c]{\textgreater{}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{t}\texttt{{\nopagebreak \newline%
}\vphantom{$\{$}}%


%
%paragraphName:
One can recognise the functions{~}\texttt{pack} and{~}\texttt{unpack} as CPS
    versions of{~}\texttt{existToSucc} and{~}\texttt{succToExist}.%


%
%paragraphName:
The proof of{~}\texttt{existToSucc}\texttt{\mbox{\hspace{0.50em}}}\texttt{.}\texttt{\mbox{\hspace{0.50em}}}\texttt{succToExist}\texttt{\mbox{\hspace{0.50em}}}\texttt{$ \equiv $}\texttt{\mbox{\hspace{0.50em}}}\texttt{id} (no junk) is nearly
    identical to the first proof about{~}\texttt{UnivScope} and hence omitted.
    To prove \texttt{succToExist}\texttt{\mbox{\hspace{0.50em}}}\texttt{.}\texttt{\mbox{\hspace{0.50em}}}\texttt{existToSucc}\texttt{\mbox{\hspace{0.50em}}}\texttt{$ \equiv $}\texttt{\mbox{\hspace{0.50em}}}\texttt{id}, we first remark that by
    definition{:}%


%
%comment: {- --
%


{\nopagebreak }

%
%code:
%
%comment: succToExist (existToSucc (E y t)) ≡
%  E () (fmap (mapNew (const ())) t)
%
~\\~\vphantom{$\{$}\texttt{succToExist}\texttt{\mbox{\hspace{0.50em}}}\texttt{\makebox[1.22ex][l]{$ {(} $}}\texttt{existToSucc}\texttt{\mbox{\hspace{0.50em}}}\texttt{\makebox[1.22ex][l]{$ {(} $}}\texttt{E}\texttt{\mbox{\hspace{0.50em}}}\texttt{y}\texttt{\mbox{\hspace{0.50em}}}\texttt{t}\texttt{\makebox[1.22ex][r]{$ {)} $}}\texttt{\makebox[1.22ex][r]{$ {)} $}}\texttt{\mbox{\hspace{0.50em}}}\texttt{$ \equiv $}\texttt{{\nopagebreak \newline%
}\vphantom{$\{$}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{E}\texttt{\mbox{\hspace{0.50em}}}\texttt{\makebox[1.22ex][l]{$ {(} $}}\texttt{\makebox[1.22ex][r]{$ {)} $}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\makebox[1.22ex][l]{$ {(} $}}\texttt{fmap}\texttt{\mbox{\hspace{0.50em}}}\texttt{\makebox[1.22ex][l]{$ {(} $}}\texttt{mapNew}\texttt{\mbox{\hspace{0.50em}}}\texttt{\makebox[1.22ex][l]{$ {(} $}}\texttt{const}\texttt{\mbox{\hspace{0.50em}}}\texttt{\makebox[1.22ex][l]{$ {(} $}}\texttt{\makebox[1.22ex][r]{$ {)} $}}\texttt{\makebox[1.22ex][r]{$ {)} $}}\texttt{\makebox[1.22ex][r]{$ {)} $}}\texttt{\mbox{\hspace{0.50em}}}\texttt{t}\texttt{\makebox[1.22ex][r]{$ {)} $}}\texttt{{\nopagebreak \newline%
}\vphantom{$\{$}}%


%
%comment: -- -}
%


%
%paragraphName:
It remains to show that{~}\texttt{E}\texttt{\mbox{\hspace{0.50em}}}\texttt{y}\texttt{\mbox{\hspace{0.50em}}}\texttt{t} is equivalent to the right-hand
    side of the above equation. To do so, we consider any observation
    function{~}\texttt{o} of type \texttt{\makebox[1.22ex][c]{$ \forall $}}\texttt{\mbox{\hspace{0.50em}}}\texttt{v}\texttt{.}\texttt{\mbox{\hspace{0.50em}}}\texttt{v}\texttt{\mbox{\hspace{0.50em}}}\texttt{$ \rightarrow $}\texttt{\mbox{\hspace{0.50em}}}\texttt{tm}\texttt{\mbox{\hspace{0.50em}}}\texttt{\makebox[1.22ex][l]{$ {(} $}}\texttt{a}\texttt{\mbox{\hspace{0.50em}}}\texttt{$ \vartriangleright $}\texttt{\mbox{\hspace{0.50em}}}\texttt{v}\texttt{\makebox[1.22ex][r]{$ {)} $}}\texttt{\mbox{\hspace{0.50em}}}\texttt{$ \rightarrow $}\texttt{\mbox{\hspace{0.50em}}}\texttt{K} for some constant
    type{~}\texttt{K}, and show that it returns the same result if applied
    to{~}\texttt{y} and{~}\texttt{t} or{~}\texttt{\makebox[1.22ex][l]{$ {(} $}}\texttt{\makebox[1.22ex][r]{$ {)} $}} and{~}\texttt{fmap}\texttt{\mbox{\hspace{0.50em}}}\texttt{\makebox[1.22ex][l]{$ {(} $}}\texttt{mapNew}\texttt{\mbox{\hspace{0.50em}}}\texttt{\makebox[1.22ex][l]{$ {(} $}}\texttt{const}\texttt{\mbox{\hspace{0.50em}}}\texttt{\makebox[1.22ex][l]{$ {(} $}}\texttt{\makebox[1.22ex][r]{$ {)} $}}\texttt{\makebox[1.22ex][r]{$ {)} $}}\texttt{\makebox[1.22ex][r]{$ {)} $}}\texttt{{\nopagebreak \newline%
}\vphantom{$\{$}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{t}. This fact is a consequence of the free theorem associated
    with{~}\texttt{o}{:}%


%
%comment: {- --
%


{\nopagebreak }

%
%code:
%
%comment:  ∀ v₁:*.  ∀ v₂:*. ∀ v:v₁ → v₂.
% ∀ x₁:v₁. ∀ x₂:*. v x₁ ≡ x₂.
% ∀ t₁:tm (a :▹ v₁). ∀ t₂:tm (a :▹ v₂).
% (∀ g:(a :▹ v₁) → (a :▹ v₂).
%  (∀ y:v₁. New (v y) ≡ g (New y)) →
%  (∀ n:a.  Old n     ≡ g (Old n)) →
%  t₂ ≡ fmap g t₁) →
% o x₂ t₂ ≡ o x₁ t₁
%
~\\~\vphantom{$\{$}\texttt{\mbox{\hspace{0.50em}}}\texttt{\makebox[1.22ex][c]{$ \forall $}}\texttt{\mbox{\hspace{0.50em}}}\texttt{v\makebox[0.61ex][l]{$ _{{1}} $}{:}}\texttt{*.}\texttt{\mbox{\hspace{0.50em}}}\texttt{\ensuremath{\!}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\makebox[1.22ex][c]{$ \forall $}}\texttt{\mbox{\hspace{0.50em}}}\texttt{v\makebox[0.61ex][l]{$ _{{2}} $}{:}}\texttt{*.}\texttt{\mbox{\hspace{0.50em}}}\texttt{\makebox[1.22ex][c]{$ \forall $}}\texttt{\mbox{\hspace{0.50em}}}\texttt{v}\texttt{{:}}\texttt{v\makebox[0.61ex][l]{$ _{{1}} $}}\texttt{\mbox{\hspace{0.50em}}}\texttt{$ \rightarrow $}\texttt{\mbox{\hspace{0.50em}}}\texttt{v\makebox[0.61ex][l]{$ _{{2}} $}.}\texttt{{\nopagebreak \newline%
}\vphantom{$\{$}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\makebox[1.22ex][c]{$ \forall $}}\texttt{\mbox{\hspace{0.50em}}}\texttt{x\makebox[0.61ex][l]{$ _{{1}} $}{:}v\makebox[0.61ex][l]{$ _{{1}} $}.}\texttt{\mbox{\hspace{0.50em}}}\texttt{\makebox[1.22ex][c]{$ \forall $}}\texttt{\mbox{\hspace{0.50em}}}\texttt{x\makebox[0.61ex][l]{$ _{{2}} $}{:}}\texttt{*.}\texttt{\mbox{\hspace{0.50em}}}\texttt{v}\texttt{\mbox{\hspace{0.50em}}}\texttt{x\makebox[0.61ex][l]{$ _{{1}} $}}\texttt{\mbox{\hspace{0.50em}}}\texttt{$ \equiv $}\texttt{\mbox{\hspace{0.50em}}}\texttt{x\makebox[0.61ex][l]{$ _{{2}} $}.}\texttt{{\nopagebreak \newline%
}\vphantom{$\{$}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\makebox[1.22ex][c]{$ \forall $}}\texttt{\mbox{\hspace{0.50em}}}\texttt{t\makebox[0.61ex][l]{$ _{{1}} $}{:}tm}\texttt{\mbox{\hspace{0.50em}}}\texttt{\makebox[1.22ex][l]{$ {(} $}}\texttt{a}\texttt{\mbox{\hspace{0.50em}}}\texttt{$ \vartriangleright $}\texttt{\mbox{\hspace{0.50em}}}\texttt{v\makebox[0.61ex][l]{$ _{{1}} $}}\texttt{\makebox[1.22ex][r]{$ {)} $}}\texttt{.}\texttt{\mbox{\hspace{0.50em}}}\texttt{\makebox[1.22ex][c]{$ \forall $}}\texttt{\mbox{\hspace{0.50em}}}\texttt{t\makebox[0.61ex][l]{$ _{{2}} $}{:}tm}\texttt{\mbox{\hspace{0.50em}}}\texttt{\makebox[1.22ex][l]{$ {(} $}}\texttt{a}\texttt{\mbox{\hspace{0.50em}}}\texttt{$ \vartriangleright $}\texttt{\mbox{\hspace{0.50em}}}\texttt{v\makebox[0.61ex][l]{$ _{{2}} $}}\texttt{\makebox[1.22ex][r]{$ {)} $}}\texttt{.}\texttt{{\nopagebreak \newline%
}\vphantom{$\{$}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\makebox[1.22ex][l]{$ {(} $}}\texttt{\makebox[1.22ex][c]{$ \forall $}}\texttt{\mbox{\hspace{0.50em}}}\texttt{g}\texttt{{:}}\texttt{\makebox[1.22ex][l]{$ {(} $}}\texttt{a}\texttt{\mbox{\hspace{0.50em}}}\texttt{$ \vartriangleright $}\texttt{\mbox{\hspace{0.50em}}}\texttt{v\makebox[0.61ex][l]{$ _{{1}} $}}\texttt{\makebox[1.22ex][r]{$ {)} $}}\texttt{\mbox{\hspace{0.50em}}}\texttt{$ \rightarrow $}\texttt{\mbox{\hspace{0.50em}}}\texttt{\makebox[1.22ex][l]{$ {(} $}}\texttt{a}\texttt{\mbox{\hspace{0.50em}}}\texttt{$ \vartriangleright $}\texttt{\mbox{\hspace{0.50em}}}\texttt{v\makebox[0.61ex][l]{$ _{{2}} $}}\texttt{\makebox[1.22ex][r]{$ {)} $}}\texttt{.}\texttt{{\nopagebreak \newline%
}\vphantom{$\{$}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\makebox[1.22ex][l]{$ {(} $}}\texttt{\makebox[1.22ex][c]{$ \forall $}}\texttt{\mbox{\hspace{0.50em}}}\texttt{y}\texttt{{:}}\texttt{v\makebox[0.61ex][l]{$ _{{1}} $}.}\texttt{\mbox{\hspace{0.50em}}}\texttt{New}\texttt{\mbox{\hspace{0.50em}}}\texttt{\makebox[1.22ex][l]{$ {(} $}}\texttt{v}\texttt{\mbox{\hspace{0.50em}}}\texttt{y}\texttt{\makebox[1.22ex][r]{$ {)} $}}\texttt{\mbox{\hspace{0.50em}}}\texttt{$ \equiv $}\texttt{\mbox{\hspace{0.50em}}}\texttt{g}\texttt{\mbox{\hspace{0.50em}}}\texttt{\makebox[1.22ex][l]{$ {(} $}}\texttt{New}\texttt{\mbox{\hspace{0.50em}}}\texttt{y}\texttt{\makebox[1.22ex][r]{$ {)} $}}\texttt{\makebox[1.22ex][r]{$ {)} $}}\texttt{\mbox{\hspace{0.50em}}}\texttt{$ \rightarrow $}\texttt{{\nopagebreak \newline%
}\vphantom{$\{$}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\makebox[1.22ex][l]{$ {(} $}}\texttt{\makebox[1.22ex][c]{$ \forall $}}\texttt{\mbox{\hspace{0.50em}}}\texttt{n}\texttt{{:}}\texttt{a}\texttt{.}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{Old}\texttt{\mbox{\hspace{0.50em}}}\texttt{n}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{$ \equiv $}\texttt{\mbox{\hspace{0.50em}}}\texttt{g}\texttt{\mbox{\hspace{0.50em}}}\texttt{\makebox[1.22ex][l]{$ {(} $}}\texttt{Old}\texttt{\mbox{\hspace{0.50em}}}\texttt{n}\texttt{\makebox[1.22ex][r]{$ {)} $}}\texttt{\makebox[1.22ex][r]{$ {)} $}}\texttt{\mbox{\hspace{0.50em}}}\texttt{$ \rightarrow $}\texttt{{\nopagebreak \newline%
}\vphantom{$\{$}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{t\makebox[0.61ex][l]{$ _{{2}} $}}\texttt{\mbox{\hspace{0.50em}}}\texttt{$ \equiv $}\texttt{\mbox{\hspace{0.50em}}}\texttt{fmap}\texttt{\mbox{\hspace{0.50em}}}\texttt{g}\texttt{\mbox{\hspace{0.50em}}}\texttt{t\makebox[0.61ex][l]{$ _{{1}} $}}\texttt{\makebox[1.22ex][r]{$ {)} $}}\texttt{\mbox{\hspace{0.50em}}}\texttt{$ \rightarrow $}\texttt{{\nopagebreak \newline%
}\vphantom{$\{$}}\texttt{\mbox{\hspace{0.50em}}}\texttt{o}\texttt{\mbox{\hspace{0.50em}}}\texttt{x\makebox[0.61ex][l]{$ _{{2}} $}}\texttt{\mbox{\hspace{0.50em}}}\texttt{t\makebox[0.61ex][l]{$ _{{2}} $}}\texttt{\mbox{\hspace{0.50em}}}\texttt{$ \equiv $}\texttt{\mbox{\hspace{0.50em}}}\texttt{o}\texttt{\mbox{\hspace{0.50em}}}\texttt{x\makebox[0.61ex][l]{$ _{{1}} $}}\texttt{\mbox{\hspace{0.50em}}}\texttt{t\makebox[0.61ex][l]{$ _{{1}} $}}\texttt{{\nopagebreak \newline%
}\vphantom{$\{$}}%


%
%comment: -- -}
%


%
%paragraphName:
Indeed, after specializing{~}\texttt{x\makebox[0.61ex][l]{$ _{{2}} $}} to{~}\texttt{\makebox[1.22ex][l]{$ {(} $}}\texttt{\makebox[1.22ex][r]{$ {)} $}} and{~}\texttt{v}    to{~}\texttt{const}\texttt{\mbox{\hspace{0.50em}}}\texttt{\makebox[1.22ex][l]{$ {(} $}}\texttt{\makebox[1.22ex][r]{$ {)} $}}, the last condition amounts
    to{~}\texttt{t\makebox[0.61ex][l]{$ _{{2}} $}}\texttt{\mbox{\hspace{0.50em}}}\texttt{$ \equiv $}\texttt{\mbox{\hspace{0.50em}}}\texttt{fmap}\texttt{\mbox{\hspace{0.50em}}}\texttt{\makebox[1.22ex][l]{$ {(} $}}\texttt{mapNew}\texttt{\mbox{\hspace{0.50em}}}\texttt{\makebox[1.22ex][l]{$ {(} $}}\texttt{const}\texttt{\mbox{\hspace{0.50em}}}\texttt{\makebox[1.22ex][l]{$ {(} $}}\texttt{\makebox[1.22ex][r]{$ {)} $}}\texttt{\makebox[1.22ex][r]{$ {)} $}}\texttt{\makebox[1.22ex][r]{$ {)} $}}\texttt{\mbox{\hspace{0.50em}}}\texttt{t\makebox[0.61ex][l]{$ _{{1}} $}}, and we get the desired
    result.%


\subsection{A Matter of Style\label{styleSec}}

%
%paragraphName:
We have seen that \texttt{ExistScope} is well-suited for term analysis,
    while \texttt{UnivScope} is well-suited for term construction. What
    about term \emph{transformations}, which combine both aspects?
    In this case, one is free to choose either interface. This can be
    illustrated by showing both alternatives for the \texttt{Lam} case of the
    \texttt{fmap} function. (The \texttt{App} and \texttt{Var} cases are identical.)
    Because the second version is more concise, we prefer it in the
    upcoming examples, but the other choice is equally valid.%


%
%comment: {- --
%


{\nopagebreak }

%
%code:
%
%comment: fmap' f (Lam b)
%   = unpack b $ \ x t → lamP x (mapOld f <$> t)
%fmap' f (Lam b)
%   = lam (\ x → mapOld f <$> (b `atVar` x))
%
~\\~\vphantom{$\{$}\texttt{fmap{'}}\texttt{\mbox{\hspace{0.50em}}}\texttt{f}\texttt{\mbox{\hspace{0.50em}}}\texttt{\makebox[1.22ex][l]{$ {(} $}}\texttt{Lam}\texttt{\mbox{\hspace{0.50em}}}\texttt{b}\texttt{\makebox[1.22ex][r]{$ {)} $}}\texttt{{\nopagebreak \newline%
}\vphantom{$\{$}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{{\char `\=}}\texttt{\mbox{\hspace{0.50em}}}\texttt{unpack}\texttt{\mbox{\hspace{0.50em}}}\texttt{b}\texttt{\mbox{\hspace{0.50em}}}\texttt{\${}}\texttt{\mbox{\hspace{0.50em}}}\texttt{$ \lambda $}\texttt{\mbox{\hspace{0.50em}}}\texttt{x}\texttt{\mbox{\hspace{0.50em}}}\texttt{t}\texttt{\mbox{\hspace{0.50em}}}\texttt{$ \rightarrow $}\texttt{\mbox{\hspace{0.50em}}}\texttt{lamP}\texttt{\mbox{\hspace{0.50em}}}\texttt{x}\texttt{\mbox{\hspace{0.50em}}}\texttt{\makebox[1.22ex][l]{$ {(} $}}\texttt{mapOld}\texttt{\mbox{\hspace{0.50em}}}\texttt{f}\texttt{\mbox{\hspace{0.50em}}}\texttt{\makebox[1.22ex][c]{\textless{}}\${}\makebox[1.22ex][c]{\textgreater{}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{t}\texttt{\makebox[1.22ex][r]{$ {)} $}}\texttt{{\nopagebreak \newline%
}\vphantom{$\{$}}\texttt{fmap{'}}\texttt{\mbox{\hspace{0.50em}}}\texttt{f}\texttt{\mbox{\hspace{0.50em}}}\texttt{\makebox[1.22ex][l]{$ {(} $}}\texttt{Lam}\texttt{\mbox{\hspace{0.50em}}}\texttt{b}\texttt{\makebox[1.22ex][r]{$ {)} $}}\texttt{{\nopagebreak \newline%
}\vphantom{$\{$}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{{\char `\=}}\texttt{\mbox{\hspace{0.50em}}}\texttt{lam}\texttt{\mbox{\hspace{0.50em}}}\texttt{\makebox[1.22ex][l]{$ {(} $}}\texttt{$ \lambda $}\texttt{\mbox{\hspace{0.50em}}}\texttt{x}\texttt{\mbox{\hspace{0.50em}}}\texttt{$ \rightarrow $}\texttt{\mbox{\hspace{0.50em}}}\texttt{mapOld}\texttt{\mbox{\hspace{0.50em}}}\texttt{f}\texttt{\mbox{\hspace{0.50em}}}\texttt{\makebox[1.22ex][c]{\textless{}}\${}\makebox[1.22ex][c]{\textgreater{}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\makebox[1.22ex][l]{$ {(} $}}\texttt{b}\texttt{\mbox{\hspace{0.50em}}}\texttt{{`}atVar{`}}\texttt{\mbox{\hspace{0.50em}}}\texttt{x}\texttt{\makebox[1.22ex][r]{$ {)} $}}\texttt{\makebox[1.22ex][r]{$ {)} $}}\texttt{{\nopagebreak \newline%
}\vphantom{$\{$}}%


%
%comment: -- -}
%


%
%paragraphName:
When using \texttt{succToUniv}, the type of the second argument of
    \texttt{succToUniv} should always be a type variable in order to have
    maximally polymorphic contexts. To remind us of this requirement
    when writing code, we give the alias \texttt{atVar} for \texttt{succToUniv}.
    (Similarly, to guarantee safety, the first argument of \texttt{pack}    (encapsulated here in \texttt{lamP}) must be maximally polymorphic.)%


\subsection{Scope Representations and Term Representations}

%
%paragraphName:
By using an interface such as ours, term representations can be
    made agnostic to the particular scope representation one might
    choose. In other words, if some interface appears well-suited
    to a given application domain, one might choose it as the scope
    representation in the implementation. Typically, this choice is be
    guided by performance considerations. Within this paper we favor
    code concision instead, and therefore in sec. \ref{hereditarySec}    we use \texttt{ExistScope}, and in sections \ref{closureSec} and \ref{cpsSec} we use \texttt{UnivScope}.%


\section{Bigger Examples\label{examples}}

\subsection{Normalization using hereditary substitution\label{hereditarySec}}

%
%paragraphName:
A standard test of binder representations is how well they support normalization. 
    In this section we show how to implement normalization using our constructions.%


%
%paragraphName:
The following type
    captures normal forms of the untyped $ \lambda $-calculus{:} a normal form is
    either an abstraction over a normal form or a neutral term (a variable applied to some normal forms). In
    this definition we use an existential-based version of scopes, which
    we splice in the{~}\texttt{LamNo} constructor.%


{\nopagebreak }

%
%code:
%
%comment: data No a where
%  LamNo :: v → No (a :▹ v) → No a
%  Neutr :: a → [No a] → No a
%
~\\~\vphantom{$\{$}\texttt{data}\texttt{\mbox{\hspace{0.50em}}}\texttt{No}\texttt{\mbox{\hspace{0.50em}}}\texttt{a}\texttt{\mbox{\hspace{0.50em}}}\texttt{where}\texttt{{\nopagebreak \newline%
}\vphantom{$\{$}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{LamNo}\texttt{\mbox{\hspace{0.50em}}}\texttt{{:}{:}}\texttt{\mbox{\hspace{0.50em}}}\texttt{v}\texttt{\mbox{\hspace{0.50em}}}\texttt{$ \rightarrow $}\texttt{\mbox{\hspace{0.50em}}}\texttt{No}\texttt{\mbox{\hspace{0.50em}}}\texttt{\makebox[1.22ex][l]{$ {(} $}}\texttt{a}\texttt{\mbox{\hspace{0.50em}}}\texttt{$ \vartriangleright $}\texttt{\mbox{\hspace{0.50em}}}\texttt{v}\texttt{\makebox[1.22ex][r]{$ {)} $}}\texttt{\mbox{\hspace{0.50em}}}\texttt{$ \rightarrow $}\texttt{\mbox{\hspace{0.50em}}}\texttt{No}\texttt{\mbox{\hspace{0.50em}}}\texttt{a}\texttt{{\nopagebreak \newline%
}\vphantom{$\{$}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{Neutr}\texttt{\mbox{\hspace{0.50em}}}\texttt{{:}{:}}\texttt{\mbox{\hspace{0.50em}}}\texttt{a}\texttt{\mbox{\hspace{0.50em}}}\texttt{$ \rightarrow $}\texttt{\mbox{\hspace{0.50em}}}\texttt{{[}}\texttt{No}\texttt{\mbox{\hspace{0.50em}}}\texttt{a}\texttt{{]}}\texttt{\mbox{\hspace{0.50em}}}\texttt{$ \rightarrow $}\texttt{\mbox{\hspace{0.50em}}}\texttt{No}\texttt{\mbox{\hspace{0.50em}}}\texttt{a}\texttt{{\nopagebreak \newline%
}\vphantom{$\{$}}%


%
%paragraphName:
The key to this normalization procedure is that normal forms
    are stable under hereditary substitution{~}\cite{nanevski-08}.
    The function performing a hereditary substitution substitutes
    variables for their value, while reducing redexes on the fly.%


{\nopagebreak }

%
%code:
%
%comment: instance Monad No where
%  return x = Neutr x []
%  LamNo x t  >>= θ = LamNo x (t >>= liftSubst x θ)
%  Neutr f ts >>= θ = foldl app (θ f)((>>= θ)<$>ts)
%
~\\~\vphantom{$\{$}\texttt{instance}\texttt{\mbox{\hspace{0.50em}}}\texttt{Monad}\texttt{\mbox{\hspace{0.50em}}}\texttt{No}\texttt{\mbox{\hspace{0.50em}}}\texttt{where}\texttt{{\nopagebreak \newline%
}\vphantom{$\{$}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{return}\texttt{\mbox{\hspace{0.50em}}}\texttt{x}\texttt{\mbox{\hspace{0.50em}}}\texttt{{\char `\=}}\texttt{\mbox{\hspace{0.50em}}}\texttt{Neutr}\texttt{\mbox{\hspace{0.50em}}}\texttt{x}\texttt{\mbox{\hspace{0.50em}}}\texttt{{[}}\texttt{{]}}\texttt{{\nopagebreak \newline%
}\vphantom{$\{$}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{LamNo}\texttt{\mbox{\hspace{0.50em}}}\texttt{x}\texttt{\mbox{\hspace{0.50em}}}\texttt{t}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\makebox[1.22ex][c]{\textgreater{}}\makebox[1.22ex][c]{\textgreater{}}{\char `\=}}\texttt{\mbox{\hspace{0.50em}}}\texttt{$ \theta $}\texttt{\mbox{\hspace{0.50em}}}\texttt{{\char `\=}}\texttt{\mbox{\hspace{0.50em}}}\texttt{LamNo}\texttt{\mbox{\hspace{0.50em}}}\texttt{x}\texttt{\mbox{\hspace{0.50em}}}\texttt{\makebox[1.22ex][l]{$ {(} $}}\texttt{t}\texttt{\mbox{\hspace{0.50em}}}\texttt{\makebox[1.22ex][c]{\textgreater{}}\makebox[1.22ex][c]{\textgreater{}}{\char `\=}}\texttt{\mbox{\hspace{0.50em}}}\texttt{liftSubst}\texttt{\mbox{\hspace{0.50em}}}\texttt{x}\texttt{\mbox{\hspace{0.50em}}}\texttt{$ \theta $}\texttt{\makebox[1.22ex][r]{$ {)} $}}\texttt{{\nopagebreak \newline%
}\vphantom{$\{$}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{Neutr}\texttt{\mbox{\hspace{0.50em}}}\texttt{f}\texttt{\mbox{\hspace{0.50em}}}\texttt{ts}\texttt{\mbox{\hspace{0.50em}}}\texttt{\makebox[1.22ex][c]{\textgreater{}}\makebox[1.22ex][c]{\textgreater{}}{\char `\=}}\texttt{\mbox{\hspace{0.50em}}}\texttt{$ \theta $}\texttt{\mbox{\hspace{0.50em}}}\texttt{{\char `\=}}\texttt{\mbox{\hspace{0.50em}}}\texttt{foldl}\texttt{\mbox{\hspace{0.50em}}}\texttt{app}\texttt{\mbox{\hspace{0.50em}}}\texttt{\makebox[1.22ex][l]{$ {(} $}}\texttt{$ \theta $}\texttt{\mbox{\hspace{0.50em}}}\texttt{f}\texttt{\makebox[1.22ex][r]{$ {)} $}}\texttt{\makebox[1.22ex][l]{$ {(} $}}\texttt{\makebox[1.22ex][l]{$ {(} $}}\texttt{\makebox[1.22ex][c]{\textgreater{}}\makebox[1.22ex][c]{\textgreater{}}{\char `\=}}\texttt{\mbox{\hspace{0.50em}}}\texttt{$ \theta $}\texttt{\makebox[1.22ex][r]{$ {)} $}}\texttt{\makebox[1.22ex][c]{\textless{}}\${}\makebox[1.22ex][c]{\textgreater{}}}\texttt{ts}\texttt{\makebox[1.22ex][r]{$ {)} $}}\texttt{{\nopagebreak \newline%
}\vphantom{$\{$}}%


%
%paragraphName:
The most notable feature of this substitution is the use of{~}\texttt{app}    to normalize redexes{:}%


{\nopagebreak }

%
%code:
%
%comment: app :: No a → No a → No a
%app (LamNo x t)  u = substituteOut x u t
%app (Neutr f ts) u = Neutr f (ts++[u])
%
~\\~\vphantom{$\{$}\texttt{app}\texttt{\mbox{\hspace{0.50em}}}\texttt{{:}{:}}\texttt{\mbox{\hspace{0.50em}}}\texttt{No}\texttt{\mbox{\hspace{0.50em}}}\texttt{a}\texttt{\mbox{\hspace{0.50em}}}\texttt{$ \rightarrow $}\texttt{\mbox{\hspace{0.50em}}}\texttt{No}\texttt{\mbox{\hspace{0.50em}}}\texttt{a}\texttt{\mbox{\hspace{0.50em}}}\texttt{$ \rightarrow $}\texttt{\mbox{\hspace{0.50em}}}\texttt{No}\texttt{\mbox{\hspace{0.50em}}}\texttt{a}\texttt{{\nopagebreak \newline%
}\vphantom{$\{$}}\texttt{app}\texttt{\mbox{\hspace{0.50em}}}\texttt{\makebox[1.22ex][l]{$ {(} $}}\texttt{LamNo}\texttt{\mbox{\hspace{0.50em}}}\texttt{x}\texttt{\mbox{\hspace{0.50em}}}\texttt{t}\texttt{\makebox[1.22ex][r]{$ {)} $}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{u}\texttt{\mbox{\hspace{0.50em}}}\texttt{{\char `\=}}\texttt{\mbox{\hspace{0.50em}}}\texttt{substituteOut}\texttt{\mbox{\hspace{0.50em}}}\texttt{x}\texttt{\mbox{\hspace{0.50em}}}\texttt{u}\texttt{\mbox{\hspace{0.50em}}}\texttt{t}\texttt{{\nopagebreak \newline%
}\vphantom{$\{$}}\texttt{app}\texttt{\mbox{\hspace{0.50em}}}\texttt{\makebox[1.22ex][l]{$ {(} $}}\texttt{Neutr}\texttt{\mbox{\hspace{0.50em}}}\texttt{f}\texttt{\mbox{\hspace{0.50em}}}\texttt{ts}\texttt{\makebox[1.22ex][r]{$ {)} $}}\texttt{\mbox{\hspace{0.50em}}}\texttt{u}\texttt{\mbox{\hspace{0.50em}}}\texttt{{\char `\=}}\texttt{\mbox{\hspace{0.50em}}}\texttt{Neutr}\texttt{\mbox{\hspace{0.50em}}}\texttt{f}\texttt{\mbox{\hspace{0.50em}}}\texttt{\makebox[1.22ex][l]{$ {(} $}}\texttt{ts}\texttt{++}\texttt{{[}}\texttt{u}\texttt{{]}}\texttt{\makebox[1.22ex][r]{$ {)} $}}\texttt{{\nopagebreak \newline%
}\vphantom{$\{$}}%


%
%paragraphName:
The normalize is then a simple recursion on the term
    structure{:}%


{\nopagebreak }

%
%code:
%
%comment: norm :: Tm a → No a
%norm (Var x)   = return x
%norm (App t u) = app (norm t) (norm u)
%norm (Lam b)   = unpack b $ \ x t →
%                   LamNo x (norm t)
%
~\\~\vphantom{$\{$}\texttt{norm}\texttt{\mbox{\hspace{0.50em}}}\texttt{{:}{:}}\texttt{\mbox{\hspace{0.50em}}}\texttt{Tm}\texttt{\mbox{\hspace{0.50em}}}\texttt{a}\texttt{\mbox{\hspace{0.50em}}}\texttt{$ \rightarrow $}\texttt{\mbox{\hspace{0.50em}}}\texttt{No}\texttt{\mbox{\hspace{0.50em}}}\texttt{a}\texttt{{\nopagebreak \newline%
}\vphantom{$\{$}}\texttt{norm}\texttt{\mbox{\hspace{0.50em}}}\texttt{\makebox[1.22ex][l]{$ {(} $}}\texttt{Var}\texttt{\mbox{\hspace{0.50em}}}\texttt{x}\texttt{\makebox[1.22ex][r]{$ {)} $}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{{\char `\=}}\texttt{\mbox{\hspace{0.50em}}}\texttt{return}\texttt{\mbox{\hspace{0.50em}}}\texttt{x}\texttt{{\nopagebreak \newline%
}\vphantom{$\{$}}\texttt{norm}\texttt{\mbox{\hspace{0.50em}}}\texttt{\makebox[1.22ex][l]{$ {(} $}}\texttt{App}\texttt{\mbox{\hspace{0.50em}}}\texttt{t}\texttt{\mbox{\hspace{0.50em}}}\texttt{u}\texttt{\makebox[1.22ex][r]{$ {)} $}}\texttt{\mbox{\hspace{0.50em}}}\texttt{{\char `\=}}\texttt{\mbox{\hspace{0.50em}}}\texttt{app}\texttt{\mbox{\hspace{0.50em}}}\texttt{\makebox[1.22ex][l]{$ {(} $}}\texttt{norm}\texttt{\mbox{\hspace{0.50em}}}\texttt{t}\texttt{\makebox[1.22ex][r]{$ {)} $}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\makebox[1.22ex][l]{$ {(} $}}\texttt{norm}\texttt{\mbox{\hspace{0.50em}}}\texttt{u}\texttt{\makebox[1.22ex][r]{$ {)} $}}\texttt{{\nopagebreak \newline%
}\vphantom{$\{$}}\texttt{norm}\texttt{\mbox{\hspace{0.50em}}}\texttt{\makebox[1.22ex][l]{$ {(} $}}\texttt{Lam}\texttt{\mbox{\hspace{0.50em}}}\texttt{b}\texttt{\makebox[1.22ex][r]{$ {)} $}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{{\char `\=}}\texttt{\mbox{\hspace{0.50em}}}\texttt{unpack}\texttt{\mbox{\hspace{0.50em}}}\texttt{b}\texttt{\mbox{\hspace{0.50em}}}\texttt{\${}}\texttt{\mbox{\hspace{0.50em}}}\texttt{$ \lambda $}\texttt{\mbox{\hspace{0.50em}}}\texttt{x}\texttt{\mbox{\hspace{0.50em}}}\texttt{t}\texttt{\mbox{\hspace{0.50em}}}\texttt{$ \rightarrow $}\texttt{{\nopagebreak \newline%
}\vphantom{$\{$}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{LamNo}\texttt{\mbox{\hspace{0.50em}}}\texttt{x}\texttt{\mbox{\hspace{0.50em}}}\texttt{\makebox[1.22ex][l]{$ {(} $}}\texttt{norm}\texttt{\mbox{\hspace{0.50em}}}\texttt{t}\texttt{\makebox[1.22ex][r]{$ {)} $}}\texttt{{\nopagebreak \newline%
}\vphantom{$\{$}}%


\subsection{Closure Conversion\label{closureSec}}

%
%paragraphName:
A common phase in the compilation of functional languages is closure conversion. 
    The goal of closure conversion is make explicit the creation and opening of closures, 
    essentially implementing lexical scope. 
    What follows is a definition of closure conversion, as can be found in a textbook 
    (in fact this version is slightly adapted from \citet{guillemette_type-preserving_2007}).
    In it, we use a hat to distinguish
    object-level abstractions ($ \hat\lambda $) from host-level ones.
    Similarly, the $ @ $ sign is used for object-level applications. %


%
%paragraphName:
    The characteristic that interests us in this definition is that it is written in nominal style.
    For instance, it pretends that by matching on a $ \hat \lambda $-abstraction, one obtains a name
    $ x $ and an expression $ e $, and it is silent about the issues of freshness and
    transport of names between contexts. In the rest of the section, we construct an
    implementation which essentially retains
    these characteristics.
  %


\[ 
\begin{array}{r@{\,}l}
  \llbracket x \rrbracket &= x \\
  \llbracket \hat\lambda x. e \rrbracket &= \mathsf{closure}~(\hat\lambda x~x_\mathnormal{env}. e_\mathnormal{body})\, e_\mathnormal{env} \\
                                         &\quad \quad \mathsf{where}~\begin{array}[t]{l@{\,}l}
                                                                  y_1,\ldots,y_n & = FV(e)-\{x\} \\
                                                                  e_\mathnormal{body} & = \llbracket e \rrbracket[x_{env}.i/y_i] \\
                                                                  e_\mathnormal{env} & = \langle y_1,\ldots,y_n \rangle
                                                               \end{array}\\
  \llbracket e_1@e_2 \rrbracket &= \mathsf{let}~(x_f,x_\mathnormal{env}) = \mathsf{open}~\llbracket e_1 \rrbracket \, \mathsf{in}~ x_f \langle \llbracket e_2 \rrbracket , x_\mathnormal{env} \rangle
\end{array} \]

%
%paragraphName:
The first step in implementing the above function is to define the
    target language. It features variables and applications as usual.
    Most importantly, it has a constructor for \texttt{Closure}s, composed
    of a body and an environment. The body of closures have exactly two
    free variables{:} \texttt{vx} for the parameter of the closure and{~}\texttt{venv}    for its environment.
    These variables are represented
    by two \texttt{UnivScope}s, which we splice in the type of the constructor.
    An environment is realized by a{~}\texttt{Tuple}.
    Inside the closure, elements of the environment are accessed via
    their{~}\texttt{Index} in the tuple. Finally, the{~}\texttt{LetOpen} construction
    allows to access the components of a closure (its first argument)
    in an arbitrary expression (its second argument). This arbitrary
    expression has two extra free variables{:} \texttt{vf} for the code of the
    closure and{~}\texttt{venv} for its environment.
     %


{\nopagebreak }

%
%code:
%
%comment: data LC a where
%  VarLC :: a → LC a
%  AppLC :: LC a → LC a → LC a
%  Closure :: (∀ vx venv. vx → venv →
%           LC (Zero :▹ venv :▹ vx)) →
%           LC a → LC a
%  Tuple :: [LC a] → LC a
%  Index :: LC a → Int → LC a
%  LetOpen :: LC a → (∀ vf venv. vf → venv →
%                     LC (a :▹ vf :▹ venv)) → LC a
%
~\\~\vphantom{$\{$}\texttt{data}\texttt{\mbox{\hspace{0.50em}}}\texttt{LC}\texttt{\mbox{\hspace{0.50em}}}\texttt{a}\texttt{\mbox{\hspace{0.50em}}}\texttt{where}\texttt{{\nopagebreak \newline%
}\vphantom{$\{$}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{VarLC}\texttt{\mbox{\hspace{0.50em}}}\texttt{{:}{:}}\texttt{\mbox{\hspace{0.50em}}}\texttt{a}\texttt{\mbox{\hspace{0.50em}}}\texttt{$ \rightarrow $}\texttt{\mbox{\hspace{0.50em}}}\texttt{LC}\texttt{\mbox{\hspace{0.50em}}}\texttt{a}\texttt{{\nopagebreak \newline%
}\vphantom{$\{$}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{AppLC}\texttt{\mbox{\hspace{0.50em}}}\texttt{{:}{:}}\texttt{\mbox{\hspace{0.50em}}}\texttt{LC}\texttt{\mbox{\hspace{0.50em}}}\texttt{a}\texttt{\mbox{\hspace{0.50em}}}\texttt{$ \rightarrow $}\texttt{\mbox{\hspace{0.50em}}}\texttt{LC}\texttt{\mbox{\hspace{0.50em}}}\texttt{a}\texttt{\mbox{\hspace{0.50em}}}\texttt{$ \rightarrow $}\texttt{\mbox{\hspace{0.50em}}}\texttt{LC}\texttt{\mbox{\hspace{0.50em}}}\texttt{a}\texttt{{\nopagebreak \newline%
}\vphantom{$\{$}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{Closure}\texttt{\mbox{\hspace{0.50em}}}\texttt{{:}{:}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\makebox[1.22ex][l]{$ {(} $}}\texttt{\makebox[1.22ex][c]{$ \forall $}}\texttt{\mbox{\hspace{0.50em}}}\texttt{vx}\texttt{\mbox{\hspace{0.50em}}}\texttt{venv}\texttt{.}\texttt{\mbox{\hspace{0.50em}}}\texttt{vx}\texttt{\mbox{\hspace{0.50em}}}\texttt{$ \rightarrow $}\texttt{\mbox{\hspace{0.50em}}}\texttt{venv}\texttt{\mbox{\hspace{0.50em}}}\texttt{$ \rightarrow $}\texttt{{\nopagebreak \newline%
}\vphantom{$\{$}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{LC}\texttt{\mbox{\hspace{0.50em}}}\texttt{\makebox[1.22ex][l]{$ {(} $}}\texttt{Zero}\texttt{\mbox{\hspace{0.50em}}}\texttt{$ \vartriangleright $}\texttt{\mbox{\hspace{0.50em}}}\texttt{venv}\texttt{\mbox{\hspace{0.50em}}}\texttt{$ \vartriangleright $}\texttt{\mbox{\hspace{0.50em}}}\texttt{vx}\texttt{\makebox[1.22ex][r]{$ {)} $}}\texttt{\makebox[1.22ex][r]{$ {)} $}}\texttt{\mbox{\hspace{0.50em}}}\texttt{$ \rightarrow $}\texttt{{\nopagebreak \newline%
}\vphantom{$\{$}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{LC}\texttt{\mbox{\hspace{0.50em}}}\texttt{a}\texttt{\mbox{\hspace{0.50em}}}\texttt{$ \rightarrow $}\texttt{\mbox{\hspace{0.50em}}}\texttt{LC}\texttt{\mbox{\hspace{0.50em}}}\texttt{a}\texttt{{\nopagebreak \newline%
}\vphantom{$\{$}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{Tuple}\texttt{\mbox{\hspace{0.50em}}}\texttt{{:}{:}}\texttt{\mbox{\hspace{0.50em}}}\texttt{{[}}\texttt{LC}\texttt{\mbox{\hspace{0.50em}}}\texttt{a}\texttt{{]}}\texttt{\mbox{\hspace{0.50em}}}\texttt{$ \rightarrow $}\texttt{\mbox{\hspace{0.50em}}}\texttt{LC}\texttt{\mbox{\hspace{0.50em}}}\texttt{a}\texttt{{\nopagebreak \newline%
}\vphantom{$\{$}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{Index}\texttt{\mbox{\hspace{0.50em}}}\texttt{{:}{:}}\texttt{\mbox{\hspace{0.50em}}}\texttt{LC}\texttt{\mbox{\hspace{0.50em}}}\texttt{a}\texttt{\mbox{\hspace{0.50em}}}\texttt{$ \rightarrow $}\texttt{\mbox{\hspace{0.50em}}}\texttt{Int}\texttt{\mbox{\hspace{0.50em}}}\texttt{$ \rightarrow $}\texttt{\mbox{\hspace{0.50em}}}\texttt{LC}\texttt{\mbox{\hspace{0.50em}}}\texttt{a}\texttt{{\nopagebreak \newline%
}\vphantom{$\{$}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{LetOpen}\texttt{\mbox{\hspace{0.50em}}}\texttt{{:}{:}}\texttt{\mbox{\hspace{0.50em}}}\texttt{LC}\texttt{\mbox{\hspace{0.50em}}}\texttt{a}\texttt{\mbox{\hspace{0.50em}}}\texttt{$ \rightarrow $}\texttt{\mbox{\hspace{0.50em}}}\texttt{\makebox[1.22ex][l]{$ {(} $}}\texttt{\makebox[1.22ex][c]{$ \forall $}}\texttt{\mbox{\hspace{0.50em}}}\texttt{vf}\texttt{\mbox{\hspace{0.50em}}}\texttt{venv}\texttt{.}\texttt{\mbox{\hspace{0.50em}}}\texttt{vf}\texttt{\mbox{\hspace{0.50em}}}\texttt{$ \rightarrow $}\texttt{\mbox{\hspace{0.50em}}}\texttt{venv}\texttt{\mbox{\hspace{0.50em}}}\texttt{$ \rightarrow $}\texttt{{\nopagebreak \newline%
}\vphantom{$\{$}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{LC}\texttt{\mbox{\hspace{0.50em}}}\texttt{\makebox[1.22ex][l]{$ {(} $}}\texttt{a}\texttt{\mbox{\hspace{0.50em}}}\texttt{$ \vartriangleright $}\texttt{\mbox{\hspace{0.50em}}}\texttt{vf}\texttt{\mbox{\hspace{0.50em}}}\texttt{$ \vartriangleright $}\texttt{\mbox{\hspace{0.50em}}}\texttt{venv}\texttt{\makebox[1.22ex][r]{$ {)} $}}\texttt{\makebox[1.22ex][r]{$ {)} $}}\texttt{\mbox{\hspace{0.50em}}}\texttt{$ \rightarrow $}\texttt{\mbox{\hspace{0.50em}}}\texttt{LC}\texttt{\mbox{\hspace{0.50em}}}\texttt{a}\texttt{{\nopagebreak \newline%
}\vphantom{$\{$}}%


%
%paragraphName:
This representation is an instance of{~}\texttt{Functor} and{~}\texttt{Monad}, and
    the corresponding code offers no surprise.
    We give an infix alias for{~}\texttt{AppLC}, named{~}\texttt{\${}\${}}.%


%
%paragraphName:
Closure conversion can then be implemented as a function
    from{~}\texttt{Tm}\texttt{\mbox{\hspace{0.50em}}}\texttt{a} to{~}\texttt{LC}\texttt{\mbox{\hspace{0.50em}}}\texttt{a}. The case of variables is trivial. For
    an abstraction, one must construct a closure, whose environment
    contains each of the free variables in the body. The application
    must open the closure, explicitly applying the argument and the
    environment.%


%
%paragraphName:
The implementation closely follows the mathematical definition
    given above. The work to manage variables explicitly is limited
    to the lifting of the substitution $ [x_{env}.i/y_i] $, and an
    application of \texttt{wk}. Additionally, the substitution performed
    by{~}\texttt{wk} is inferred automatically by GHC.%


{\nopagebreak }

%
%code:
%
%comment: cc :: Eq a ⇒ Tm a → LC a
%cc (Var x) = VarLC x
%cc t0@(Lam b) =
%  let yn = nub $ freeVars t0
%  in Closure (\ x env → cc (b `atVar` x) >>=
%                   liftSubst x (idxFrom yn env))
%             (Tuple $ map VarLC yn)
%cc (App e1 e2) =
%  LetOpen (cc e1)
%          (\ f x → var f $$ wk (cc e2) $$ var x)
%
~\\~\vphantom{$\{$}\texttt{cc}\texttt{\mbox{\hspace{0.50em}}}\texttt{{:}{:}}\texttt{\mbox{\hspace{0.50em}}}\texttt{Eq}\texttt{\mbox{\hspace{0.50em}}}\texttt{a}\texttt{\mbox{\hspace{0.50em}}}\texttt{$ \Rightarrow $}\texttt{\mbox{\hspace{0.50em}}}\texttt{Tm}\texttt{\mbox{\hspace{0.50em}}}\texttt{a}\texttt{\mbox{\hspace{0.50em}}}\texttt{$ \rightarrow $}\texttt{\mbox{\hspace{0.50em}}}\texttt{LC}\texttt{\mbox{\hspace{0.50em}}}\texttt{a}\texttt{{\nopagebreak \newline%
}\vphantom{$\{$}}\texttt{cc}\texttt{\mbox{\hspace{0.50em}}}\texttt{\makebox[1.22ex][l]{$ {(} $}}\texttt{Var}\texttt{\mbox{\hspace{0.50em}}}\texttt{x}\texttt{\makebox[1.22ex][r]{$ {)} $}}\texttt{\mbox{\hspace{0.50em}}}\texttt{{\char `\=}}\texttt{\mbox{\hspace{0.50em}}}\texttt{VarLC}\texttt{\mbox{\hspace{0.50em}}}\texttt{x}\texttt{{\nopagebreak \newline%
}\vphantom{$\{$}}\texttt{cc}\texttt{\mbox{\hspace{0.50em}}}\texttt{t0}\texttt{@}\texttt{\makebox[1.22ex][l]{$ {(} $}}\texttt{Lam}\texttt{\mbox{\hspace{0.50em}}}\texttt{b}\texttt{\makebox[1.22ex][r]{$ {)} $}}\texttt{\mbox{\hspace{0.50em}}}\texttt{{\char `\=}}\texttt{{\nopagebreak \newline%
}\vphantom{$\{$}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{let}\texttt{\mbox{\hspace{0.50em}}}\texttt{yn}\texttt{\mbox{\hspace{0.50em}}}\texttt{{\char `\=}}\texttt{\mbox{\hspace{0.50em}}}\texttt{nub}\texttt{\mbox{\hspace{0.50em}}}\texttt{\${}}\texttt{\mbox{\hspace{0.50em}}}\texttt{freeVars}\texttt{\mbox{\hspace{0.50em}}}\texttt{t0}\texttt{{\nopagebreak \newline%
}\vphantom{$\{$}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{in}\texttt{\mbox{\hspace{0.50em}}}\texttt{Closure}\texttt{\mbox{\hspace{0.50em}}}\texttt{\makebox[1.22ex][l]{$ {(} $}}\texttt{$ \lambda $}\texttt{\mbox{\hspace{0.50em}}}\texttt{x}\texttt{\mbox{\hspace{0.50em}}}\texttt{env}\texttt{\mbox{\hspace{0.50em}}}\texttt{$ \rightarrow $}\texttt{\mbox{\hspace{0.50em}}}\texttt{cc}\texttt{\mbox{\hspace{0.50em}}}\texttt{\makebox[1.22ex][l]{$ {(} $}}\texttt{b}\texttt{\mbox{\hspace{0.50em}}}\texttt{{`}atVar{`}}\texttt{\mbox{\hspace{0.50em}}}\texttt{x}\texttt{\makebox[1.22ex][r]{$ {)} $}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\makebox[1.22ex][c]{\textgreater{}}\makebox[1.22ex][c]{\textgreater{}}{\char `\=}}\texttt{{\nopagebreak \newline%
}\vphantom{$\{$}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{liftSubst}\texttt{\mbox{\hspace{0.50em}}}\texttt{x}\texttt{\mbox{\hspace{0.50em}}}\texttt{\makebox[1.22ex][l]{$ {(} $}}\texttt{idxFrom}\texttt{\mbox{\hspace{0.50em}}}\texttt{yn}\texttt{\mbox{\hspace{0.50em}}}\texttt{env}\texttt{\makebox[1.22ex][r]{$ {)} $}}\texttt{\makebox[1.22ex][r]{$ {)} $}}\texttt{{\nopagebreak \newline%
}\vphantom{$\{$}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\makebox[1.22ex][l]{$ {(} $}}\texttt{Tuple}\texttt{\mbox{\hspace{0.50em}}}\texttt{\${}}\texttt{\mbox{\hspace{0.50em}}}\texttt{map}\texttt{\mbox{\hspace{0.50em}}}\texttt{VarLC}\texttt{\mbox{\hspace{0.50em}}}\texttt{yn}\texttt{\makebox[1.22ex][r]{$ {)} $}}\texttt{{\nopagebreak \newline%
}\vphantom{$\{$}}\texttt{cc}\texttt{\mbox{\hspace{0.50em}}}\texttt{\makebox[1.22ex][l]{$ {(} $}}\texttt{App}\texttt{\mbox{\hspace{0.50em}}}\texttt{e1}\texttt{\mbox{\hspace{0.50em}}}\texttt{e2}\texttt{\makebox[1.22ex][r]{$ {)} $}}\texttt{\mbox{\hspace{0.50em}}}\texttt{{\char `\=}}\texttt{{\nopagebreak \newline%
}\vphantom{$\{$}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{LetOpen}\texttt{\mbox{\hspace{0.50em}}}\texttt{\makebox[1.22ex][l]{$ {(} $}}\texttt{cc}\texttt{\mbox{\hspace{0.50em}}}\texttt{e1}\texttt{\makebox[1.22ex][r]{$ {)} $}}\texttt{{\nopagebreak \newline%
}\vphantom{$\{$}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\makebox[1.22ex][l]{$ {(} $}}\texttt{$ \lambda $}\texttt{\mbox{\hspace{0.50em}}}\texttt{f}\texttt{\mbox{\hspace{0.50em}}}\texttt{x}\texttt{\mbox{\hspace{0.50em}}}\texttt{$ \rightarrow $}\texttt{\mbox{\hspace{0.50em}}}\texttt{var}\texttt{\mbox{\hspace{0.50em}}}\texttt{f}\texttt{\mbox{\hspace{0.50em}}}\texttt{\${}\${}}\texttt{\mbox{\hspace{0.50em}}}\texttt{wk}\texttt{\mbox{\hspace{0.50em}}}\texttt{\makebox[1.22ex][l]{$ {(} $}}\texttt{cc}\texttt{\mbox{\hspace{0.50em}}}\texttt{e2}\texttt{\makebox[1.22ex][r]{$ {)} $}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\${}\${}}\texttt{\mbox{\hspace{0.50em}}}\texttt{var}\texttt{\mbox{\hspace{0.50em}}}\texttt{x}\texttt{\makebox[1.22ex][r]{$ {)} $}}\texttt{{\nopagebreak \newline%
}\vphantom{$\{$}}%


%
%paragraphName:
A notable difference between the above implementation and that of
    \citeauthor{guillemette_type-preserving_2007} is the following.
    They first modify the
    function to take an additional substitution argument, citing the
    difficulty to support a direct implementation with de{~}Bruijn
    indices. We need not do any such modification{:} our interface is
    natural enough to support a direct implementation of the algorithm.%


\subsection{CPS Transform\label{cpsSec}}

%
%paragraphName: intro
The next example is a transformation to continuation-passing
    style (CPS) based partially on work by \citet{chlipala_parametric_2008} and
    \citet{guillemette_type-preserving_2008}.
    The main objective of the transformation is to make the
    order of evaluation explicit, by $ \mathsf{let} $-binding every intermediate{~}\texttt{Value} in
    a specific order. To this end, we target a special representation,
    where every intermediate result is named. We allow for{~}\texttt{Value}s to be
    pairs, so we can easily replace each argument with a pair of an
    argument and a continuation.%


{\nopagebreak }

%
%code:
%
%comment: data TmC a where
%  HaltC :: Value a → TmC a
%  AppC  :: Value a → Value a → TmC a
%  LetC  :: Value a → TmC (Succ a) → TmC a
%
%data Value a where
%  LamC  :: TmC (Succ a) → Value a
%  PairC :: Value a → Value a → Value a
%  VarC  :: a → Value a
%  FstC  :: a → Value a
%  SndC  :: a → Value a
%
~\\~\vphantom{$\{$}\texttt{data}\texttt{\mbox{\hspace{0.50em}}}\texttt{TmC}\texttt{\mbox{\hspace{0.50em}}}\texttt{a}\texttt{\mbox{\hspace{0.50em}}}\texttt{where}\texttt{{\nopagebreak \newline%
}\vphantom{$\{$}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{HaltC}\texttt{\mbox{\hspace{0.50em}}}\texttt{{:}{:}}\texttt{\mbox{\hspace{0.50em}}}\texttt{Value}\texttt{\mbox{\hspace{0.50em}}}\texttt{a}\texttt{\mbox{\hspace{0.50em}}}\texttt{$ \rightarrow $}\texttt{\mbox{\hspace{0.50em}}}\texttt{TmC}\texttt{\mbox{\hspace{0.50em}}}\texttt{a}\texttt{{\nopagebreak \newline%
}\vphantom{$\{$}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{AppC}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{{:}{:}}\texttt{\mbox{\hspace{0.50em}}}\texttt{Value}\texttt{\mbox{\hspace{0.50em}}}\texttt{a}\texttt{\mbox{\hspace{0.50em}}}\texttt{$ \rightarrow $}\texttt{\mbox{\hspace{0.50em}}}\texttt{Value}\texttt{\mbox{\hspace{0.50em}}}\texttt{a}\texttt{\mbox{\hspace{0.50em}}}\texttt{$ \rightarrow $}\texttt{\mbox{\hspace{0.50em}}}\texttt{TmC}\texttt{\mbox{\hspace{0.50em}}}\texttt{a}\texttt{{\nopagebreak \newline%
}\vphantom{$\{$}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{LetC}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{{:}{:}}\texttt{\mbox{\hspace{0.50em}}}\texttt{Value}\texttt{\mbox{\hspace{0.50em}}}\texttt{a}\texttt{\mbox{\hspace{0.50em}}}\texttt{$ \rightarrow $}\texttt{\mbox{\hspace{0.50em}}}\texttt{TmC}\texttt{\mbox{\hspace{0.50em}}}\texttt{\makebox[1.22ex][l]{$ {(} $}}\texttt{Succ}\texttt{\mbox{\hspace{0.50em}}}\texttt{a}\texttt{\makebox[1.22ex][r]{$ {)} $}}\texttt{\mbox{\hspace{0.50em}}}\texttt{$ \rightarrow $}\texttt{\mbox{\hspace{0.50em}}}\texttt{TmC}\texttt{\mbox{\hspace{0.50em}}}\texttt{a}\texttt{{\nopagebreak \newline%
}\vphantom{$\{$}}\texttt{{\nopagebreak \newline%
}\vphantom{$\{$}}\texttt{data}\texttt{\mbox{\hspace{0.50em}}}\texttt{Value}\texttt{\mbox{\hspace{0.50em}}}\texttt{a}\texttt{\mbox{\hspace{0.50em}}}\texttt{where}\texttt{{\nopagebreak \newline%
}\vphantom{$\{$}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{LamC}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{{:}{:}}\texttt{\mbox{\hspace{0.50em}}}\texttt{TmC}\texttt{\mbox{\hspace{0.50em}}}\texttt{\makebox[1.22ex][l]{$ {(} $}}\texttt{Succ}\texttt{\mbox{\hspace{0.50em}}}\texttt{a}\texttt{\makebox[1.22ex][r]{$ {)} $}}\texttt{\mbox{\hspace{0.50em}}}\texttt{$ \rightarrow $}\texttt{\mbox{\hspace{0.50em}}}\texttt{Value}\texttt{\mbox{\hspace{0.50em}}}\texttt{a}\texttt{{\nopagebreak \newline%
}\vphantom{$\{$}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{PairC}\texttt{\mbox{\hspace{0.50em}}}\texttt{{:}{:}}\texttt{\mbox{\hspace{0.50em}}}\texttt{Value}\texttt{\mbox{\hspace{0.50em}}}\texttt{a}\texttt{\mbox{\hspace{0.50em}}}\texttt{$ \rightarrow $}\texttt{\mbox{\hspace{0.50em}}}\texttt{Value}\texttt{\mbox{\hspace{0.50em}}}\texttt{a}\texttt{\mbox{\hspace{0.50em}}}\texttt{$ \rightarrow $}\texttt{\mbox{\hspace{0.50em}}}\texttt{Value}\texttt{\mbox{\hspace{0.50em}}}\texttt{a}\texttt{{\nopagebreak \newline%
}\vphantom{$\{$}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{VarC}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{{:}{:}}\texttt{\mbox{\hspace{0.50em}}}\texttt{a}\texttt{\mbox{\hspace{0.50em}}}\texttt{$ \rightarrow $}\texttt{\mbox{\hspace{0.50em}}}\texttt{Value}\texttt{\mbox{\hspace{0.50em}}}\texttt{a}\texttt{{\nopagebreak \newline%
}\vphantom{$\{$}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{FstC}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{{:}{:}}\texttt{\mbox{\hspace{0.50em}}}\texttt{a}\texttt{\mbox{\hspace{0.50em}}}\texttt{$ \rightarrow $}\texttt{\mbox{\hspace{0.50em}}}\texttt{Value}\texttt{\mbox{\hspace{0.50em}}}\texttt{a}\texttt{{\nopagebreak \newline%
}\vphantom{$\{$}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{SndC}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{{:}{:}}\texttt{\mbox{\hspace{0.50em}}}\texttt{a}\texttt{\mbox{\hspace{0.50em}}}\texttt{$ \rightarrow $}\texttt{\mbox{\hspace{0.50em}}}\texttt{Value}\texttt{\mbox{\hspace{0.50em}}}\texttt{a}\texttt{{\nopagebreak \newline%
}\vphantom{$\{$}}%


%
%paragraphName: smart constructors
We do not use \texttt{Value}s directly, but instead their composition with injection.%


{\nopagebreak }

%
%code:
%
%comment: varC :: (v :∈ a) ⇒ v → Value a
%letC :: Value a → UnivScope TmC a → TmC a
%lamC :: UnivScope TmC a → Value a
%fstC :: (v :∈ a) ⇒ v → Value a
%sndC :: (v :∈ a) ⇒ v → Value a
%
~\\~\vphantom{$\{$}\texttt{varC}\texttt{\mbox{\hspace{0.50em}}}\texttt{{:}{:}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\makebox[1.22ex][l]{$ {(} $}}\texttt{v}\texttt{\mbox{\hspace{0.50em}}}\texttt{\makebox[1.22ex][c]{$ \in $}}\texttt{\mbox{\hspace{0.50em}}}\texttt{a}\texttt{\makebox[1.22ex][r]{$ {)} $}}\texttt{\mbox{\hspace{0.50em}}}\texttt{$ \Rightarrow $}\texttt{\mbox{\hspace{0.50em}}}\texttt{v}\texttt{\mbox{\hspace{0.50em}}}\texttt{$ \rightarrow $}\texttt{\mbox{\hspace{0.50em}}}\texttt{Value}\texttt{\mbox{\hspace{0.50em}}}\texttt{a}\texttt{{\nopagebreak \newline%
}\vphantom{$\{$}}\texttt{letC}\texttt{\mbox{\hspace{0.50em}}}\texttt{{:}{:}}\texttt{\mbox{\hspace{0.50em}}}\texttt{Value}\texttt{\mbox{\hspace{0.50em}}}\texttt{a}\texttt{\mbox{\hspace{0.50em}}}\texttt{$ \rightarrow $}\texttt{\mbox{\hspace{0.50em}}}\texttt{UnivScope}\texttt{\mbox{\hspace{0.50em}}}\texttt{TmC}\texttt{\mbox{\hspace{0.50em}}}\texttt{a}\texttt{\mbox{\hspace{0.50em}}}\texttt{$ \rightarrow $}\texttt{\mbox{\hspace{0.50em}}}\texttt{TmC}\texttt{\mbox{\hspace{0.50em}}}\texttt{a}\texttt{{\nopagebreak \newline%
}\vphantom{$\{$}}\texttt{lamC}\texttt{\mbox{\hspace{0.50em}}}\texttt{{:}{:}}\texttt{\mbox{\hspace{0.50em}}}\texttt{UnivScope}\texttt{\mbox{\hspace{0.50em}}}\texttt{TmC}\texttt{\mbox{\hspace{0.50em}}}\texttt{a}\texttt{\mbox{\hspace{0.50em}}}\texttt{$ \rightarrow $}\texttt{\mbox{\hspace{0.50em}}}\texttt{Value}\texttt{\mbox{\hspace{0.50em}}}\texttt{a}\texttt{{\nopagebreak \newline%
}\vphantom{$\{$}}\texttt{fstC}\texttt{\mbox{\hspace{0.50em}}}\texttt{{:}{:}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\makebox[1.22ex][l]{$ {(} $}}\texttt{v}\texttt{\mbox{\hspace{0.50em}}}\texttt{\makebox[1.22ex][c]{$ \in $}}\texttt{\mbox{\hspace{0.50em}}}\texttt{a}\texttt{\makebox[1.22ex][r]{$ {)} $}}\texttt{\mbox{\hspace{0.50em}}}\texttt{$ \Rightarrow $}\texttt{\mbox{\hspace{0.50em}}}\texttt{v}\texttt{\mbox{\hspace{0.50em}}}\texttt{$ \rightarrow $}\texttt{\mbox{\hspace{0.50em}}}\texttt{Value}\texttt{\mbox{\hspace{0.50em}}}\texttt{a}\texttt{{\nopagebreak \newline%
}\vphantom{$\{$}}\texttt{sndC}\texttt{\mbox{\hspace{0.50em}}}\texttt{{:}{:}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\makebox[1.22ex][l]{$ {(} $}}\texttt{v}\texttt{\mbox{\hspace{0.50em}}}\texttt{\makebox[1.22ex][c]{$ \in $}}\texttt{\mbox{\hspace{0.50em}}}\texttt{a}\texttt{\makebox[1.22ex][r]{$ {)} $}}\texttt{\mbox{\hspace{0.50em}}}\texttt{$ \Rightarrow $}\texttt{\mbox{\hspace{0.50em}}}\texttt{v}\texttt{\mbox{\hspace{0.50em}}}\texttt{$ \rightarrow $}\texttt{\mbox{\hspace{0.50em}}}\texttt{Value}\texttt{\mbox{\hspace{0.50em}}}\texttt{a}\texttt{{\nopagebreak \newline%
}\vphantom{$\{$}}%


%
%paragraphName: Functor TmC
Free variables in{~}\texttt{TmC} can be renamed, thus it enjoys a
    functor structure, with a straightforward implementation found
    our online development{~}\cite{namesforfreerepo}. However, this
    new syntax{~}\texttt{TmC} is not stable under substitution. Building a
    monadic structure would be more involved, and is directly tied to
    the transformation we perform and the operational semantics of the
    language, so we omit it.%


%
%paragraphName: the transformation
We implement a one-pass CPS transform (administrative redexes are
    not created). This is done by passing a host-language continuation
    to the transformation. At the top-level the halting continuation
    is used. A definition of the transformation using mathematical
    notation could be written as follows.%


\[ 
\begin{array}{r@{\,}l}
 \llbracket x \rrbracket\,\kappa &= \kappa\,x \\
 \llbracket e_1 \,@\, e_2 \rrbracket\,\kappa &= \llbracket e_1 \rrbracket (\lambda f. \,
                                       \llbracket e_2 \rrbracket (\lambda x. \,
                                       f \, @ \, \langle x, \kappa \rangle ) ) \\
 \llbracket \hat\lambda x. e \rrbracket \kappa &= \mathsf{let}\, f = \hat\lambda p. \begin{array}[t]{l}
                                       \mathsf{let}\, x_1 = \mathsf{fst}\, p \,\mathsf{in}\\
                                       \mathsf{let}\, x_2  = \mathsf{snd}\, p \,\mathsf{in} \\
                                       \llbracket e[x_1/x] \rrbracket (\lambda r.\, x_2 \, @ \, r) \end{array}  \\
                                      &\quad \mathsf{in} \, \kappa\,f
\end{array} \]

%
%paragraphName: latex vs. haskell
The implementation follows the above definition, except for the
    following minor differences. For the{~}\texttt{Lam} case, the only
    deviation is an occurrence of{~}\texttt{wk}. In the{~}\texttt{App} case, we
    have an additional reification of the host-level continuation as a
    proper \texttt{Value} using the{~}\texttt{lamC} function.
    In the variable case, we must pass the variable{~}\texttt{v} to the
    continuation. Doing so yields a value of type{~}\texttt{TmC}\texttt{\mbox{\hspace{0.50em}}}\texttt{\makebox[1.22ex][l]{$ {(} $}}\texttt{a}\texttt{\mbox{\hspace{0.50em}}}\texttt{$ \vartriangleright $}\texttt{\mbox{\hspace{0.50em}}}\texttt{a}\texttt{\makebox[1.22ex][r]{$ {)} $}}.
    To obtain a result of the right type it suffices to remove the
    extra tagging introduced by{~}\texttt{a}\texttt{\mbox{\hspace{0.50em}}}\texttt{$ \vartriangleright $}\texttt{\mbox{\hspace{0.50em}}}\texttt{a} everywhere in the term,
    using{~}\texttt{\makebox[1.22ex][l]{$ {(} $}}\texttt{untag}\texttt{\mbox{\hspace{0.50em}}}\texttt{\makebox[1.22ex][c]{\textless{}}\${}\makebox[1.22ex][c]{\textgreater{}}}\texttt{\makebox[1.22ex][r]{$ {)} $}}. The function{~}\texttt{untag} simply removes
    the{~}\texttt{Old}/\texttt{New} tags and thus has type{~}\texttt{a}\texttt{\mbox{\hspace{0.50em}}}\texttt{$ \vartriangleright $}\texttt{\mbox{\hspace{0.50em}}}\texttt{a}\texttt{\mbox{\hspace{0.50em}}}\texttt{$ \rightarrow $}\texttt{\mbox{\hspace{0.50em}}}\texttt{a}. Besides,
    we use a number of instances of \texttt{wk}, and for each of them GHC is
    able to infer the substitution to perform.%


{\nopagebreak }

%
%code:
%
%comment: cps :: Tm a → (∀ v. v → TmC (a :▹ v)) → TmC a
%cps (Var x)     k = untag <$> k x
%cps (App e1 e2) k =
%  cps e1 $ \ x1 →
%  cps (wk e2) $ \ x2 →
%  varC x1 `AppC` (varC x2 `PairC`
%                  lamC (\ x → wk $ k x))
%cps (Lam e)    k =
%  letC
%    (lamC $ \p →
%       letC (fstC p) $ \ x1 →
%       letC (sndC p) $ \ x2 →
%       cps (wk $ e `atVar` x1) $ \r →
%       varC x2 `AppC` varC r) k
%
~\\~\vphantom{$\{$}\texttt{cps}\texttt{\mbox{\hspace{0.50em}}}\texttt{{:}{:}}\texttt{\mbox{\hspace{0.50em}}}\texttt{Tm}\texttt{\mbox{\hspace{0.50em}}}\texttt{a}\texttt{\mbox{\hspace{0.50em}}}\texttt{$ \rightarrow $}\texttt{\mbox{\hspace{0.50em}}}\texttt{\makebox[1.22ex][l]{$ {(} $}}\texttt{\makebox[1.22ex][c]{$ \forall $}}\texttt{\mbox{\hspace{0.50em}}}\texttt{v}\texttt{.}\texttt{\mbox{\hspace{0.50em}}}\texttt{v}\texttt{\mbox{\hspace{0.50em}}}\texttt{$ \rightarrow $}\texttt{\mbox{\hspace{0.50em}}}\texttt{TmC}\texttt{\mbox{\hspace{0.50em}}}\texttt{\makebox[1.22ex][l]{$ {(} $}}\texttt{a}\texttt{\mbox{\hspace{0.50em}}}\texttt{$ \vartriangleright $}\texttt{\mbox{\hspace{0.50em}}}\texttt{v}\texttt{\makebox[1.22ex][r]{$ {)} $}}\texttt{\makebox[1.22ex][r]{$ {)} $}}\texttt{\mbox{\hspace{0.50em}}}\texttt{$ \rightarrow $}\texttt{\mbox{\hspace{0.50em}}}\texttt{TmC}\texttt{\mbox{\hspace{0.50em}}}\texttt{a}\texttt{{\nopagebreak \newline%
}\vphantom{$\{$}}\texttt{cps}\texttt{\mbox{\hspace{0.50em}}}\texttt{\makebox[1.22ex][l]{$ {(} $}}\texttt{Var}\texttt{\mbox{\hspace{0.50em}}}\texttt{x}\texttt{\makebox[1.22ex][r]{$ {)} $}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{k}\texttt{\mbox{\hspace{0.50em}}}\texttt{{\char `\=}}\texttt{\mbox{\hspace{0.50em}}}\texttt{untag}\texttt{\mbox{\hspace{0.50em}}}\texttt{\makebox[1.22ex][c]{\textless{}}\${}\makebox[1.22ex][c]{\textgreater{}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{k}\texttt{\mbox{\hspace{0.50em}}}\texttt{x}\texttt{{\nopagebreak \newline%
}\vphantom{$\{$}}\texttt{cps}\texttt{\mbox{\hspace{0.50em}}}\texttt{\makebox[1.22ex][l]{$ {(} $}}\texttt{App}\texttt{\mbox{\hspace{0.50em}}}\texttt{e1}\texttt{\mbox{\hspace{0.50em}}}\texttt{e2}\texttt{\makebox[1.22ex][r]{$ {)} $}}\texttt{\mbox{\hspace{0.50em}}}\texttt{k}\texttt{\mbox{\hspace{0.50em}}}\texttt{{\char `\=}}\texttt{{\nopagebreak \newline%
}\vphantom{$\{$}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{cps}\texttt{\mbox{\hspace{0.50em}}}\texttt{e1}\texttt{\mbox{\hspace{0.50em}}}\texttt{\${}}\texttt{\mbox{\hspace{0.50em}}}\texttt{$ \lambda $}\texttt{\mbox{\hspace{0.50em}}}\texttt{x1}\texttt{\mbox{\hspace{0.50em}}}\texttt{$ \rightarrow $}\texttt{{\nopagebreak \newline%
}\vphantom{$\{$}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{cps}\texttt{\mbox{\hspace{0.50em}}}\texttt{\makebox[1.22ex][l]{$ {(} $}}\texttt{wk}\texttt{\mbox{\hspace{0.50em}}}\texttt{e2}\texttt{\makebox[1.22ex][r]{$ {)} $}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\${}}\texttt{\mbox{\hspace{0.50em}}}\texttt{$ \lambda $}\texttt{\mbox{\hspace{0.50em}}}\texttt{x2}\texttt{\mbox{\hspace{0.50em}}}\texttt{$ \rightarrow $}\texttt{{\nopagebreak \newline%
}\vphantom{$\{$}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{varC}\texttt{\mbox{\hspace{0.50em}}}\texttt{x1}\texttt{\mbox{\hspace{0.50em}}}\texttt{{`}AppC{`}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\makebox[1.22ex][l]{$ {(} $}}\texttt{varC}\texttt{\mbox{\hspace{0.50em}}}\texttt{x2}\texttt{\mbox{\hspace{0.50em}}}\texttt{{`}PairC{`}}\texttt{{\nopagebreak \newline%
}\vphantom{$\{$}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{lamC}\texttt{\mbox{\hspace{0.50em}}}\texttt{\makebox[1.22ex][l]{$ {(} $}}\texttt{$ \lambda $}\texttt{\mbox{\hspace{0.50em}}}\texttt{x}\texttt{\mbox{\hspace{0.50em}}}\texttt{$ \rightarrow $}\texttt{\mbox{\hspace{0.50em}}}\texttt{wk}\texttt{\mbox{\hspace{0.50em}}}\texttt{\${}}\texttt{\mbox{\hspace{0.50em}}}\texttt{k}\texttt{\mbox{\hspace{0.50em}}}\texttt{x}\texttt{\makebox[1.22ex][r]{$ {)} $}}\texttt{\makebox[1.22ex][r]{$ {)} $}}\texttt{{\nopagebreak \newline%
}\vphantom{$\{$}}\texttt{cps}\texttt{\mbox{\hspace{0.50em}}}\texttt{\makebox[1.22ex][l]{$ {(} $}}\texttt{Lam}\texttt{\mbox{\hspace{0.50em}}}\texttt{e}\texttt{\makebox[1.22ex][r]{$ {)} $}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{k}\texttt{\mbox{\hspace{0.50em}}}\texttt{{\char `\=}}\texttt{{\nopagebreak \newline%
}\vphantom{$\{$}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{letC}\texttt{{\nopagebreak \newline%
}\vphantom{$\{$}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\makebox[1.22ex][l]{$ {(} $}}\texttt{lamC}\texttt{\mbox{\hspace{0.50em}}}\texttt{\${}}\texttt{\mbox{\hspace{0.50em}}}\texttt{$ \lambda $}\texttt{p}\texttt{\mbox{\hspace{0.50em}}}\texttt{$ \rightarrow $}\texttt{{\nopagebreak \newline%
}\vphantom{$\{$}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{letC}\texttt{\mbox{\hspace{0.50em}}}\texttt{\makebox[1.22ex][l]{$ {(} $}}\texttt{fstC}\texttt{\mbox{\hspace{0.50em}}}\texttt{p}\texttt{\makebox[1.22ex][r]{$ {)} $}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\${}}\texttt{\mbox{\hspace{0.50em}}}\texttt{$ \lambda $}\texttt{\mbox{\hspace{0.50em}}}\texttt{x1}\texttt{\mbox{\hspace{0.50em}}}\texttt{$ \rightarrow $}\texttt{{\nopagebreak \newline%
}\vphantom{$\{$}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{letC}\texttt{\mbox{\hspace{0.50em}}}\texttt{\makebox[1.22ex][l]{$ {(} $}}\texttt{sndC}\texttt{\mbox{\hspace{0.50em}}}\texttt{p}\texttt{\makebox[1.22ex][r]{$ {)} $}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\${}}\texttt{\mbox{\hspace{0.50em}}}\texttt{$ \lambda $}\texttt{\mbox{\hspace{0.50em}}}\texttt{x2}\texttt{\mbox{\hspace{0.50em}}}\texttt{$ \rightarrow $}\texttt{{\nopagebreak \newline%
}\vphantom{$\{$}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{cps}\texttt{\mbox{\hspace{0.50em}}}\texttt{\makebox[1.22ex][l]{$ {(} $}}\texttt{wk}\texttt{\mbox{\hspace{0.50em}}}\texttt{\${}}\texttt{\mbox{\hspace{0.50em}}}\texttt{e}\texttt{\mbox{\hspace{0.50em}}}\texttt{{`}atVar{`}}\texttt{\mbox{\hspace{0.50em}}}\texttt{x1}\texttt{\makebox[1.22ex][r]{$ {)} $}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\${}}\texttt{\mbox{\hspace{0.50em}}}\texttt{$ \lambda $}\texttt{r}\texttt{\mbox{\hspace{0.50em}}}\texttt{$ \rightarrow $}\texttt{{\nopagebreak \newline%
}\vphantom{$\{$}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{varC}\texttt{\mbox{\hspace{0.50em}}}\texttt{x2}\texttt{\mbox{\hspace{0.50em}}}\texttt{{`}AppC{`}}\texttt{\mbox{\hspace{0.50em}}}\texttt{varC}\texttt{\mbox{\hspace{0.50em}}}\texttt{r}\texttt{\makebox[1.22ex][r]{$ {)} $}}\texttt{\mbox{\hspace{0.50em}}}\texttt{k}\texttt{{\nopagebreak \newline%
}\vphantom{$\{$}}%


%
%paragraphName:
It is folklore that a CPS transformation is easier
    to implement with higher-order abstract syntax
    \cite{guillemette_type-preserving_2008,washburn_boxes_2003}. Our
    interface for name abstractions features a form of higher-order
    representation. (Namely, a quantification, over a universally
    quantified type.) However limited, this higher-order aspect is
    enough to allow an easy implementation of the CPS transform.%


\section{Related Work\label{comparison}}

%
%paragraphName:
Representing names and binders in a safe and convenient manner is a
    long-standing issue, with an extensive body of work devoted to it.
    A survey is far beyond the scope of this paper. Hence, we limit our
    comparison to the work that we judge most relevant, or whose contrasts
    with our proposal is the most revealing.%


%
%paragraphName:
However, we do not limit our comparison to interfaces for names and
    binders, but also look at terms representations. Indeed, we have
    noted in sec. \ref{styleSec} that every term representation embodies
    an interface for binders.%


\subsection{\texttt{Fin}}

%
%paragraphName: Fin approach description
Another approach already used and described by{~}\citet{altenkirch-93,mcbride-mckinna-04} is
    to index terms, names, etc. by a number, a bound. This bound is the
    maximum number of distinct free variables allowed in the value. This
    rule is enforced in two parts{:} variables have to be strictly lower
    than their bound, and the bound is incremented by one when crossing
    a name abstraction (a $ \lambda $-abstraction for instance).%


%
%paragraphName: Fin type description
The type{~}\texttt{Fin}\texttt{\mbox{\hspace{0.50em}}}\texttt{n} is used for variables and represents natural
    numbers strictly lower than{~}\texttt{n}. The name \texttt{Fin}\texttt{\mbox{\hspace{0.50em}}}\texttt{n} comes from the
    fact that it defines finite sets of size{~}\texttt{n}.%


%
%paragraphName: Fin/Maybe connection
We can draw a link with Nested Abstract Syntax. Indeed, as with the
    type{~}\texttt{Succ} (\texttt{\makebox[1.22ex][l]{$ {(} $}}\texttt{$ \vartriangleright $}\texttt{\mbox{\hspace{0.50em}}}\texttt{\makebox[1.22ex][l]{$ {(} $}}\texttt{\makebox[1.22ex][r]{$ {)} $}}\texttt{\makebox[1.22ex][r]{$ {)} $}} or \texttt{Maybe}), the type \texttt{Fin}\texttt{\mbox{\hspace{0.50em}}}\texttt{\makebox[1.22ex][l]{$ {(} $}}\texttt{suc}\texttt{\mbox{\hspace{0.50em}}}\texttt{n}\texttt{\makebox[1.22ex][r]{$ {)} $}}    has exactly one more element than the type{~}\texttt{Fin}\texttt{\mbox{\hspace{0.50em}}}\texttt{n}. However, these
    approaches are not equivalent for at least two reasons. Nested
    Abstract Syntax can accept any type to represent variables. This
    makes the structure more like a container and this allows to exhibit
    the substitutive structure of terms as monads. The{~}\texttt{Fin} approach
    has advantages as well{:} the representation is concrete and closer to
    the original approach of de{~}Brujin. In particular the representation
    of free and bound variables is more regular, and it may be more
    amenable to the optimization of variables as machine integers.%


\subsection{Higher-Order Abstract Syntax (HOAS)}

%
%paragraphName:
A way to represent bindings of an object language is via the
    bindings of the host language. One naive translation of this idea
    yields the following term representation{:}%


{\nopagebreak }

%
%code:
%
%comment: data TmH = LamH (TmH → TmH) | AppH TmH TmH
%
~\\~\vphantom{$\{$}\texttt{data}\texttt{\mbox{\hspace{0.50em}}}\texttt{TmH}\texttt{\mbox{\hspace{0.50em}}}\texttt{{\char `\=}}\texttt{\mbox{\hspace{0.50em}}}\texttt{LamH}\texttt{\mbox{\hspace{0.50em}}}\texttt{\makebox[1.22ex][l]{$ {(} $}}\texttt{TmH}\texttt{\mbox{\hspace{0.50em}}}\texttt{$ \rightarrow $}\texttt{\mbox{\hspace{0.50em}}}\texttt{TmH}\texttt{\makebox[1.22ex][r]{$ {)} $}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\makebox[1.22ex][c]{\textbar{}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{AppH}\texttt{\mbox{\hspace{0.50em}}}\texttt{TmH}\texttt{\mbox{\hspace{0.50em}}}\texttt{TmH}\texttt{{\nopagebreak \newline%
}\vphantom{$\{$}}%


%
%paragraphName:
An issue with this kind of representation is the presence of
    so-called {``}exotic terms{''}{:} a function of type \texttt{TmH}\texttt{\mbox{\hspace{0.50em}}}\texttt{$ \rightarrow $}\texttt{\mbox{\hspace{0.50em}}}\texttt{TmH} which
    performs pattern matching on its argument does not necessarily
    represent a term of the object language. A proper realization of the
    HOAS idea should only allow functions which use their argument for
    substitution.%


%
%paragraphName:
It has been observed before that one can implement this restriction
    by using polymorphism. This observation also underlies the safety of
    our{~}\texttt{UnivScope} representation.%


%
%paragraphName:
Another disadvantage of HOAS is the negative occurrence
    of the recursive type, which makes it tricky to analyze
    terms{~}\cite{washburn_boxes_2003}.%


\subsection{Syntax for free}

%
%paragraphName:
\citet{atkey-hoas-09} revisited the polymorphic encoding of the HOAS
    representation of the untyped lambda calculus. By constructing a
    model of System F{'}s parametricity in \textsc{Coq} he could formally prove
    that polymorphism rules out the exotic terms. Name abstractions,
    while represented by computational functions, cannot react to the
    shape of their argument and thus behave as substitutions. Here is
    this representation in \textsc{Haskell}{:}%


{\nopagebreak }

%
%code:
%
%comment: type TmF = ∀ a. ({-lam:-} (a → a) → a)
%             → ({-app:-}  a → a  → a) → a
%
~\\~\vphantom{$\{$}\texttt{type}\texttt{\mbox{\hspace{0.50em}}}\texttt{TmF}\texttt{\mbox{\hspace{0.50em}}}\texttt{{\char `\=}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\makebox[1.22ex][c]{$ \forall $}}\texttt{\mbox{\hspace{0.50em}}}\texttt{a}\texttt{.}\texttt{\mbox{\hspace{0.50em}}}\texttt{\makebox[1.22ex][l]{$ {(} $}}\texttt{\makebox[1.22ex][l]{\{{}}\makebox[1.22ex][c]{-}lam{:}\makebox[1.22ex][c]{-}\makebox[1.22ex][r]{\}{}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\makebox[1.22ex][l]{$ {(} $}}\texttt{a}\texttt{\mbox{\hspace{0.50em}}}\texttt{$ \rightarrow $}\texttt{\mbox{\hspace{0.50em}}}\texttt{a}\texttt{\makebox[1.22ex][r]{$ {)} $}}\texttt{\mbox{\hspace{0.50em}}}\texttt{$ \rightarrow $}\texttt{\mbox{\hspace{0.50em}}}\texttt{a}\texttt{\makebox[1.22ex][r]{$ {)} $}}\texttt{{\nopagebreak \newline%
}\vphantom{$\{$}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{$ \rightarrow $}\texttt{\mbox{\hspace{0.50em}}}\texttt{\makebox[1.22ex][l]{$ {(} $}}\texttt{\makebox[1.22ex][l]{\{{}}\makebox[1.22ex][c]{-}app{:}\makebox[1.22ex][c]{-}\makebox[1.22ex][r]{\}{}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{a}\texttt{\mbox{\hspace{0.50em}}}\texttt{$ \rightarrow $}\texttt{\mbox{\hspace{0.50em}}}\texttt{a}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{$ \rightarrow $}\texttt{\mbox{\hspace{0.50em}}}\texttt{a}\texttt{\makebox[1.22ex][r]{$ {)} $}}\texttt{\mbox{\hspace{0.50em}}}\texttt{$ \rightarrow $}\texttt{\mbox{\hspace{0.50em}}}\texttt{a}\texttt{{\nopagebreak \newline%
}\vphantom{$\{$}}%


%
%paragraphName:
And our familiar application function{:}%


{\nopagebreak }

%
%code:
%
%comment: apTmF :: TmF
%apTmF lam app = lam $ \ f → lam $ \ x → f `app` x
%
~\\~\vphantom{$\{$}\texttt{apTmF}\texttt{\mbox{\hspace{0.50em}}}\texttt{{:}{:}}\texttt{\mbox{\hspace{0.50em}}}\texttt{TmF}\texttt{{\nopagebreak \newline%
}\vphantom{$\{$}}\texttt{apTmF}\texttt{\mbox{\hspace{0.50em}}}\texttt{lam}\texttt{\mbox{\hspace{0.50em}}}\texttt{app}\texttt{\mbox{\hspace{0.50em}}}\texttt{{\char `\=}}\texttt{\mbox{\hspace{0.50em}}}\texttt{lam}\texttt{\mbox{\hspace{0.50em}}}\texttt{\${}}\texttt{\mbox{\hspace{0.50em}}}\texttt{$ \lambda $}\texttt{\mbox{\hspace{0.50em}}}\texttt{f}\texttt{\mbox{\hspace{0.50em}}}\texttt{$ \rightarrow $}\texttt{\mbox{\hspace{0.50em}}}\texttt{lam}\texttt{\mbox{\hspace{0.50em}}}\texttt{\${}}\texttt{\mbox{\hspace{0.50em}}}\texttt{$ \lambda $}\texttt{\mbox{\hspace{0.50em}}}\texttt{x}\texttt{\mbox{\hspace{0.50em}}}\texttt{$ \rightarrow $}\texttt{\mbox{\hspace{0.50em}}}\texttt{f}\texttt{\mbox{\hspace{0.50em}}}\texttt{{`}app{`}}\texttt{\mbox{\hspace{0.50em}}}\texttt{x}\texttt{{\nopagebreak \newline%
}\vphantom{$\{$}}%


%
%paragraphName: catamorphism only & can't go back
Being a polymorphic encoding, this technique is limited to analyze
    terms via folds (catamorphism). Indeed, there is no known safe
    way to convert a term of this polymorphic encoding to another
    safe representation of names. As Atkey shows, this conversion
    relies on the Kripke version of the parametricity result of this
    type. (At the moment, the attempts to integrate parametricity in
    a programming language only support non-Kripke versions \cite{keller_parametricity_2012,bernardy_computational_2012,bernardy_type-theory_2013}.)%


\subsection{Parametric Higher-Order Abstract Syntax (PHOAS)}

%
%paragraphName:
\citet{chlipala_parametric_2008} describes a way to represent binders
    using polymorphism and functions. Using that technique, called
    Parametric Higher-Order Abstract Syntax (PHOAS), terms of the
    untyped $ \lambda $-calculus are represented as follows{:}%


{\nopagebreak }

%
%code:
%
%comment: data TmP a where
%  VarP :: a → TmP a
%  LamP :: (a → TmP a) → TmP a
%  AppP :: TmP a → TmP a → TmP a
%
%type TmP' = ∀ a. TmP a
%
~\\~\vphantom{$\{$}\texttt{data}\texttt{\mbox{\hspace{0.50em}}}\texttt{TmP}\texttt{\mbox{\hspace{0.50em}}}\texttt{a}\texttt{\mbox{\hspace{0.50em}}}\texttt{where}\texttt{{\nopagebreak \newline%
}\vphantom{$\{$}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{VarP}\texttt{\mbox{\hspace{0.50em}}}\texttt{{:}{:}}\texttt{\mbox{\hspace{0.50em}}}\texttt{a}\texttt{\mbox{\hspace{0.50em}}}\texttt{$ \rightarrow $}\texttt{\mbox{\hspace{0.50em}}}\texttt{TmP}\texttt{\mbox{\hspace{0.50em}}}\texttt{a}\texttt{{\nopagebreak \newline%
}\vphantom{$\{$}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{LamP}\texttt{\mbox{\hspace{0.50em}}}\texttt{{:}{:}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\makebox[1.22ex][l]{$ {(} $}}\texttt{a}\texttt{\mbox{\hspace{0.50em}}}\texttt{$ \rightarrow $}\texttt{\mbox{\hspace{0.50em}}}\texttt{TmP}\texttt{\mbox{\hspace{0.50em}}}\texttt{a}\texttt{\makebox[1.22ex][r]{$ {)} $}}\texttt{\mbox{\hspace{0.50em}}}\texttt{$ \rightarrow $}\texttt{\mbox{\hspace{0.50em}}}\texttt{TmP}\texttt{\mbox{\hspace{0.50em}}}\texttt{a}\texttt{{\nopagebreak \newline%
}\vphantom{$\{$}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{AppP}\texttt{\mbox{\hspace{0.50em}}}\texttt{{:}{:}}\texttt{\mbox{\hspace{0.50em}}}\texttt{TmP}\texttt{\mbox{\hspace{0.50em}}}\texttt{a}\texttt{\mbox{\hspace{0.50em}}}\texttt{$ \rightarrow $}\texttt{\mbox{\hspace{0.50em}}}\texttt{TmP}\texttt{\mbox{\hspace{0.50em}}}\texttt{a}\texttt{\mbox{\hspace{0.50em}}}\texttt{$ \rightarrow $}\texttt{\mbox{\hspace{0.50em}}}\texttt{TmP}\texttt{\mbox{\hspace{0.50em}}}\texttt{a}\texttt{{\nopagebreak \newline%
}\vphantom{$\{$}}\texttt{{\nopagebreak \newline%
}\vphantom{$\{$}}\texttt{type}\texttt{\mbox{\hspace{0.50em}}}\texttt{TmP{'}}\texttt{\mbox{\hspace{0.50em}}}\texttt{{\char `\=}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\makebox[1.22ex][c]{$ \forall $}}\texttt{\mbox{\hspace{0.50em}}}\texttt{a}\texttt{.}\texttt{\mbox{\hspace{0.50em}}}\texttt{TmP}\texttt{\mbox{\hspace{0.50em}}}\texttt{a}\texttt{{\nopagebreak \newline%
}\vphantom{$\{$}}%


%
%paragraphName:
Only universally quantified terms{~}(\texttt{TmP{'}}) are guaranteed to
    correspond to terms of the $ \lambda $-calculus.%


%
%paragraphName:
The representation of binders used by Chlipala can be seen as
    a special version of \texttt{UnivScope}, where all variables are
    assigned the same type. This specialization has pros and cons. On
    the plus side, substitution is easier to implement with PHOAS{:}
    fresh variables do not need special treatment. The corresponding
    implementation of the monadic \texttt{join} is as follows{:}%


{\nopagebreak }

%
%code:
%
%comment: joinP (VarP x)   = x
%joinP (LamP f)   = LamP (\ x → joinP (f (VarP x)))
%joinP (AppP t u) = AppP (joinP t) (joinP u)
%
~\\~\vphantom{$\{$}\texttt{joinP}\texttt{\mbox{\hspace{0.50em}}}\texttt{\makebox[1.22ex][l]{$ {(} $}}\texttt{VarP}\texttt{\mbox{\hspace{0.50em}}}\texttt{x}\texttt{\makebox[1.22ex][r]{$ {)} $}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{{\char `\=}}\texttt{\mbox{\hspace{0.50em}}}\texttt{x}\texttt{{\nopagebreak \newline%
}\vphantom{$\{$}}\texttt{joinP}\texttt{\mbox{\hspace{0.50em}}}\texttt{\makebox[1.22ex][l]{$ {(} $}}\texttt{LamP}\texttt{\mbox{\hspace{0.50em}}}\texttt{f}\texttt{\makebox[1.22ex][r]{$ {)} $}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{{\char `\=}}\texttt{\mbox{\hspace{0.50em}}}\texttt{LamP}\texttt{\mbox{\hspace{0.50em}}}\texttt{\makebox[1.22ex][l]{$ {(} $}}\texttt{$ \lambda $}\texttt{\mbox{\hspace{0.50em}}}\texttt{x}\texttt{\mbox{\hspace{0.50em}}}\texttt{$ \rightarrow $}\texttt{\mbox{\hspace{0.50em}}}\texttt{joinP}\texttt{\mbox{\hspace{0.50em}}}\texttt{\makebox[1.22ex][l]{$ {(} $}}\texttt{f}\texttt{\mbox{\hspace{0.50em}}}\texttt{\makebox[1.22ex][l]{$ {(} $}}\texttt{VarP}\texttt{\mbox{\hspace{0.50em}}}\texttt{x}\texttt{\makebox[1.22ex][r]{$ {)} $}}\texttt{\makebox[1.22ex][r]{$ {)} $}}\texttt{\makebox[1.22ex][r]{$ {)} $}}\texttt{{\nopagebreak \newline%
}\vphantom{$\{$}}\texttt{joinP}\texttt{\mbox{\hspace{0.50em}}}\texttt{\makebox[1.22ex][l]{$ {(} $}}\texttt{AppP}\texttt{\mbox{\hspace{0.50em}}}\texttt{t}\texttt{\mbox{\hspace{0.50em}}}\texttt{u}\texttt{\makebox[1.22ex][r]{$ {)} $}}\texttt{\mbox{\hspace{0.50em}}}\texttt{{\char `\=}}\texttt{\mbox{\hspace{0.50em}}}\texttt{AppP}\texttt{\mbox{\hspace{0.50em}}}\texttt{\makebox[1.22ex][l]{$ {(} $}}\texttt{joinP}\texttt{\mbox{\hspace{0.50em}}}\texttt{t}\texttt{\makebox[1.22ex][r]{$ {)} $}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\makebox[1.22ex][l]{$ {(} $}}\texttt{joinP}\texttt{\mbox{\hspace{0.50em}}}\texttt{u}\texttt{\makebox[1.22ex][r]{$ {)} $}}\texttt{{\nopagebreak \newline%
}\vphantom{$\{$}}%


%
%paragraphName:
On the minus side, all the variables (bound and free) have the
    same representation. This means that they cannot be told apart
    within a term of type{~}\texttt{\makebox[1.22ex][c]{$ \forall $}}\texttt{\mbox{\hspace{0.50em}}}\texttt{a}\texttt{.}\texttt{\mbox{\hspace{0.50em}}}\texttt{TmP}\texttt{\mbox{\hspace{0.50em}}}\texttt{a}. Additionally, once the type
    variable{~}\texttt{a} is instantiated to a closed type, one cannot recover
    the polymorphic version. Furthermore while{~}\texttt{Tm}\texttt{\mbox{\hspace{0.50em}}}\texttt{Zero} denotes a
    closed term, \texttt{TmP}\texttt{\mbox{\hspace{0.50em}}}\texttt{Zero} denotes a term \emph{without} variables,
    hence no term at all. Therefore, whenever a user of PHOAS needs to
    perform some manipulation on terms, they must make an upfront choice
    of a particular instance for the parameter of{~}\texttt{TmP} that supports
    all the required operations on free variables. This limitation is
    not good for modularity, and for code clarity in general. Another
    issue arises from the negative occurrence of the variable type.
    Indeed this makes the type{~}\texttt{TmP} invariant{:} it cannot be made
    a{~}\texttt{Functor} nor a{~}\texttt{Traversable} and this not a proper{~}\texttt{Monad}    either.%


%
%paragraphName:
The use-case of PHOAS presented by Chlipala is the representation
    of well-typed terms. That is, the parameter to{~}\texttt{TmP} can be made
    a type-function, to capture the type associated with each variable.
    This is not our concern here, but we have no reason to believe that
    our technique cannot support this, beyond the lack of proper for
    type-level computation in \textsc{Haskell} --- Chlipala uses \textsc{Coq} for
    his development.%


\subsection{\textsc{Hybrid}}

%
%paragraphName:
In \textsc{Hybrid}, Ambler et al. define a way to define and reason about
    higher-order abstract syntax in the \textsc{Isabelle}{~}\cite{ambler-02} and
    \textsc{Coq}{~}\cite{capretta-06} proof assistants. To do so, as a first
    level they build a representation for $ \lambda $-terms (plus constructors)
    using de{~}Brujin indices. Then as a second level they represent HOAS
    terms using the $ \lambda $-terms of the first level. In this second level
    name abstraction is represented using $ \lambda $-abstractions of the first
    level. Finally HOAS terms can be built using $ \lambda $-abstractions from the
    host language (\textsc{Isabelle} or \textsc{Coq}) as long as these functions are
    accompanied with uniformity proofs. These uniformity proofs rule out
    the exotic terms. Using our approach, parametricity would discharge
    these uniformity proofs.%


\subsection{McBride{'}s {``}Classy Hack{''}}

%
%paragraphName:
\citet{mcbride_not_2010} has devised a set of combinators to
    construct $ \lambda $-terms in de{~}Brujin representation, with the ability to
    refer to bound variables by name. Terms constructed using McBride{'}s
    technique are textually identical to terms constructed using ours.
    Another point of similarity is the use of instance search to recover
    the indices from a host-language variable name. A difference is that
    McBride integrates the injection in the abstraction constructor
    rather than the variable constructor. The type of the \texttt{var}    combinator then becomes simpler, at the expense of \texttt{lam}{:}%


%
%comment: {- --
%


{\nopagebreak }

%
%code:
%
%comment: lam :: ((∀ n. (Leq (S m) n ⇒ Fin n)) → Tm (S m))
%       → Tm m
%var :: Fin n → Tm n
%
~\\~\vphantom{$\{$}\texttt{lam}\texttt{\mbox{\hspace{0.50em}}}\texttt{{:}{:}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\makebox[1.22ex][l]{$ {(} $}}\texttt{\makebox[1.22ex][l]{$ {(} $}}\texttt{\makebox[1.22ex][c]{$ \forall $}}\texttt{\mbox{\hspace{0.50em}}}\texttt{n}\texttt{.}\texttt{\mbox{\hspace{0.50em}}}\texttt{\makebox[1.22ex][l]{$ {(} $}}\texttt{Leq}\texttt{\mbox{\hspace{0.50em}}}\texttt{\makebox[1.22ex][l]{$ {(} $}}\texttt{S}\texttt{\mbox{\hspace{0.50em}}}\texttt{m}\texttt{\makebox[1.22ex][r]{$ {)} $}}\texttt{\mbox{\hspace{0.50em}}}\texttt{n}\texttt{\mbox{\hspace{0.50em}}}\texttt{$ \Rightarrow $}\texttt{\mbox{\hspace{0.50em}}}\texttt{Fin}\texttt{\mbox{\hspace{0.50em}}}\texttt{n}\texttt{\makebox[1.22ex][r]{$ {)} $}}\texttt{\makebox[1.22ex][r]{$ {)} $}}\texttt{\mbox{\hspace{0.50em}}}\texttt{$ \rightarrow $}\texttt{\mbox{\hspace{0.50em}}}\texttt{Tm}\texttt{\mbox{\hspace{0.50em}}}\texttt{\makebox[1.22ex][l]{$ {(} $}}\texttt{S}\texttt{\mbox{\hspace{0.50em}}}\texttt{m}\texttt{\makebox[1.22ex][r]{$ {)} $}}\texttt{\makebox[1.22ex][r]{$ {)} $}}\texttt{{\nopagebreak \newline%
}\vphantom{$\{$}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{$ \rightarrow $}\texttt{\mbox{\hspace{0.50em}}}\texttt{Tm}\texttt{\mbox{\hspace{0.50em}}}\texttt{m}\texttt{{\nopagebreak \newline%
}\vphantom{$\{$}}\texttt{var}\texttt{\mbox{\hspace{0.50em}}}\texttt{{:}{:}}\texttt{\mbox{\hspace{0.50em}}}\texttt{Fin}\texttt{\mbox{\hspace{0.50em}}}\texttt{n}\texttt{\mbox{\hspace{0.50em}}}\texttt{$ \rightarrow $}\texttt{\mbox{\hspace{0.50em}}}\texttt{Tm}\texttt{\mbox{\hspace{0.50em}}}\texttt{n}\texttt{{\nopagebreak \newline%
}\vphantom{$\{$}}%


%
%comment: -- -}
%


%
%paragraphName:
An advantage of McBride{'}s interface is that it does not require the
    {``}incoherent instances{''} extension. %


%
%paragraphName:
However, because McBride represents variables as{~}\texttt{Fin}, the types
    of his combinators are less precise than ours. Notably, the{~}\texttt{Leq}    class captures only one aspect of context inclusion (captured
    by the class{~}\texttt{\makebox[1.83ex][c]{$ \subseteq $}} in our development), namely that one context
    should be smaller than another. This means, for example, that the
    class constraint{~}\texttt{a}\texttt{\mbox{\hspace{0.50em}}}\texttt{\makebox[1.83ex][c]{$ \subseteq $}}\texttt{\mbox{\hspace{0.50em}}}\texttt{b} can be meaningfully resolved in more
    cases than{~}\texttt{Leq}\texttt{\mbox{\hspace{0.50em}}}\texttt{m}\texttt{\mbox{\hspace{0.50em}}}\texttt{n}, in turn making functions such as{~}\texttt{wk}    more useful in practice. Additionally, our{~}\texttt{unpack} and{~}\texttt{pack}    combinators extend the technique to term analysis and manipulation.%


\subsection{\textsc{NomPa} (nominal fragment)}

%
%paragraphName:
\citet{pouillard_unified_2012} describe an interface for names and
    binders which provides maximum safety. The library{~}\textsc{NomPa} is
    written in \textsc{Agda}, using dependent types. The interface makes use
    of a notion of{~}\texttt{World}s (intuitively a set of names),{~}\texttt{Binder}s
    (name declaration), and{~}\texttt{Name}s (the occurrence of a name).
    A{~}\texttt{World} can either be{~}\texttt{Empty} (called{~}\texttt{\makebox[1.22ex][c]{$ \emptyset $}} in the
    library{~}\textsc{NomPa}) in or result of the addition of a{~}\texttt{Binder} to an
    existing{~}\texttt{World}, using the operator \texttt{\makebox[1.22ex][l]{$ {(} $}}\texttt{\makebox[1.22ex][c]{\ensuremath{\triangleleft}}}\texttt{\makebox[1.22ex][r]{$ {)} $}}. The type{~}\texttt{Name} is
    indexed by{~}\texttt{World}s{:} this ties occurrences to the context where
    they make sense.%


%
%comment: {- --
%


{\nopagebreak }

%
%code:
%
%comment: World :: *
%Binder :: *
%Empty :: World
%(◅) :: Binder → World → World
%Name :: World → *
%
~\\~\vphantom{$\{$}\texttt{World}\texttt{\mbox{\hspace{0.50em}}}\texttt{{:}{:}}\texttt{\mbox{\hspace{0.50em}}}\texttt{*}\texttt{{\nopagebreak \newline%
}\vphantom{$\{$}}\texttt{Binder}\texttt{\mbox{\hspace{0.50em}}}\texttt{{:}{:}}\texttt{\mbox{\hspace{0.50em}}}\texttt{*}\texttt{{\nopagebreak \newline%
}\vphantom{$\{$}}\texttt{Empty}\texttt{\mbox{\hspace{0.50em}}}\texttt{{:}{:}}\texttt{\mbox{\hspace{0.50em}}}\texttt{World}\texttt{{\nopagebreak \newline%
}\vphantom{$\{$}}\texttt{\makebox[1.22ex][l]{$ {(} $}}\texttt{\makebox[1.22ex][c]{\ensuremath{\triangleleft}}}\texttt{\makebox[1.22ex][r]{$ {)} $}}\texttt{\mbox{\hspace{0.50em}}}\texttt{{:}{:}}\texttt{\mbox{\hspace{0.50em}}}\texttt{Binder}\texttt{\mbox{\hspace{0.50em}}}\texttt{$ \rightarrow $}\texttt{\mbox{\hspace{0.50em}}}\texttt{World}\texttt{\mbox{\hspace{0.50em}}}\texttt{$ \rightarrow $}\texttt{\mbox{\hspace{0.50em}}}\texttt{World}\texttt{{\nopagebreak \newline%
}\vphantom{$\{$}}\texttt{Name}\texttt{\mbox{\hspace{0.50em}}}\texttt{{:}{:}}\texttt{\mbox{\hspace{0.50em}}}\texttt{World}\texttt{\mbox{\hspace{0.50em}}}\texttt{$ \rightarrow $}\texttt{\mbox{\hspace{0.50em}}}\texttt{*}\texttt{{\nopagebreak \newline%
}\vphantom{$\{$}}%


%
%comment: -- -}
%


%
%paragraphName:
On top of these abstract notions, one can construct the following
    representation of terms (we use a \textsc{Haskell}-style syntax for
    dependent types, similar to that of \textsc{Idris}){:}%


%
%comment: {- --
%


{\nopagebreak }

%
%code:
%
%comment: data Tm α where
%  Var :: Name α → Tm α
%  App :: Tm α → Tm α → Tm α
%  Lam :: (b :: Binder) → Tm (b ◅ α) → Tm α
%
~\\~\vphantom{$\{$}\texttt{data}\texttt{\mbox{\hspace{0.50em}}}\texttt{Tm}\texttt{\mbox{\hspace{0.50em}}}\texttt{\makebox[1.22ex][c]{$ \alpha $}}\texttt{\mbox{\hspace{0.50em}}}\texttt{where}\texttt{{\nopagebreak \newline%
}\vphantom{$\{$}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{Var}\texttt{\mbox{\hspace{0.50em}}}\texttt{{:}{:}}\texttt{\mbox{\hspace{0.50em}}}\texttt{Name}\texttt{\mbox{\hspace{0.50em}}}\texttt{\makebox[1.22ex][c]{$ \alpha $}}\texttt{\mbox{\hspace{0.50em}}}\texttt{$ \rightarrow $}\texttt{\mbox{\hspace{0.50em}}}\texttt{Tm}\texttt{\mbox{\hspace{0.50em}}}\texttt{\makebox[1.22ex][c]{$ \alpha $}}\texttt{{\nopagebreak \newline%
}\vphantom{$\{$}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{App}\texttt{\mbox{\hspace{0.50em}}}\texttt{{:}{:}}\texttt{\mbox{\hspace{0.50em}}}\texttt{Tm}\texttt{\mbox{\hspace{0.50em}}}\texttt{\makebox[1.22ex][c]{$ \alpha $}}\texttt{\mbox{\hspace{0.50em}}}\texttt{$ \rightarrow $}\texttt{\mbox{\hspace{0.50em}}}\texttt{Tm}\texttt{\mbox{\hspace{0.50em}}}\texttt{\makebox[1.22ex][c]{$ \alpha $}}\texttt{\mbox{\hspace{0.50em}}}\texttt{$ \rightarrow $}\texttt{\mbox{\hspace{0.50em}}}\texttt{Tm}\texttt{\mbox{\hspace{0.50em}}}\texttt{\makebox[1.22ex][c]{$ \alpha $}}\texttt{{\nopagebreak \newline%
}\vphantom{$\{$}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{Lam}\texttt{\mbox{\hspace{0.50em}}}\texttt{{:}{:}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\makebox[1.22ex][l]{$ {(} $}}\texttt{b}\texttt{\mbox{\hspace{0.50em}}}\texttt{{:}{:}}\texttt{\mbox{\hspace{0.50em}}}\texttt{Binder}\texttt{\makebox[1.22ex][r]{$ {)} $}}\texttt{\mbox{\hspace{0.50em}}}\texttt{$ \rightarrow $}\texttt{\mbox{\hspace{0.50em}}}\texttt{Tm}\texttt{\mbox{\hspace{0.50em}}}\texttt{\makebox[1.22ex][l]{$ {(} $}}\texttt{b}\texttt{\mbox{\hspace{0.50em}}}\texttt{\makebox[1.22ex][c]{\ensuremath{\triangleleft}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\makebox[1.22ex][c]{$ \alpha $}}\texttt{\makebox[1.22ex][r]{$ {)} $}}\texttt{\mbox{\hspace{0.50em}}}\texttt{$ \rightarrow $}\texttt{\mbox{\hspace{0.50em}}}\texttt{Tm}\texttt{\mbox{\hspace{0.50em}}}\texttt{\makebox[1.22ex][c]{$ \alpha $}}\texttt{{\nopagebreak \newline%
}\vphantom{$\{$}}%


%
%comment: -- -}
%


%
%paragraphName:
The safety of the technique comes from the abstract character of the
    interface. If one were to give concrete definitions for \texttt{Binder},
    \texttt{World} and their related operations, it would become possible for
    user code to cheat the system.
    A drawback of the interface being abstract is that some subterms
    do not evaluate. This point is of prime concern in the context of
    reasoning about programs involving binders.
    In contrast, our interfaces are concrete (code using it always
    evaluates), but it requires the user to choose the representation
    appropriate to the current use (\texttt{SuccScope}, \texttt{UnivScope} or
    \texttt{ExistScope}).%


\section{Discussion\label{discussion}}

\subsection{Binding Many Variables}

%
%paragraphName:
    In \texttt{SuccScope}, there is exactly one more free variable available in the sub-term.
    However, it might be useful to bind multiple names at once in a binder. This can 
    be done by using a type \texttt{n} of the appropriate cardinality instead of \texttt{\makebox[1.22ex][l]{$ {(} $}}\texttt{\makebox[1.22ex][r]{$ {)} $}}.
    This technique has been used for example by \citet{bound-kmett-12}.%


{\nopagebreak }

%
%code:
%
%comment: type NScope n tm a = tm (a :▹ n)
%
~\\~\vphantom{$\{$}\texttt{type}\texttt{\mbox{\hspace{0.50em}}}\texttt{NScope}\texttt{\mbox{\hspace{0.50em}}}\texttt{n}\texttt{\mbox{\hspace{0.50em}}}\texttt{tm}\texttt{\mbox{\hspace{0.50em}}}\texttt{a}\texttt{\mbox{\hspace{0.50em}}}\texttt{{\char `\=}}\texttt{\mbox{\hspace{0.50em}}}\texttt{tm}\texttt{\mbox{\hspace{0.50em}}}\texttt{\makebox[1.22ex][l]{$ {(} $}}\texttt{a}\texttt{\mbox{\hspace{0.50em}}}\texttt{$ \vartriangleright $}\texttt{\mbox{\hspace{0.50em}}}\texttt{n}\texttt{\makebox[1.22ex][r]{$ {)} $}}\texttt{{\nopagebreak \newline%
}\vphantom{$\{$}}%


%
%paragraphName:
Adapting the idea to our framework would mean to quantify over a family of types,
    indexed by a type \texttt{n} of the appropriate cardinality{:}%


%
%comment: {- --
%


{\nopagebreak }

%
%code:
%
%comment: type NUnivScope  n tm a = ∀v. (n → v) → tm (a :▹ v)
%type NExistScope n tm a = ∃v.((n → v) , tm (a :▹ v))
%
~\\~\vphantom{$\{$}\texttt{type}\texttt{\mbox{\hspace{0.50em}}}\texttt{NUnivScope}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{n}\texttt{\mbox{\hspace{0.50em}}}\texttt{tm}\texttt{\mbox{\hspace{0.50em}}}\texttt{a}\texttt{\mbox{\hspace{0.50em}}}\texttt{{\char `\=}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\makebox[1.22ex][c]{$ \forall $}}\texttt{v}\texttt{.}\texttt{\mbox{\hspace{0.50em}}}\texttt{\makebox[1.22ex][l]{$ {(} $}}\texttt{n}\texttt{\mbox{\hspace{0.50em}}}\texttt{$ \rightarrow $}\texttt{\mbox{\hspace{0.50em}}}\texttt{v}\texttt{\makebox[1.22ex][r]{$ {)} $}}\texttt{\mbox{\hspace{0.50em}}}\texttt{$ \rightarrow $}\texttt{\mbox{\hspace{0.50em}}}\texttt{tm}\texttt{\mbox{\hspace{0.50em}}}\texttt{\makebox[1.22ex][l]{$ {(} $}}\texttt{a}\texttt{\mbox{\hspace{0.50em}}}\texttt{$ \vartriangleright $}\texttt{\mbox{\hspace{0.50em}}}\texttt{v}\texttt{\makebox[1.22ex][r]{$ {)} $}}\texttt{{\nopagebreak \newline%
}\vphantom{$\{$}}\texttt{type}\texttt{\mbox{\hspace{0.50em}}}\texttt{NExistScope}\texttt{\mbox{\hspace{0.50em}}}\texttt{n}\texttt{\mbox{\hspace{0.50em}}}\texttt{tm}\texttt{\mbox{\hspace{0.50em}}}\texttt{a}\texttt{\mbox{\hspace{0.50em}}}\texttt{{\char `\=}}\texttt{\mbox{\hspace{0.50em}}}\texttt{$ \exists $}\texttt{v}\texttt{.}\texttt{\makebox[1.22ex][l]{$ {(} $}}\texttt{\makebox[1.22ex][l]{$ {(} $}}\texttt{n}\texttt{\mbox{\hspace{0.50em}}}\texttt{$ \rightarrow $}\texttt{\mbox{\hspace{0.50em}}}\texttt{v}\texttt{\makebox[1.22ex][r]{$ {)} $}}\texttt{\mbox{\hspace{0.50em}}}\texttt{,}\texttt{\mbox{\hspace{0.50em}}}\texttt{tm}\texttt{\mbox{\hspace{0.50em}}}\texttt{\makebox[1.22ex][l]{$ {(} $}}\texttt{a}\texttt{\mbox{\hspace{0.50em}}}\texttt{$ \vartriangleright $}\texttt{\mbox{\hspace{0.50em}}}\texttt{v}\texttt{\makebox[1.22ex][r]{$ {)} $}}\texttt{\makebox[1.22ex][r]{$ {)} $}}\texttt{{\nopagebreak \newline%
}\vphantom{$\{$}}%


%
%comment: -- -}
%


\subsection{Delayed Substitutions}

%
%paragraphName:
The main performance issue with de{~}Brujn indices comes from the cost
    of importing terms into scopes without capture, which requires to
    increment free variables in the substituted term (see \texttt{fmap}\texttt{\mbox{\hspace{0.50em}}}\texttt{Old}    in the definition of \texttt{liftSubst}). This transformation incurs not
    only a direct cost proportional to the size of terms, but also an
    indirect cost in the form of loss of sharing.%


%
%paragraphName:
\Citet{bird-paterson-99} propose a solution to this issue, which can
    be expressed simply as another implementation of binders, where free
    variables of the inner term stand for whole terms with one less free
    variable{:}%


{\nopagebreak }

%
%code:
%
%comment: type DelayedScope tm a = tm (tm a :▹ ())
%
~\\~\vphantom{$\{$}\texttt{type}\texttt{\mbox{\hspace{0.50em}}}\texttt{DelayedScope}\texttt{\mbox{\hspace{0.50em}}}\texttt{tm}\texttt{\mbox{\hspace{0.50em}}}\texttt{a}\texttt{\mbox{\hspace{0.50em}}}\texttt{{\char `\=}}\texttt{\mbox{\hspace{0.50em}}}\texttt{tm}\texttt{\mbox{\hspace{0.50em}}}\texttt{\makebox[1.22ex][l]{$ {(} $}}\texttt{tm}\texttt{\mbox{\hspace{0.50em}}}\texttt{a}\texttt{\mbox{\hspace{0.50em}}}\texttt{$ \vartriangleright $}\texttt{\mbox{\hspace{0.50em}}}\texttt{\makebox[1.22ex][l]{$ {(} $}}\texttt{\makebox[1.22ex][r]{$ {)} $}}\texttt{\makebox[1.22ex][r]{$ {)} $}}\texttt{{\nopagebreak \newline%
}\vphantom{$\{$}}%


%
%paragraphName:
This means that the parallel substitution for a term representation 
    based on \texttt{DelayedScope} does not require lifting of substitutions.%


{\nopagebreak }

%
%code:
%
%comment: data TmD a where
%  VarD :: a → TmD a
%  LamD :: DelayedScope TmD a → TmD a
%  AppD :: TmD a → TmD a → TmD a
%
~\\~\vphantom{$\{$}\texttt{data}\texttt{\mbox{\hspace{0.50em}}}\texttt{TmD}\texttt{\mbox{\hspace{0.50em}}}\texttt{a}\texttt{\mbox{\hspace{0.50em}}}\texttt{where}\texttt{{\nopagebreak \newline%
}\vphantom{$\{$}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{VarD}\texttt{\mbox{\hspace{0.50em}}}\texttt{{:}{:}}\texttt{\mbox{\hspace{0.50em}}}\texttt{a}\texttt{\mbox{\hspace{0.50em}}}\texttt{$ \rightarrow $}\texttt{\mbox{\hspace{0.50em}}}\texttt{TmD}\texttt{\mbox{\hspace{0.50em}}}\texttt{a}\texttt{{\nopagebreak \newline%
}\vphantom{$\{$}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{LamD}\texttt{\mbox{\hspace{0.50em}}}\texttt{{:}{:}}\texttt{\mbox{\hspace{0.50em}}}\texttt{DelayedScope}\texttt{\mbox{\hspace{0.50em}}}\texttt{TmD}\texttt{\mbox{\hspace{0.50em}}}\texttt{a}\texttt{\mbox{\hspace{0.50em}}}\texttt{$ \rightarrow $}\texttt{\mbox{\hspace{0.50em}}}\texttt{TmD}\texttt{\mbox{\hspace{0.50em}}}\texttt{a}\texttt{{\nopagebreak \newline%
}\vphantom{$\{$}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{AppD}\texttt{\mbox{\hspace{0.50em}}}\texttt{{:}{:}}\texttt{\mbox{\hspace{0.50em}}}\texttt{TmD}\texttt{\mbox{\hspace{0.50em}}}\texttt{a}\texttt{\mbox{\hspace{0.50em}}}\texttt{$ \rightarrow $}\texttt{\mbox{\hspace{0.50em}}}\texttt{TmD}\texttt{\mbox{\hspace{0.50em}}}\texttt{a}\texttt{\mbox{\hspace{0.50em}}}\texttt{$ \rightarrow $}\texttt{\mbox{\hspace{0.50em}}}\texttt{TmD}\texttt{\mbox{\hspace{0.50em}}}\texttt{a}\texttt{{\nopagebreak \newline%
}\vphantom{$\{$}}%


%
%code:
{\noindent}%
%comment: instance Monad TmD where
%  return = VarD
%  VarD a   >>= θ = θ a
%  AppD a b >>= θ = AppD (a >>= θ) (b >>= θ)
%  LamD t   >>= θ = LamD (mapOld (>>= θ) <$> t)
%
\vphantom{$\{$}\texttt{instance}\texttt{\mbox{\hspace{0.50em}}}\texttt{Monad}\texttt{\mbox{\hspace{0.50em}}}\texttt{TmD}\texttt{\mbox{\hspace{0.50em}}}\texttt{where}\texttt{{\nopagebreak \newline%
}\vphantom{$\{$}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{return}\texttt{\mbox{\hspace{0.50em}}}\texttt{{\char `\=}}\texttt{\mbox{\hspace{0.50em}}}\texttt{VarD}\texttt{{\nopagebreak \newline%
}\vphantom{$\{$}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{VarD}\texttt{\mbox{\hspace{0.50em}}}\texttt{a}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\makebox[1.22ex][c]{\textgreater{}}\makebox[1.22ex][c]{\textgreater{}}{\char `\=}}\texttt{\mbox{\hspace{0.50em}}}\texttt{$ \theta $}\texttt{\mbox{\hspace{0.50em}}}\texttt{{\char `\=}}\texttt{\mbox{\hspace{0.50em}}}\texttt{$ \theta $}\texttt{\mbox{\hspace{0.50em}}}\texttt{a}\texttt{{\nopagebreak \newline%
}\vphantom{$\{$}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{AppD}\texttt{\mbox{\hspace{0.50em}}}\texttt{a}\texttt{\mbox{\hspace{0.50em}}}\texttt{b}\texttt{\mbox{\hspace{0.50em}}}\texttt{\makebox[1.22ex][c]{\textgreater{}}\makebox[1.22ex][c]{\textgreater{}}{\char `\=}}\texttt{\mbox{\hspace{0.50em}}}\texttt{$ \theta $}\texttt{\mbox{\hspace{0.50em}}}\texttt{{\char `\=}}\texttt{\mbox{\hspace{0.50em}}}\texttt{AppD}\texttt{\mbox{\hspace{0.50em}}}\texttt{\makebox[1.22ex][l]{$ {(} $}}\texttt{a}\texttt{\mbox{\hspace{0.50em}}}\texttt{\makebox[1.22ex][c]{\textgreater{}}\makebox[1.22ex][c]{\textgreater{}}{\char `\=}}\texttt{\mbox{\hspace{0.50em}}}\texttt{$ \theta $}\texttt{\makebox[1.22ex][r]{$ {)} $}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\makebox[1.22ex][l]{$ {(} $}}\texttt{b}\texttt{\mbox{\hspace{0.50em}}}\texttt{\makebox[1.22ex][c]{\textgreater{}}\makebox[1.22ex][c]{\textgreater{}}{\char `\=}}\texttt{\mbox{\hspace{0.50em}}}\texttt{$ \theta $}\texttt{\makebox[1.22ex][r]{$ {)} $}}\texttt{{\nopagebreak \newline%
}\vphantom{$\{$}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{LamD}\texttt{\mbox{\hspace{0.50em}}}\texttt{t}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\makebox[1.22ex][c]{\textgreater{}}\makebox[1.22ex][c]{\textgreater{}}{\char `\=}}\texttt{\mbox{\hspace{0.50em}}}\texttt{$ \theta $}\texttt{\mbox{\hspace{0.50em}}}\texttt{{\char `\=}}\texttt{\mbox{\hspace{0.50em}}}\texttt{LamD}\texttt{\mbox{\hspace{0.50em}}}\texttt{\makebox[1.22ex][l]{$ {(} $}}\texttt{mapOld}\texttt{\mbox{\hspace{0.50em}}}\texttt{\makebox[1.22ex][l]{$ {(} $}}\texttt{\makebox[1.22ex][c]{\textgreater{}}\makebox[1.22ex][c]{\textgreater{}}{\char `\=}}\texttt{\mbox{\hspace{0.50em}}}\texttt{$ \theta $}\texttt{\makebox[1.22ex][r]{$ {)} $}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\makebox[1.22ex][c]{\textless{}}\${}\makebox[1.22ex][c]{\textgreater{}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{t}\texttt{\makebox[1.22ex][r]{$ {)} $}}\texttt{{\nopagebreak \newline%
}\vphantom{$\{$}}%


%
%paragraphName:
Because idea of delayed substitutions is concerned with free
    variables, and the concepts we present here is concerned with bound
    variables, one can easily define scopes which are both delayed
    and safe. Hence the performance gain is compatible with our safe
    interface.%


%
%comment: {- --
%


{\nopagebreak }

%
%code:
%
%comment: type UnivScope'  tm a = ∀v. (v → tm (tm a :▹ v))
%type ExistScope' tm a = ∃v. (v ,  tm (tm a :▹ v))
%
~\\~\vphantom{$\{$}\texttt{type}\texttt{\mbox{\hspace{0.50em}}}\texttt{UnivScope{'}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{tm}\texttt{\mbox{\hspace{0.50em}}}\texttt{a}\texttt{\mbox{\hspace{0.50em}}}\texttt{{\char `\=}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\makebox[1.22ex][c]{$ \forall $}}\texttt{v}\texttt{.}\texttt{\mbox{\hspace{0.50em}}}\texttt{\makebox[1.22ex][l]{$ {(} $}}\texttt{v}\texttt{\mbox{\hspace{0.50em}}}\texttt{$ \rightarrow $}\texttt{\mbox{\hspace{0.50em}}}\texttt{tm}\texttt{\mbox{\hspace{0.50em}}}\texttt{\makebox[1.22ex][l]{$ {(} $}}\texttt{tm}\texttt{\mbox{\hspace{0.50em}}}\texttt{a}\texttt{\mbox{\hspace{0.50em}}}\texttt{$ \vartriangleright $}\texttt{\mbox{\hspace{0.50em}}}\texttt{v}\texttt{\makebox[1.22ex][r]{$ {)} $}}\texttt{\makebox[1.22ex][r]{$ {)} $}}\texttt{{\nopagebreak \newline%
}\vphantom{$\{$}}\texttt{type}\texttt{\mbox{\hspace{0.50em}}}\texttt{ExistScope{'}}\texttt{\mbox{\hspace{0.50em}}}\texttt{tm}\texttt{\mbox{\hspace{0.50em}}}\texttt{a}\texttt{\mbox{\hspace{0.50em}}}\texttt{{\char `\=}}\texttt{\mbox{\hspace{0.50em}}}\texttt{$ \exists $}\texttt{v}\texttt{.}\texttt{\mbox{\hspace{0.50em}}}\texttt{\makebox[1.22ex][l]{$ {(} $}}\texttt{v}\texttt{\mbox{\hspace{0.50em}}}\texttt{,}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{tm}\texttt{\mbox{\hspace{0.50em}}}\texttt{\makebox[1.22ex][l]{$ {(} $}}\texttt{tm}\texttt{\mbox{\hspace{0.50em}}}\texttt{a}\texttt{\mbox{\hspace{0.50em}}}\texttt{$ \vartriangleright $}\texttt{\mbox{\hspace{0.50em}}}\texttt{v}\texttt{\makebox[1.22ex][r]{$ {)} $}}\texttt{\makebox[1.22ex][r]{$ {)} $}}\texttt{{\nopagebreak \newline%
}\vphantom{$\{$}}%


%
%comment: -- -}
%


\subsection{Future Work{:} Improving Safety}

%
%paragraphName:
As it stands our interface prevents mistakes in the manipulation of de{~}Bruijn indices, but
    requires a collaboration from the user. 
    Indeed, a malicious user can instantiate \texttt{v} 
    to a monotype either in the analysis of
    \texttt{\makebox[1.22ex][c]{$ \forall $}}\texttt{\mbox{\hspace{0.50em}}}\texttt{v}\texttt{.}\texttt{\mbox{\hspace{0.50em}}}\texttt{v}\texttt{\mbox{\hspace{0.50em}}}\texttt{$ \rightarrow $}\texttt{\mbox{\hspace{0.50em}}}\texttt{tm}\texttt{\mbox{\hspace{0.50em}}}\texttt{\makebox[1.22ex][l]{$ {(} $}}\texttt{a}\texttt{\mbox{\hspace{0.50em}}}\texttt{$ \vartriangleright $}\texttt{\mbox{\hspace{0.50em}}}\texttt{v}\texttt{\makebox[1.22ex][r]{$ {)} $}} or in the construction of \texttt{$ \exists $}\texttt{\mbox{\hspace{0.50em}}}\texttt{v}\texttt{.}\texttt{\mbox{\hspace{0.50em}}}\texttt{\makebox[1.22ex][l]{$ {(} $}}\texttt{v,}\texttt{\mbox{\hspace{0.50em}}}\texttt{tm}\texttt{\mbox{\hspace{0.50em}}}\texttt{\makebox[1.22ex][l]{$ {(} $}}\texttt{a}\texttt{\mbox{\hspace{0.50em}}}\texttt{$ \vartriangleright $}\texttt{\mbox{\hspace{0.50em}}}\texttt{v}\texttt{\makebox[1.22ex][r]{$ {)} $}}\texttt{\makebox[1.22ex][r]{$ {)} $}}. This situation can be improved 
    by providing a quantifier which allows to substitute for type variables other type variables only.
    This
    quantifier can be understood as being at the same time existential and universal, 
    and hence is self dual.
    We use the notation \texttt{\ensuremath{\nabla}} (pronounced nabla) for it, due to the similarity with the quantifier
    of the same name introduced by \citet{miller_proof_2003}.
    We would then have the following definitions, and safety could not be compromised. %


%
%comment: {- --
%


{\nopagebreak }

%
%code:
%
%comment: type UnivScope  tm a = ∇ v.  v → tm (a :▹ v)
%type ExistScope tm a = ∇ v. (v ,  tm (a :▹ v))
%
~\\~\vphantom{$\{$}\texttt{type}\texttt{\mbox{\hspace{0.50em}}}\texttt{UnivScope}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{tm}\texttt{\mbox{\hspace{0.50em}}}\texttt{a}\texttt{\mbox{\hspace{0.50em}}}\texttt{{\char `\=}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\ensuremath{\nabla}}\texttt{\mbox{\hspace{0.50em}}}\texttt{v}\texttt{.}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{v}\texttt{\mbox{\hspace{0.50em}}}\texttt{$ \rightarrow $}\texttt{\mbox{\hspace{0.50em}}}\texttt{tm}\texttt{\mbox{\hspace{0.50em}}}\texttt{\makebox[1.22ex][l]{$ {(} $}}\texttt{a}\texttt{\mbox{\hspace{0.50em}}}\texttt{$ \vartriangleright $}\texttt{\mbox{\hspace{0.50em}}}\texttt{v}\texttt{\makebox[1.22ex][r]{$ {)} $}}\texttt{{\nopagebreak \newline%
}\vphantom{$\{$}}\texttt{type}\texttt{\mbox{\hspace{0.50em}}}\texttt{ExistScope}\texttt{\mbox{\hspace{0.50em}}}\texttt{tm}\texttt{\mbox{\hspace{0.50em}}}\texttt{a}\texttt{\mbox{\hspace{0.50em}}}\texttt{{\char `\=}}\texttt{\mbox{\hspace{0.50em}}}\texttt{\ensuremath{\nabla}}\texttt{\mbox{\hspace{0.50em}}}\texttt{v}\texttt{.}\texttt{\mbox{\hspace{0.50em}}}\texttt{\makebox[1.22ex][l]{$ {(} $}}\texttt{v}\texttt{\mbox{\hspace{0.50em}}}\texttt{,}\texttt{\mbox{\hspace{0.50em}}}\texttt{\mbox{\hspace{0.50em}}}\texttt{tm}\texttt{\mbox{\hspace{0.50em}}}\texttt{\makebox[1.22ex][l]{$ {(} $}}\texttt{a}\texttt{\mbox{\hspace{0.50em}}}\texttt{$ \vartriangleright $}\texttt{\mbox{\hspace{0.50em}}}\texttt{v}\texttt{\makebox[1.22ex][r]{$ {)} $}}\texttt{\makebox[1.22ex][r]{$ {)} $}}\texttt{{\nopagebreak \newline%
}\vphantom{$\{$}}%


%
%comment: -- -}
%


%
%paragraphName:
   These definitions would preclude using \texttt{SuccScope} as an implementation, 
   however this should not cause any issue{:} either of the above could be used directly
   as an implementation.
   Supporting our version of \texttt{\ensuremath{\nabla}} in a type-checker seems a rather modest extension,
   therefore we wish to investigate how some future version of GHC could support it.
   %


\subsection{Future Work{:} Improve Performance}

%
%paragraphName:
An apparent issue with the presented conversion functions between
    \texttt{UnivScope} or \texttt{ExistScope} on one side and \texttt{SuccScope} on the
    other side is that all but \texttt{succToExist} cost a time 
    proportional to the size of the term converted. In the current state of affairs, we 
    might be able to use a system of rewrite rules, such as that implemented in GHC, to 
    eliminate the conversions to and from the safe interfaces. However, within
    a system which supports \ensuremath{\nabla}-quantification, a better option offers itself{:}
    the machine-representation of the type \texttt{v} should be
    nil (nothing at all) if \texttt{v} is a \ensuremath{\nabla}-bound variable; 
    therefore the machine-implementation of the conversions
    can be the identity.%


\subsection{Future Work{:} No Injections}

%
%paragraphName: getting rid of the injections by using a stronger type system
    We use the instance search of GHC in a very specific way{:} only to discover in injections.
    This suggests that a special-purpose type-system (featuring a form of subtyping)
    could be built to take care of those injections automatically.
    An obvious benefit would be some additional shortening of programs manipulating terms.
    Additionally, this simplification of programs would imply an
    even greater simplification of the proofs about them; indeed, a variation in complexity in
    an object usually yields a greater variation in complexity in proofs about it.
  %


\subsection{Conclusion}

%
%paragraphName:
  We have shown how to make de{~}Bruijn indices safe, by typing them precisely with 
  the context where they make sense. Such precise contexts are obtained is by using (appropriately)
  either of the interfaces \texttt{UnivScope} or \texttt{ExistScope}. These two interfaces can 
  be seen as the both sides of the \ensuremath{\nabla} quantifier of \citet{miller_proof_2003}. 
  Essentially, we have deconstructed that flavor of quantification over names, 
  and implemented it in \textsc{Haskell}. The result is a safe method to manipulate names
  and binders, which is supported by today{'}s Glasgow Haskell Compiler.%


%
%paragraphName:
  The method preserves the good properties of de{~}Bruijn indices, while providing
  a convenient interface to program with multiple open binders. We have illustrated 
  these properties by exhibiting the implementation of a number of examples.
  %


\acks{}The second author was supported in part by grant 10-092309 from
    the Danish Council for Strategic Research, Programme Commission
    on Strategic Growth Technologies. We thank Emil Axelsson, Koen
    Claessen, Daniel Gustafsson and Patrik Jansson for useful feedback.

\bibliographystyle{abbrvnat}

\bibliography{../../local,../../npouillard,../../jp}

\newpage

\end{document}
